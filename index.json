[{"categories":["力扣hot100"],"content":"在数组中查找元素的第一个和最后一个位置 在数组中查找元素的第一个和最后一个位置 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例1 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] ","date":"2023-03-15","objectID":"/%E5%8A%9B%E6%89%A3hot18_%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/:0:0","tags":["力扣hot100"],"title":"力扣hot100_18_在数组中查找元素的第一个和最后一个位置","uri":"/%E5%8A%9B%E6%89%A3hot18_%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"},{"categories":["力扣hot100"],"content":"题解和思路 使用两个二分 第一个二分将r往target处移动，如果有target，则l和r会逐渐重合，找出第一个target的下标 第二个二分将l往最后的target处移动，如果有target，则l和r会逐渐重合，找出最后一个target的下标 class Solution { public: vector\u003cint\u003e searchRange(vector\u003cint\u003e\u0026 nums, int target) { vector\u003cint\u003e ans = {-1,-1}; int len = nums.size(); if(len == 0)return ans; int l = 0; int r = len - 1; while(l\u003cr){ int mid = ( l + r ) \u003e\u003e 1; if(nums[mid]\u003e=target){ r = mid; }else{ l = mid + 1; } } if(nums[l]!=target)return ans; ans[0] = l; l = 0; r = len - 1; while(l\u003cr){ int mid = (l + r + 1) \u003e\u003e 1; if(nums[mid]\u003c=target){ l = mid; }else{ r = mid - 1; } } ans[1] = l; return ans; } }; ","date":"2023-03-15","objectID":"/%E5%8A%9B%E6%89%A3hot18_%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/:1:0","tags":["力扣hot100"],"title":"力扣hot100_18_在数组中查找元素的第一个和最后一个位置","uri":"/%E5%8A%9B%E6%89%A3hot18_%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"},{"categories":["力扣hot100"],"content":"搜索旋转排序数组 搜索旋转排序数组 整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 \u003c= k \u003c nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。 示例1 输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 ","date":"2023-03-14","objectID":"/%E5%8A%9B%E6%89%A3hot17_%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/:0:0","tags":["力扣hot100"],"title":"力扣hot100_17_搜索旋转排序数组","uri":"/%E5%8A%9B%E6%89%A3hot17_%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"categories":["力扣hot100"],"content":"题解和思路 可以通过mid和target的关系来判断target究竟处于哪个空间 在判断的同时还需要注意left 和 right 是否逆序 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0; int right = nums.size()-1; while(left \u003c= right){ int mid = (left + right)\u003e\u003e1; if(nums[mid]==target)return mid; if(nums[left]\u003c=nums[mid]){ if(nums[left]\u003c=target\u0026\u0026target\u003cnums[mid]){ right = mid -1; }else{ left = mid + 1; } }else{ if(target\u003enums[mid]\u0026\u0026target\u003c=nums[right]){ left = mid + 1; }else{ right = mid - 1; } } } return -1; } }; ","date":"2023-03-14","objectID":"/%E5%8A%9B%E6%89%A3hot17_%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/:1:0","tags":["力扣hot100"],"title":"力扣hot100_17_搜索旋转排序数组","uri":"/%E5%8A%9B%E6%89%A3hot17_%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"categories":["力扣hot100"],"content":"括号生成 括号生成 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例1 输入：n = 3 输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] ","date":"2023-03-10","objectID":"/%E5%8A%9B%E6%89%A3hot13_%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/:0:0","tags":["力扣hot100"],"title":"力扣hot100_13_括号生成","uri":"/%E5%8A%9B%E6%89%A3hot13_%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"categories":["力扣hot100"],"content":"题解和思路 使用回溯算法 可以按照左右括号的匹配情况判断 优先使用左括号，如果左括号小于右括号，则使用右括号 class Solution { public: vector\u003cstring\u003e generateParenthesis(int n) { if(n\u003c=0){ return ans; } dfs(\"\",n,n); return ans; } private: vector\u003cstring\u003e ans; void dfs(const string \u0026str,int left,int right){ if(left==0\u0026\u0026right==0){ ans.push_back(str); return; } //优先使用左括号 if(left\u003e0){ dfs(str+'(',left-1,right); } if(left\u003cright){ dfs(str+')',left,right-1); } } }; ","date":"2023-03-10","objectID":"/%E5%8A%9B%E6%89%A3hot13_%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/:1:0","tags":["力扣hot100"],"title":"力扣hot100_13_括号生成","uri":"/%E5%8A%9B%E6%89%A3hot13_%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"categories":["力扣hot100"],"content":"合并两个有序链表 合并两个有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的 示例1 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] ","date":"2023-03-10","objectID":"/%E5%8A%9B%E6%89%A3hot12_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/:0:0","tags":["力扣hot100"],"title":"力扣hot100_12_合并两个有序链表","uri":"/%E5%8A%9B%E6%89%A3hot12_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["力扣hot100"],"content":"题解和思路 循环遍历两个链表，对比大小，小的插入到新链表 直到某个链表为空 继续循环不为空的链表插入到新链表 返回新链表 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode* head = new ListNode(0); ListNode* tail = head; while(list1\u0026\u0026list2){ int v1 = list1-\u003eval; int v2 = list2-\u003eval; if(v1\u003ev2){ tail-\u003enext=new ListNode(v2); tail = tail-\u003enext; list2 = list2-\u003enext; }else{ tail-\u003enext=new ListNode(v1); tail = tail-\u003enext; list1 = list1-\u003enext; } } while(list1){ tail-\u003enext=new ListNode(list1-\u003eval); tail = tail-\u003enext; list1 = list1-\u003enext; } while(list2){ tail-\u003enext=new ListNode(list2-\u003eval); tail = tail-\u003enext; list2 = list2-\u003enext; } return head-\u003enext; } }; ","date":"2023-03-10","objectID":"/%E5%8A%9B%E6%89%A3hot12_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/:1:0","tags":["力扣hot100"],"title":"力扣hot100_12_合并两个有序链表","uri":"/%E5%8A%9B%E6%89%A3hot12_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["力扣hot100"],"content":"有效括号 有效括号 给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 示例1 输入：s = \"()[]{}\" 输出：true ","date":"2023-03-09","objectID":"/%E5%8A%9B%E6%89%A3hot11_%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/:0:0","tags":["力扣hot100"],"title":"力扣hot100_11_有效括号","uri":"/%E5%8A%9B%E6%89%A3hot11_%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"},{"categories":["力扣hot100"],"content":"题解和思路 使用栈 将括号的组合放入哈希表中 依次判断即可 class Solution { public: map\u003cchar,char\u003e map = { {')', '('}, {']', '['}, {'}', '{'} }; bool isValid(string s1) { if(s1.size()%2 == 1)return false; stack\u003cchar\u003e z; for(char ch : s1){ if(map.count(ch)){ if(z.empty()||z.top()!=map[ch]){ return false; } z.pop(); }else{ z.push(ch); } } return z.empty(); } }; ","date":"2023-03-09","objectID":"/%E5%8A%9B%E6%89%A3hot11_%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/:1:0","tags":["力扣hot100"],"title":"力扣hot100_11_有效括号","uri":"/%E5%8A%9B%E6%89%A3hot11_%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"},{"categories":["力扣hot100"],"content":"删除链表倒数第N个节点 删除链表倒数第N个节点 题目: 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例1 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] ","date":"2023-03-09","objectID":"/%E5%8A%9B%E6%89%A3hot10_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/:0:0","tags":["力扣hot100"],"title":"力扣hot100_10_删除链表倒数第N个节点","uri":"/%E5%8A%9B%E6%89%A3hot10_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["力扣hot100"],"content":"题解和思路 使用快慢指针 定义一个fast指向head 定义一个新的ListNode节点dummy，并将其next指向head，让slow指针指向dummy 对fast进行遍历 遍历次数为n(倒数节点的值); 然后我们对slow和fast都进行遍历，直到fast节点指向null。这样slow就指向了倒数第n个节点。 那么如果我们让slow指向dummy，再进行遍历，就可以得到需要删除的节点的前置节点，就便于删除 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { //快慢指针 ListNode *dummy = new ListNode(0,head); ListNode *fast = head; ListNode *slow = dummy; for(int i = 0;i\u003cn;i++){ fast = fast-\u003enext; } while(fast){ fast=fast-\u003enext; slow=slow-\u003enext; } slow-\u003enext = slow-\u003enext-\u003enext; return dummy-\u003enext; } }; ","date":"2023-03-09","objectID":"/%E5%8A%9B%E6%89%A3hot10_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/:1:0","tags":["力扣hot100"],"title":"力扣hot100_10_删除链表倒数第N个节点","uri":"/%E5%8A%9B%E6%89%A3hot10_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["力扣hot100"],"content":"电话号码的字母组合 电话号码的字母组合 题目: 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 “”,\" “,“abc”,“def”,“ghi”,“jkl”,“mno”,“pqrs”,“tuv”,“wxyz” 示例1 输入：digits = \"23\" 输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] ","date":"2023-03-09","objectID":"/%E5%8A%9B%E6%89%A3hot9_%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/:0:0","tags":["力扣hot100"],"title":"力扣hot100_9_电话号码的字母组合","uri":"/%E5%8A%9B%E6%89%A3hot9_%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"categories":["力扣hot100"],"content":"题解和思路 定义一个全局number变量去存储电话号码按键。 使用回溯法去回溯。 class Solution { public: vector\u003cstring\u003e number = {\"\",\" \",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}; void dfs(vector\u003cstring\u003e \u0026ans,const string \u0026digits,int pos,string\u0026 temp){ if(pos==digits.size()){ ans.push_back(temp); return; } int num = digits[pos] - '0'; for(int i=0;i\u003cnumber[num].size();i++){ char ch = number[num][i]; temp.push_back(ch); dfs(ans,digits,pos+1,temp); temp.pop_back(); } } vector\u003cstring\u003e letterCombinations(string digits) { vector\u003cstring\u003e ans; string temp; if(digits.size()\u003c1)return ans; dfs(ans,digits,0,temp); return ans; } }; ","date":"2023-03-09","objectID":"/%E5%8A%9B%E6%89%A3hot9_%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/:1:0","tags":["力扣hot100"],"title":"力扣hot100_9_电话号码的字母组合","uri":"/%E5%8A%9B%E6%89%A3hot9_%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"categories":["力扣hot100"],"content":"三数之和 三数之和 题目: 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请 你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例1 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 解释： nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 ","date":"2023-03-08","objectID":"/%E5%8A%9B%E6%89%A3hot8_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/:0:0","tags":["力扣hot100"],"title":"力扣hot100_8_三数之和","uri":"/%E5%8A%9B%E6%89%A3hot8_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["力扣hot100"],"content":"题解和思路 三个数之和，可以先固定一个数，再在内层使用双指针从除i外的两端开始向内查找， 并且，需要每次都对三个数进行查重。 class Solution { public: vector\u003cvector\u003cint\u003e\u003e threeSum(vector\u003cint\u003e\u0026 nums) { //创建答案数组 vector\u003cvector\u003cint\u003e\u003e ans; //判断长度 if(nums.size()\u003c3||nums.empty()) return ans; //排序 sort(nums.begin(),nums.end()); //从头循环 int i = 0 ; while(i\u003cnums.size()){ if(nums[i]\u003e0)break;//提前终止 int left = i+1; int right = nums.size()-1; while(left\u003cright){ int x = nums[i]; int y = nums[left]; int z = nums[right]; if(x + y \u003e0 - z){ right-- ; }else if(x + y \u003c 0 - z){ left ++; }else{ ans.push_back({nums[i],nums[left],nums[right]}); //不允许重复 while(left\u003cright\u0026\u0026nums[left] == nums[left+1]){ left++; } while(left\u003cright\u0026\u0026nums[right] == nums[right-1]){ right--; } left++; right--; } } //避免nums[i]重复 while(i+1\u003cnums.size()\u0026\u0026nums[i]==nums[i+1]){ i++; } i++; } return ans; } }; ","date":"2023-03-08","objectID":"/%E5%8A%9B%E6%89%A3hot8_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/:1:0","tags":["力扣hot100"],"title":"力扣hot100_8_三数之和","uri":"/%E5%8A%9B%E6%89%A3hot8_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["力扣hot100"],"content":"盛最多水的容器 盛最多水的容器 题目: 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器 示例1 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 ","date":"2023-03-08","objectID":"/%E5%8A%9B%E6%89%A3hot7_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/:0:0","tags":["力扣hot100"],"title":"力扣hot100_7_盛最多水的容器","uri":"/%E5%8A%9B%E6%89%A3hot7_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["力扣hot100"],"content":"题解和思路 双指针 双向向中间遍历 判断哪边最短，选取最短的边的计算结果 最短边向中间移动一格 返回结果 class Solution { public: int maxArea(vector\u003cint\u003e\u0026 height) { int left = 0; int right = height.size()-1; int ans = 0; while(left \u003c right){ if(height[right]\u003eheight[left]){ int area = height[left] *(right - left ); ans = max(ans,area); left++; }else{ int area = height[right] *(right - left ); ans = max(ans,area); right--; } } return ans; } }; ","date":"2023-03-08","objectID":"/%E5%8A%9B%E6%89%A3hot7_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/:1:0","tags":["力扣hot100"],"title":"力扣hot100_7_盛最多水的容器","uri":"/%E5%8A%9B%E6%89%A3hot7_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["力扣hot100"],"content":"最长回文子串 最长回文子串 题目: 给你一个字符串 s，找到 s 中最长的回文子串。 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。 示例1 输入：s = \"babad\" 输出：\"bab\" 解释：\"aba\" 同样是符合题意的答案 ","date":"2023-03-08","objectID":"/%E5%8A%9B%E6%89%A3hot5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:0:0","tags":["力扣hot100"],"title":"力扣hot100_5_最长回文子串","uri":"/%E5%8A%9B%E6%89%A3hot5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"categories":["力扣hot100"],"content":"题解和思路 //中心扩散法 从字符串的每一个index开始操作; 如果往左边字符串相同，则长度+1 直到没有重复 如果往右边字符串相同，则长度+1 直到没有重复 然后开始 向两边扩张，left的字母等于right 的字母，则长度+2; 进行一轮判断之后，如果长度比maxlen大，将left赋值给maxleft right赋值给maxright 重复 class Solution { public: string longestPalindrome(string s) { //使用中心扩散方法 int maxleft = 0; int maxright = 0; int maxlen = 0; int len = 1 ; for(int mid = 0; mid \u003c s.size() ;mid++){ int left = mid - 1; //重复字符串左边界 int right = mid + 1; //重复字符串右边界限 while( left \u003e= 0 \u0026\u0026 s[left] == s[mid]){ left --; len++; } while(right \u003c= s.size()-1\u0026\u0026s[right]==s[mid]){ right++; len++; } while(left \u003e=0 \u0026\u0026 right \u003c=s.size()-1 \u0026\u0026 s[left] == s[right]){ left -- ; right ++ ; len +=2; } if(len \u003e maxlen){ maxleft = left; maxright = right; maxlen = len; } len = 1; } return s.substr(maxleft + 1,maxlen); } }; ","date":"2023-03-08","objectID":"/%E5%8A%9B%E6%89%A3hot5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:1:0","tags":["力扣hot100"],"title":"力扣hot100_5_最长回文子串","uri":"/%E5%8A%9B%E6%89%A3hot5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"categories":["力扣hot100"],"content":"无重复字符的最长子串 无重复字符的最长子串 题目: 给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。 示例1 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 ","date":"2023-03-07","objectID":"/%E5%8A%9B%E6%89%A3hot3_%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:0:0","tags":["力扣hot100"],"title":"力扣hot100_3_无重复字符的最长子串","uri":"/%E5%8A%9B%E6%89%A3hot3_%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["力扣hot100"],"content":"题解和思路 创建一个桶，其内的元素为128个，并将其置为0; 创建一个最大长度值maxvalue = 0; 创建一个指向最左边的变量head = 0; 循环访问字符串s内的每一个元素; head代表不重复字符串最左边的字符的下标，如果重复出现了a，则当前head的值为上一个v[a]内的值，而上一个v[a]内的值是上一个a的下标加1，这样可以让窗口往前移动。 最大值为已经计算的最大值，和 当前不重复字符串的最大值的对比。 class Solution { public: int lengthOfLongestSubstring(string s) { //判断是否为0 if(s.size()==0)return 0; // 滑动窗口 vector\u003cint\u003e v(128,0); int head = 0; int maxvalue = 0; for(int i =0;i\u003cs.size();i++){ head = max(head,v[s[i]]); v[s[i]] = i + 1 ; maxvalue = max(maxvalue , i - head + 1); } return maxvalue; } }; ","date":"2023-03-07","objectID":"/%E5%8A%9B%E6%89%A3hot3_%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:0","tags":["力扣hot100"],"title":"力扣hot100_3_无重复字符的最长子串","uri":"/%E5%8A%9B%E6%89%A3hot3_%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["力扣hot100"],"content":"两数相加 两数相加 题目: 给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储 一位数字。 请你将两个数相加，并以相同形式返回一个表示和的链表 示例1 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. ","date":"2023-03-07","objectID":"/%E5%8A%9B%E6%89%A3hot2_%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:0:0","tags":["力扣hot100"],"title":"力扣hot100_2_两数相加","uri":"/%E5%8A%9B%E6%89%A3hot2_%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["力扣hot100"],"content":"题解和思路 创建一个ListNode *head作为链表头 创建一个ListNode *tail作为链表尾部. 使用||符号，不去判断每个链表的节点是否为空，直到两个链表都到达链表最后。 创建新链表内的值 为两个链表内值相加 / 10 循环到最后的时候判断一下carry是否\u003e0 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *head = new ListNode(0); ListNode *tail = head; int sum = 0; int carry = 0; while(l1 || l2){ sum += (l1!=NULL?l1-\u003eval:0); sum += (l2!=NULL?l2-\u003eval:0); sum += carry; tail-\u003enext = new ListNode( sum % 10); tail = tail-\u003enext; carry = sum / 10; sum = 0; l1 = l1-\u003enext; l2 = l2-\u003enext; } if(carry\u003e0){ tail-\u003enext = new ListNode( carry ); tail = tail-\u003enext ; } return head-\u003enext; } }; ","date":"2023-03-07","objectID":"/%E5%8A%9B%E6%89%A3hot2_%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:1:0","tags":["力扣hot100"],"title":"力扣hot100_2_两数相加","uri":"/%E5%8A%9B%E6%89%A3hot2_%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["力扣hot100"],"content":"两数之和 两数之和 题目： 给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值 target 的那两个整数,并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 示例1 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 ","date":"2023-03-07","objectID":"/%E5%8A%9B%E6%89%A3hot1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:0:0","tags":["力扣hot100"],"title":"力扣hot100_1_两数之和","uri":"/%E5%8A%9B%E6%89%A3hot1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["力扣hot100"],"content":"思路和题解 创建一个ans的vector容器 创建一个map的哈希表 遍历nums内的元素，并查找哈希表内target - nums[i]的值是否在哈希表内，不在则将键值对为key:nums[i],value:i 加入到哈希表中，如果target - nums[i]的值在哈希表内，则将当前值的index和目标值的index加入到ans中，并返回即可。 单次hash遍历的时间复杂度为O(n). class Solution { public: vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 nums, int target) { vector\u003cint\u003e ans; map\u003cint,int\u003e map; ans.push_back(-1); ans.push_back(-1); for(int i = 0;i \u003c nums.size();i++){ if(map.count(target - nums[i])\u003e0){ ans[0] = (map[target - nums[i]]); ans[1] = i; return ans; } map[nums[i]] = i; } return ans; } }; ","date":"2023-03-07","objectID":"/%E5%8A%9B%E6%89%A3hot1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:1:0","tags":["力扣hot100"],"title":"力扣hot100_1_两数之和","uri":"/%E5%8A%9B%E6%89%A3hot1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["Linux网络编程实战"],"content":"1.阻塞/非阻塞,同步/异步 典型的一次IO的两个阶段：数据的就绪和数据的读写 数据就绪:根据系统IO操作的就绪状态 1.阻塞 调用IO方法的线程进入阻塞状态，如果没数据，线程被挂起 2.非阻塞 不会改变线程的状态，通过返回值判断 -------------------------------------------- 数据读写:根据应用程序和内核的交互方式 1.同步 例如读数据，读取内核缓冲区数据，直到读取完，我们才知道有多少数据，才可以执行下面步骤 2.异步 例如读数据，读取内核缓冲区数据，我们不管读没读完，我们都可以执行下面的代码 一个典型的网络IO接口的调用，分为两个阶段，分别是数据就绪和数据读写。数据就绪阶段分为阻塞和非阻塞。表现的结果就是，阻塞当前线程或者直接返回。 同步表示A向B请求一个网络接口IO的时候(或者调用某个业务逻辑API接口时)，数据的读写都是由请求方A自己来完成的(不管阻塞或者非阻塞);异步表示A向B请求调用一个网络接口IO时(或者调用某个业务API接口时),向B传入请求事件，以及事件发生时通知的方式，A就可以处理其他逻辑了，当B监听到事件处理完成之后，会用事先约定好的通知方式，通知A处理结果 ","date":"2023-03-06","objectID":"/%E9%98%BB%E5%A1%9E_%E9%9D%9E%E9%98%BB%E5%A1%9E/:0:0","tags":["Linux网络编程实战"],"title":"阻塞/阻塞_同步/异步","uri":"/%E9%98%BB%E5%A1%9E_%E9%9D%9E%E9%98%BB%E5%A1%9E/"},{"categories":["Linux网络编程"],"content":"UDP ","date":"2023-03-06","objectID":"/udp%E9%80%9A%E4%BF%A1/:0:0","tags":["Linux网络编程"],"title":"UDP","uri":"/udp%E9%80%9A%E4%BF%A1/"},{"categories":["Linux网络编程"],"content":"UDP通信 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e ssize_t sendto(int sockfd,const void *buf,size_t len,int flags,const struct sockaddr *dest_addr,socklen_t addrlen); 参数: -sockfd：通信的fd -buf:需要发送的数据 -len:数组的大小 -flags:设置一些标志 -dest_addr:通信的另外一端的地址信息 -addrlen :地址的内存大小 返回值:。。。 ssize_t recvfrom(int sockfd,void *buf,size_t len,int flags,struct sockaddr *src_addr,socklen_t *addrlen); 参数 -sockfd:通信的fd -buf:接受数据的数组 -len:数组的大小 -flags:0 -src_addr:接收方的地址指针 -addrlen:接收方地址的内存大小 ","date":"2023-03-06","objectID":"/udp%E9%80%9A%E4%BF%A1/:1:0","tags":["Linux网络编程"],"title":"UDP","uri":"/udp%E9%80%9A%E4%BF%A1/"},{"categories":["Linux网络编程"],"content":"广播 向子网中多台计算机发送消息，并且子网中所有计算机都可以接受到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1 a.只能在局域网中使用 b.客户端要绑定服务器广播使用的端口，才可以接收到广播的消息。 //设置广播属性 int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen); sockfd：文件描述符 level:级别 SOL_SOCKET optname:SO_BROADCAST optval : 1表示允许广播 optlen : optval的大小 ","date":"2023-03-06","objectID":"/udp%E9%80%9A%E4%BF%A1/:2:0","tags":["Linux网络编程"],"title":"UDP","uri":"/udp%E9%80%9A%E4%BF%A1/"},{"categories":["Linux网络编程"],"content":"组播 单播地址标识单个IP接口，广播地址标识某个子网的所有IP接口，多播地址标识一组IP接口。单播是寻址方案的两个极端(要么单个要么全部)，多播则实在两者之间提供一个折中的方案。多播数据报只应该由对它感兴趣的接口接受。也就是说由允许相应多播会话系统的主机上的接口接受。另外，广播一般局限于局域网使用，而多播既可以用于局域网，也可跨局域网使用。 a.既可以局域网，也可以跨局域网 b.客户端需要加入多播组，才能接收到多播的数据 ","date":"2023-03-06","objectID":"/udp%E9%80%9A%E4%BF%A1/:3:0","tags":["Linux网络编程"],"title":"UDP","uri":"/udp%E9%80%9A%E4%BF%A1/"},{"categories":["Linux网络编程"],"content":"组播地址 IP多播通信必须依赖于IP多播地址，在IPv4中它的范围224.0.0.0到239.255.255.255,并被划分为局部链接多播地址，预留多播地址和管理权限多播地址三类。 设置组播 int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen); //服务器设置多播信息，外出接口 sockfd：文件描述符 level:级别 IPPROTO_IP optname: optval : struct in_addr optlen : optval的大小 //客户端加入到多播组 -level :IPPROTO_IP -optname : IP_ADD_MEMBERSHIP -optval : struct ip_mreqn; struct ip_mreq{ //组播组的IP地址 struct in_addr_imr_multiaddr; //组播组的ip地址 //本地某一网路设备接口的IP地址 struct in_addr imr_address; int imr_ifindex; //网卡编号 } typedef uint32_t in_addr_t; struct in_addr{ } ","date":"2023-03-06","objectID":"/udp%E9%80%9A%E4%BF%A1/:3:1","tags":["Linux网络编程"],"title":"UDP","uri":"/udp%E9%80%9A%E4%BF%A1/"},{"categories":["Linux网络编程"],"content":"IO多路复用 I/O 多路复用使得程序能够同时监听多个文件描述符，能够提高程序的性能，Linux下实现I/O多路复用的系统调用主要有select ，poll和epoll ","date":"2023-03-05","objectID":"/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/:0:0","tags":["Linux网络编程"],"title":"IO多路复用(select,poll,epoll)","uri":"/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"},{"categories":["Linux网络编程"],"content":"2.select 缺点： 1.每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大。 2.同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多的时候也很大。 3.select支持的文件描述符数量太小了，默认是1024 4.fds集合不能重用，每次都需要重置。 /* 主旨思想： 1.要构造一个关于文件描述符的列表(将要监听的文件描述符) 2.调用系统函数 select，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行了I/O操作时，该函数才返回。 a:这个函数时阻塞的 b:函数对文件描述符的检测是由内核完成的 3.在返回时，它会告诉进程有多少(哪些)描述符进行I/O操作。 //sizeof(fd_set) = 128 ----\u003e1024bit */ #include \u003csys/time.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e #includ \u003csys/select.h\u003e int select(int nfds,fd_set *readfds,fd_set *writefds, fd_set *exceptfds,struct timeval *timeout); -参数 -nfds:委托内核检测的最大文件描述符的值 + 1 -readfds:要检测的读的文件描述符的集合，委托内核检测哪些文件描述符的读的属性。 一般只检测读操作。 对应的是对方发送过来的数据，因为读是被动的接受数据，检测的是读缓冲区。 -writefds:要检测的文件描述符的写集合，委托内核检测哪些文件描述符的写的属性。 委托内核检测写缓冲区是不是还可以写数据(不满就可以写)。 -exceptfds:检测发生异常的文件操作描述符的集合。 -timeout:设置的超时时间 struct timeval { long tv_sec; /* seconds */ long tv_usec; /* microseconds */ }; -NULL：永久阻塞 -tv_sec=0,tv_usec =0; 不阻塞 -tv_sec\u003e0,tv_usec \u003e0; 阻塞对应的时间 -返回值： --1:失败 \u003e0:检测的集合中有n个文件描述符发生变化 //将参数文件描述符fd对应的标志位清零 void FD_CLR(int fd,fd_set *set); //判断fd对应的标志位是0还是1，返回值是fd对应的标志位的值 int FD_ISSET(int fd,fd_set *set); //将fd对应的标志位设为1 void FD_SET(int fd,fd_set *set); //清空整个标志位 void FD_ZERO(fd_set *set); ","date":"2023-03-05","objectID":"/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/:1:0","tags":["Linux网络编程"],"title":"IO多路复用(select,poll,epoll)","uri":"/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"},{"categories":["Linux网络编程"],"content":"3.poll 1.移除了select的大小的限制 2.移除了fds这样的不可重用的限制。 #include \u003cpoll.h\u003e struct pollfd{ int fd; //委托内核检测的文件描述符 short events;//委托内核检测文件描述符的什么事件 short revents;//文件描述符实际发生的事件 }; int poll(struct pollfd *fds,nfds_t nfds,int timeout); 参数: -fds:结构体数组，需要检测的文件描述符集合 -nfs:这个是第一个参数数组中最后一个有效元素的下标 + 1 -timeout :阻塞时长 -1：永远阻塞 0:不阻塞 1：阻塞，当检测到需要检测的文件描述符有变化，就解除阻塞 返回值: -1：失败 \u003e0：成功 表示检测到集合中有n个文件描述符发生变化。 ","date":"2023-03-05","objectID":"/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/:2:0","tags":["Linux网络编程"],"title":"IO多路复用(select,poll,epoll)","uri":"/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"},{"categories":["Linux网络编程"],"content":"epoll #include \u003csys/epoll.h\u003e //在内核中创建了一个新的实例，在这个数据中有两个重要的数据，一个数需要检测文件描述符信息的红黑树，还有一个就绪列表，存放检测到数据发生改变的文件描述符的信息(双向链表) int epoll_create(int size); -参数: size:目前乜有意义了，随便写一个就行。 -返回值 -1:失败 \u003e0:文件描述符，操作epoll实例的 typedef union epoll_data{ void *ptr; int fd; uint32_t u32; uint64_t u64; }epoll_data_t; struct epoll_event{ uint32_t events; //epoll event epoll_data_t data; //user data variable }; //对epoll实例进行管理：添加，删除，修改 int epoll_ctl(int epfd,int op,int fd,struct epoll_event *event); 参数: epfd:epoll实例 op：进行什么操作 fd：需要操作的文件描述符 event：对该文件描述符需要检测的事件 //检测函数 int epoll_wait(int epfd,struct epoll_event *events,int maxevents,int timeout); 参数: epfd:epoll实例 events:传出参数，保存了发生变化的文件描述符的信息 maxevents：发生改变的事件的数量(第二个参数的大小) timeout：阻塞时间 0：不阻塞 -1：阻塞，直到检测到数据发生变化 \u003e0：阻塞时长 返回值： 成功:返回发生变化的文件描述符的个数 失败:返回-1 ","date":"2023-03-05","objectID":"/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/:3:0","tags":["Linux网络编程"],"title":"IO多路复用(select,poll,epoll)","uri":"/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"},{"categories":["Linux网络编程"],"content":"Epoll的工作模式 LT模式(水平触发) 假设委托内核检测该事件 ---\u003e 检测fd缓冲区 读缓冲区有数据 ---\u003eepoll检测到会给用户通知 a.用户不读数据 数据一直在缓冲区，epoll一直通知 b.用户只读了一部分，epoll继续通知 c.缓冲区的数据读完了,不通知 LT(level-triggered)是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个描述符的fd进行I/O操作。如果你不作任何操作，内核还是会继续通知你。 ET模式(边沿触发) 假设委托内核检测该事件 ---\u003e 检测fd缓冲区 读缓冲区有数据 ---\u003eepoll检测到会给用户通知 a.用户不读数据，数据一直在缓冲区,epoll下一次检测就不通知了 b.用户只读了一部分数据，epoll不通知 c.缓冲区的数据读完了,不通知 ET(edge-triggered)是高速工作方式，只支持no-block scoket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你，然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，知道你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个fd做I/O操作(从而导致它再次编程未就绪)，内核不会发送更多的通知(only once)。 ET模式在很大程度上减少了epoll时间被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述的任务饿死。 ","date":"2023-03-05","objectID":"/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/:3:1","tags":["Linux网络编程"],"title":"IO多路复用(select,poll,epoll)","uri":"/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"},{"categories":["Linux网络编程"],"content":"半关闭 当TCP连接中A向B发送FIN请求关闭，另一端B回应ACK之后(A端进入FIN_WAIT_2状态)，并没有立即发送FIN给A，A方处于半连接状态(半开关),此时A可以接受B发送的数据，但是A已经不能再向B发送数据。 从程序的角度可以使用API控制实现半连接状态: #include \u003csys/socket.h\u003e int shutdown(int sockfd,int how); sockfd:需要关闭的sockfd描述符 how:允许为shutdown操作选择一下几种方式 SHUT_RD(0):关闭sockfd上的读功能，此选项不允许sockfd进行读操作。该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。 SHUT_WR(1):关闭sockfd的写功能，此选项不允许sockfd进行写操作，进程不能再对此套接字发出写操作。 SHUT_PDWR(2):关闭sockfd的读写功能、 使用close终止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。shutdown不考虑描述符的引用计数，直接关闭描述符。也可选择终止一个方向的连接。 注意： 1.如果有多个进程共享一个套接字，close没被调用一次，计数减1，直到计数为0时，也就是所有进程都调用了close，套接字被释放。 2.在多进程中如果一个进程调用了shutdown(sfd,SHUT_RDWR)后，其它的进程将无法进行通信。但如果一个进程close(sfd)将不会影响进程。 端口复用 端口复用的最常用的用途是： 1.防止服务器重启时之前绑定的端口还未释放。 2.程序突然退出而系统没有释放端口。 #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e //设置套接字的属性 int setsockopt(int sockfd,int level,int optname,const void*optval,socklen_t optlen); 参数 -sockfd:要操作的文件描述符 -level:级别 ：SOL_SOCKET（端口复用级别） -optname : 选项的名 -SO_REUSEADDR -SO_REUSERPORT - optval: 端口复用的值(整型) -1:可以复用 -0:不可以复用 - optlen: optval参数的大小 端口复用，设置的时机是在服务器绑定端口之前、 查看网络相关信息的命令 netstat: 参数: -a 所有的socket -p 显示正在使用socket的程序的名称 -n 直接使用IP地址，而不通过域名服务器 -l 显示正在监听的socket ","date":"2023-03-05","objectID":"/%E5%8D%8A%E5%85%B3%E9%97%AD-%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/:0:0","tags":["Linux网络编程"],"title":"端口复用","uri":"/%E5%8D%8A%E5%85%B3%E9%97%AD-%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/"},{"categories":["Linux网络编程"],"content":"TCP通信流程 ! //TCP通信流程 //服务器端(被动接受的角色) 1.创建一个用于监听的套接字 -监听：监听有无客户端连接 -套接字：这个套接字其实是一个文件描述符 2.将这个监听文件描述符和本地的Ip和端口绑定(IP和端口就是服务器的地址信息); -客户端连接服务器的时候使用的就是这个ip和端口 3.设置监听，监听的fd开始工作 4.阻塞等待，当有客户端发起连接，接触阻塞，接受客户端的连接，会得到一个和客户端通信的套接字(fd) 5.通信 - 接收数据 - 发送数据 6.通信结束，断开连接 //客户端 1.创建一个用于通信的套接字 2.连接服务器，需要指定的服务器的ip和端口 3.通信 -接收数据 -发送数据 4.通信结束，断开连接 socket编程有三种 1.流式套接字(SOCKET_STREAM) 2.数据报式套接字(SOCKET_DGRAM) 3,原始套接字(SOCKET_RAW) 前两者较常使用，基于TCP使用的是SOCKET_STREAM(流式套接字) 服务端 1.socket():创建流式socket int socket(int, int, int); 头文件： #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e 函数原型： int socket(int domain, int type, int protocol) domain: 协议类型，一般为AF_INET type: socket类型(SOCKET_STREAM,SOCKET_DGRAM,SOCKET_RAW) protocol:用来指定socket所使用的传输协议编号，通常设为0即可 2.bind():指定用于通信的IP地址和port端口 bind() 头文件： #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e 函数原型： int bind(int sockfd, struct sockaddr *my_addr, int addrlen) sockfd: socket描述符 my_addr:是一个指向包含有本机ip地址和端口号等信息的sockaddr类型的指针 addrlen:常被设为sizeof(struct sockaddr) 3.listen():把socket设为监听对象 3 listen() 头文件： #include \u003csys/socket.h\u003e 函数原型： int listen(int sockfd, int backlog); sockfd:socket()系统调用返回的socket描述符 backlog:指定在请求队列中的最大请求数，进入的连接请求将在队列中等待accept()它们。 4.accept():接受客户端发来的连接请求 4 accept() 头文件： #include \u003csys/types.h\u003e #inlcude \u003csys/socket.h\u003e 函数原型： int accept(int sockfd, void *addr, int addrlen) sockfd:是被监听的socket描述符 addr:通常是一个指向sockaddr_in变量的指针，该变量用来存放提出连接请求服务的主机的信息 addrlen:sizeof(struct sockaddr_in) 5.recv()/send():接受或者发送 send() 头文件： #include \u003csys/socket.h\u003e 函数原型： int send(int sockfd, const void *msg, int len, int flags); sockfd:用来传输数据的socket描述符 msg:要发送数据的指针 flags: 0 recv() 头文件： #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e 函数原型: int recv(int sockfd, void *buf, int len, unsigned int flags) sockfd：接收数据的socket描述符 buf:存放数据的缓冲区 len:缓冲的长度 flags:0 6.close():关闭socket连接 客户端 1.socket():创建流式套接字 2.connect():连接服务器，发起请求 3.send()/recv():接受或者发送 4.close():关闭socket连接 释放资源 ","date":"2023-03-04","objectID":"/socket%E9%80%9A%E4%BF%A1/:1:0","tags":["Linux网络编程"],"title":"Socket通信","uri":"/socket%E9%80%9A%E4%BF%A1/"},{"categories":["Linux网络编程"],"content":"备注 htons 头文件: #include \u003carpa/inet.h\u003e uint16_t htons(uint16_t hostshort);　htons的功能： 将一个无符号短整型数值转换为网络字节序，即大端模式(big-endian)　参数u_short hostshort: 16位无符号整数　返回值: TCP / IP网络字节顺序. htonl() #include \u003carpa/inet.h\u003e　uint32_t htonl(uint32_t hostlong);　简述：将主机的无符号长整形数转换成网络字节顺序。　hostlong：主机字节顺序表达的32位数。　注释： 本函数将一个32位数从主机字节顺序转换成网络字节顺序。　返回值：　htonl()返回一个网络字节顺序的值。 使用gethostname(const char *name); 返回如下结构体 struct hostent { char *h_name; /* official name of host */ char **h_aliases; /* alias list */ int h_addrtype; /* host address type */ int h_length; /* length of address */ char **h_addr_list; /* list of addresses */ } hostent-\u003eh_name 表示的是主机的规范名。例如www.baidu.com的规范名其实是www.a.shifen.com。 hostent-\u003eh_aliases 表示的是主机的别名。www.baidu.com就是baidu他自己的别名。 hostent-\u003eh_addrtype 表示的是主机ip地址的类型。只会是ipv4(AF_INET)， 这个函数处理不了ipv6 hostent-\u003eh_length 表示的是主机ip地址的长度。 hostent-\u003eh_addr_list 表示的是主机的ip地址。是网络字节序，需要通过inet_ntop函数转换。 ","date":"2023-03-04","objectID":"/socket%E9%80%9A%E4%BF%A1/:2:0","tags":["Linux网络编程"],"title":"Socket通信","uri":"/socket%E9%80%9A%E4%BF%A1/"},{"categories":["Linux网络编程"],"content":"代码样例 需求:客户端向服务器发送消息，服务器回传该消息给客户端。 服务器部分: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e #include \u003cstring.h\u003e //服务端 int main(){ int socket_fd,connect_fd; struct sockaddr_in saddr,caddr; //创建套接字 if((socket_fd=socket(AF_INET,SOCK_STREAM,0))==-1){ perror(\"socket\"); exit(0); } //定义服务器地址 saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = htonl(INADDR_ANY); saddr.sin_port = htons(8000); if((bind(socket_fd,(struct sockaddr *)\u0026saddr,sizeof(saddr)))==-1){ perror(\"bind\"); exit(0); } //监听 if((listen(socket_fd,10))==-1){ perror(\"listen\"); exit(0); } //阻塞接受 socklen_t clen = sizeof(caddr); if((connect_fd=accept(socket_fd,(struct sockaddr * )\u0026caddr,\u0026clen))==-1){ perror(\"accept\"); exit(0); } //客户端信息 char cip[16];//客户端ip inet_ntop(AF_INET,\u0026caddr.sin_addr.s_addr,cip,sizeof(cip)); unsigned int cport = ntohs(caddr.sin_port);//客户端端口 //接受消息 char recvbuf[1024]={0}; while(1){ // recvbuf int num = read(connect_fd, recvbuf, sizeof(recvbuf)); if(num == -1) { perror(\"read\"); exit(-1); } else if(num \u003e 0) { printf(\"我接受到了客户端的数据 : %s\\n\", recvbuf); } else if(num == 0) { // 表示客户端断开连接 printf(\"clinet closed...\\n\"); break; } char * data = recvbuf; // 给客户端发送数据（实现回射服务器） write(connect_fd, data, strlen(data)); } //关闭文件描述符 close(connect_fd); close(socket_fd); return 0; } 客户端部分 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e #include \u003cstring.h\u003e int main(){ int socket_fd; struct sockaddr_in saddr; //描述符 if((socket_fd = socket(AF_INET,SOCK_STREAM,0))==-1){ perror(\"socket\"); exit(0); } //设置服务器信息 saddr.sin_family=AF_INET; inet_pton(AF_INET,\"127.0.0.1\",\u0026saddr.sin_addr.s_addr); saddr.sin_port=htons(8000); //连接 int ret = connect(socket_fd, (struct sockaddr *)\u0026saddr, sizeof(saddr)); if(ret == -1) { perror(\"connect\"); exit(-1); } //发送消息 char recvbuf[1024]={0}; while(1){ // 从键盘输入，给客户端发送数据 char data[1024]; memset(data,0,sizeof data); printf(\"请输入发送数据：\"); scanf(\"%s\", data); write(socket_fd, data , strlen(data)); sleep(1); int len = read(socket_fd, recvbuf, sizeof(recvbuf)); if(len == -1) { perror(\"read\"); exit(-1); } else if(len \u003e 0) { printf(\"我接受到了回射服务器的返回的数据 : %s\\n\", recvbuf); } else if(len == 0) { // 表示服务器端断开连接 printf(\"server closed...\\n\"); break; } } close(socket_fd); return 0; } ","date":"2023-03-04","objectID":"/socket%E9%80%9A%E4%BF%A1/:2:1","tags":["Linux网络编程"],"title":"Socket通信","uri":"/socket%E9%80%9A%E4%BF%A1/"},{"categories":["Linux网络编程"],"content":"socket地址 ","date":"2023-03-04","objectID":"/socket%E5%9C%B0%E5%9D%80/:0:0","tags":["Linux网络编程"],"title":"Socket地址","uri":"/socket%E5%9C%B0%E5%9D%80/"},{"categories":["Linux网络编程"],"content":"通用socket地址 socket网络编程接口中表示socket地址的是结构体sockaddr，其定义如下： #include \u003cbits/socket.h\u003e struct sockaddr { sa_family_t sa_family; char sa_data[14]; }; typedef unsigned short int sa_family_t; sa_family成员是地址族类型(sa_family_t)的变量。地址族类型通常与协议族类型对应，常见的协议族(protocol family,也成domain)和对应的地址族如下所示: 协议族 地址族 描述 PF_UNIX AF_UNIX UNIX本地域协议族 PF_INET AF_INET TCP/IPv4协议族 PF_INET6 AF_INET6 TCP/IPv6协议族 宏PF_*和AF_*都定义在bit/socket.h头文件中，且后者与前者有完全相同的值，所有二者通常混用。sa_data成员用于存放socket地址值.但是，不同的协议族的地址值具有不同的含义和长度，如下表示： 协议族 地址值含义和长度 PF_UNIX 文件的路径名，长度可达到108字节 PF_INET 16bit端口号和32bitIPv4地址，共6字节 PF_INET6 16bit端口号，32bit流标识，128bitIPv6地址，32bit范围ID，共26字节 由上表可知，14字节的sa_data根本无法容纳多数协议族的地址值。因此，Linux定义了下面这个新的通用socket地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对象的。 #include \u003cbits/socket.h\u003e struct sockadr_storage{ sa_family_t sa_family; unsigned long int __sa_align; char __ss_padding[128 - sizeof(__sa_align)]; } typedef unsigned short int sa_family_t; ","date":"2023-03-04","objectID":"/socket%E5%9C%B0%E5%9D%80/:1:0","tags":["Linux网络编程"],"title":"Socket地址","uri":"/socket%E5%9C%B0%E5%9D%80/"},{"categories":["Linux网络编程"],"content":"专用socket地址 很多网络编程函数诞生早于IPv4协议，那时候都使用的是struct sockaddr结构体，为了向前兼容，现在的sockaddr退化成(void *)的作用，传递一个地址给函数，至于这个函数时sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转换为所需的地址类型。 UNIX本地域协议族使用如下专用的socket地址结构体 #include \u003csys/un.h\u003e struct sockaddr_un{ sa_family_t sin_family; char sun_path[108]; } TCP/IP协议族由sockaddr_in和sockaddr_in6两个专用的socket地址结构体，他们分别用于IPv4和Ipv6 #include \u003cnetinet/in.h\u003e struct sockaddr_in{ sa_family_t sa_family; in_port_t sin_port; struct in_addr sin_addr; unsigned char sin_zero[sizeof(struct sockaddr)-__SOCKADDR_COMMON_SIZE-sizeof(in_port_t)-sizeof(struct in_addr)]; }; struct in_addr{ in_addr_t s_addr; }; struct sockaddr_in6{ sa_family_t sa_family; in_port_t sin6_port; uint32_t sin6_flowinfo; struct in6_addr sin6_addr; uint32_t sin6_scope_id; }; typedef unsigned short uint16_t; typedef unsigned int uint32_t; typedef uint16_t in_port_t; typedef uint32_t in_addr_t; #define __SOCKADDR_COMMON_SIZE (sizeof(unsigned short int)) 所有专用socket地址(以及sockaddr_storage)类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr(强制转换即可),因为所有socket编程接口使用的地址参数类型都是sockaddr。 IP地址转换 通常，人们习惯用可读性好的字符串来表示ip地址，比如用点分十进制字符串表示IPv4地址，以及用十六进制字符串表示IPv6地址。但编程中我们需要先把它们转化成整数(二进制)方能使用。而记录日志时则相反，我们要把整数表示的IP地址转化成为可读的字符串。下面3个函数可用于用点分是兼职字符串表示的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换： #includ \u003carpa/inet.h\u003e in_addr_t inet_addr(const char *cp); int inet_aton(const char *cp,struct in_addr *inp); char *inet_ntoa(struct in_addr in); 下面这对更新的函数也能完成前面3个函数同样的功能，并且它们同时适用IPv4地址和IPv6地址 #includ \u003carpa/inet.h\u003e //p : 点分十进制的字符串 //n : 表示network字节序的整数 int inet_pton(int af,const char *src,void *dest); //af:地址族 //src ：需要转换的点分十进制字符串 //dest：转换后保存的目标 const char *inet_ntop(int af,const void *src,char *dest,socklen_t size); //af:地址族 //src ：需要转换的Ip的整数 //dest：转换后保存的目标 //size : 第三个参数的大小 //返回值:返回转换后的字符串 ","date":"2023-03-04","objectID":"/socket%E5%9C%B0%E5%9D%80/:2:0","tags":["Linux网络编程"],"title":"Socket地址","uri":"/socket%E5%9C%B0%E5%9D%80/"},{"categories":["Linux网络编程"],"content":"字节序 现代CPU的累加器一次都能装载至少4字节(32位机器),即一个整数。那么这四个字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机体系结构中，对于字节，字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元(比特，字节，字，双字节等)应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编码/译码从而导致通信失败。 字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。 字节序分为大端字节序(Big-Ending)，和小端字节(Little-Ending)。大端字节序是指一个整数的最高位字节(23~31bit)存储在内存的低地址处，低位字节（0-7bit）存储在内存的高地址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。 ","date":"2023-03-04","objectID":"/%E5%AD%97%E8%8A%82%E5%BA%8F/:0:0","tags":["Linux网络编程"],"title":"字节序","uri":"/%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"categories":["Linux网络编程"],"content":"字节序举例 ","date":"2023-03-04","objectID":"/%E5%AD%97%E8%8A%82%E5%BA%8F/:1:0","tags":["Linux网络编程"],"title":"字节序","uri":"/%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"categories":["Linux网络编程"],"content":"小端字节序 小端字节序:最高有效位存于最高内存地址，最低有效位存于最低内存处 内存方向—–\u003e 内存低——\u003e内存高 ","date":"2023-03-04","objectID":"/%E5%AD%97%E8%8A%82%E5%BA%8F/:1:1","tags":["Linux网络编程"],"title":"字节序","uri":"/%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"categories":["Linux网络编程"],"content":"大端字节序 大端字节序:最高有效位存于最低内存地址处，最低有效位存于最高内存处 内存方向—–\u003e 内存低——\u003e内存高 ","date":"2023-03-04","objectID":"/%E5%AD%97%E8%8A%82%E5%BA%8F/:1:2","tags":["Linux网络编程"],"title":"字节序","uri":"/%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"categories":["Linux网络编程"],"content":"整体视图 ","date":"2023-03-04","objectID":"/%E5%AD%97%E8%8A%82%E5%BA%8F/:1:3","tags":["Linux网络编程"],"title":"字节序","uri":"/%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"categories":["Linux网络编程"],"content":"字节序转换函数 当格式化的数据在两台不同字节序的主机之间直接传递时，接收端必然错误的解释。解决问题的方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换(小端机转换，大端机不转换) 网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型，操作系统等无关，从而可以保证数据在不同主机之间传输是能够被正确解释，网络字节顺序采用大端排序方式。 BSD Socket_t提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数:htons，htonl：从网络字节序到主机字节序的转换函数：ntohs，ntohl。 h - host :主机，主机字节序 to - 转换成什么 n - network:网络字节序 s - short：unsigned short l - long: unsigned int #include \u003carpa/inet.h\u003e //转换端口 uint_16_t htons(uint_16_t hostshort);//主机字节序到网络字节序 uint_16_t ntohs(uint_16_t netshort);//网络字节序到主机字节序 //转换ip uint_16_t htonl(uint_16_t hostlong);//转ip uint_16_t ntohl(uint_16_t netlong); ","date":"2023-03-04","objectID":"/%E5%AD%97%E8%8A%82%E5%BA%8F/:2:0","tags":["Linux网络编程"],"title":"字节序","uri":"/%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"categories":["Linux多线程开发"],"content":"线程同步 1.线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的，必须确保多个线程不会同时修改同一个变量，或者某个线程不会读取正在由其他线程修改的变量。 2.临界区是指访问某一种共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应该终端该片段的执行， 3.线程同步：即当有一个线程在对内存进程操作时，其他线程不可以对这个内存地址进行操作，知道该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。 ","date":"2023-03-03","objectID":"/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/:1:0","tags":["Linux多线程开发"],"title":"线程同步+锁","uri":"/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"},{"categories":["Linux多线程开发"],"content":"互斥锁 1.为了避免线程更新共享变量时出现问题，可以使用互斥量(mutex是mutual exclusion的缩写)来确保同时仅用一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。 2.互斥量有两种状态:已锁定(locked)和未锁定(unlocked),任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。 3.一旦线程锁定互斥量，随即成文该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一个共享资源(可能由多个相关变量组成)会使用不同的互斥量。每一个线程在访问同一资源时将采用如下协议: 3.1 针对共享资源锁定互斥量 3.2 访问共享资源 3.3 对互斥量解锁 ","date":"2023-03-03","objectID":"/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/:1:1","tags":["Linux多线程开发"],"title":"线程同步+锁","uri":"/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"},{"categories":["Linux多线程开发"],"content":"互斥量 如果多个线程试图执行这一块代码(一个临界区),事实上只有一个线程能够持有该互斥量(其他线程将遭到阻塞),即同时只有一个线程能够进入这段代码区域，如下图所示。 !(mutex)(../images/thread/1.png) //互斥量的类型 pthread_mutex_t int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutex_t *restrict mutex); int pthread_mutex_destroy(pthread_mutex_t *mutex); int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthraed_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); 示例代码 /* //互斥量的类型 pthread_mutex_t int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutex_t *restrict attr); -初始化互斥量 -参数 -mutex:需要初始化的互斥量变量 -attr:互斥量相关的属性，NULL 或者自己写入 - restrict：c语言修饰符，被修饰的指针，不能由另外的一个指针进行操作 int pthread_mutex_destroy(pthread_mutex_t *mutex); -释放互斥量 int pthread_mutex_lock(pthread_mutex_t *mutex); -加锁 阻塞的 如果有一个线程加锁了，其他的线程只能阻塞等待 int pthread_mutex_trylock(pthraed_mutex_t *mutex); -尝试加锁 int pthread_mutex_unlock(pthread_mutex_t *mutex); -解锁 */ #include \u003cpthread.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e int ticket = 1000; //创建一个互斥量 pthread_mutex_t mutex; void * callback(void * arg){ //卖票 while(1){ pthread_mutex_lock(\u0026mutex); if(ticket\u003e0){ printf(\"thread id = %ld,正在卖第%d张票\\n\",pthread_self(),ticket); ticket--; }else{ pthread_mutex_unlock(\u0026mutex); break; } pthread_mutex_unlock(\u0026mutex); } return NULL; } int main(){ //初始化互斥量 pthread_mutex_init(\u0026mutex,NULL); //创建一个线程 pthread_t tid1; pthread_t tid2; pthread_t tid3; //创建 pthread_create(\u0026tid1,NULL,callback,NULL); pthread_create(\u0026tid2,NULL,callback,NULL); pthread_create(\u0026tid3,NULL,callback,NULL); //回收 pthread_join(tid1,NULL); pthread_join(tid2,NULL); pthread_join(tid3,NULL); // //分离 // pthread_detach(tid1); // pthread_detach(tid2); // pthread_detach(tid3); //主线程退出 pthread_exit(NULL); //释放互斥量 pthread_mutex_destroy(\u0026mutex); return 0; } ","date":"2023-03-03","objectID":"/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/:1:2","tags":["Linux多线程开发"],"title":"线程同步+锁","uri":"/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"},{"categories":["Linux多线程开发"],"content":"死锁 1.有时候，一个线程需要用时访问两个或者更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。 2.两个或两个以上的进程在执行过程中，因争夺共享资源而造成一种互相等待的线程，若无外力作用，它们都无法推进下去。此时称系统处于死锁状态或者处于死锁。 3.死锁的集中场景： 3.1 忘记释放锁 3.2 重复加锁 3.3 多线程多锁，抢占锁资源 ","date":"2023-03-03","objectID":"/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/:1:3","tags":["Linux多线程开发"],"title":"线程同步+锁","uri":"/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"},{"categories":["Linux多线程开发"],"content":"读写锁 1.当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排他性，所有其它线程都无法访问数据锁，也就是无法访问共享资源，但是实际上多个线程同时访问共享资源也不会导致问题。 2.在对数据的读写操作时，更多的是读操作，写操作较少，例如对数据库数据的读写和应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。 3.读写锁的特点: 3.1 如果有其它线程读数据，则允许其它线程执行读操作，但是不允许写操作。 3.2 如果有其它线程写数据，则其他线程不允许读，写操作。 3.3 写是独占，写的优先级高 读写锁相关操作函数 //读写锁的类型 pthread_rwlock_t int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); int phtread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trydlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); ","date":"2023-03-03","objectID":"/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/:1:4","tags":["Linux多线程开发"],"title":"线程同步+锁","uri":"/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"},{"categories":["Linux多线程开发"],"content":"生产者消费者模型 生产者消费者模型，即多个生产者生产，多个消费者消费，共同操作一个变量，如果不加锁，则会导致内存越界，报错。但是加了锁，由于没有提醒机制，某个线程会单方面的阻塞，也不利于流程的实施。 /* 生产者消费者模型 */ #include \u003cpthread.h\u003e #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e struct Node { int num; struct Node * next; }; //头结点 struct Node * head = NULL; //定义互斥锁 pthread_mutex_t mutex; void * producer(void *arg){ while(1){ pthread_mutex_lock(\u0026mutex); struct Node * newNode = (struct Node *)malloc(sizeof(struct Node)); newNode-\u003enext = head; head = newNode; newNode-\u003enum = rand()%1000; printf(\"add node,num : %d,tid : %ld \\n\",newNode-\u003enum,pthread_self()); pthread_mutex_unlock(\u0026mutex); usleep(100); } return NULL; } void * customer(void *arg){ while(1){ pthread_mutex_lock(\u0026mutex); struct Node * temp = head; if(head!=NULL){ head = head-\u003enext; printf(\"del node num : %d, tid : %ld\\n\",temp-\u003enum,pthread_self()); temp-\u003enext = NULL; free(temp); pthread_mutex_unlock(\u0026mutex); usleep(100); }else{ pthread_mutex_unlock(\u0026mutex); } } return NULL; } int main(){ //创建互斥锁 pthread_mutex_init(\u0026mutex,NULL); //创建5个生产，5个消费 pthread_t ptids[5]; pthread_t ctids[5]; for(int i=0;i\u003c5;i++){ pthread_create(\u0026ptids[i],NULL,producer,NULL); } for(int i=0;i\u003c5;i++){ pthread_create(\u0026ctids[i],NULL,customer,NULL); } //线程连接 for(int i=0;i\u003c5;i++){ pthread_join(ptids[i],NULL); pthread_join(ctids[i],NULL); } // while(1){ // sleep(10); // } // //消除互斥锁 pthread_mutex_destroy(\u0026mutex); pthread_exit(NULL); return 0; } 条件变量 使用条件变量可以根据线程内的运行，适当的阻塞线程 或者唤醒线程 //条件变量的类型 pthread_cond_t int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr); int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex); int pthread_cond_timedwait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex,const struct timespec *restrict abstime); int pathread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthead_cond_t *cond); 代码示例 /* //条件变量的类型 pthread_cond_t int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr); 初始化 int pthread_cond_destroy(pthread_cond_t *cond); 释放 int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex); 等待唤醒 int pthread_cond_timedwait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex,const struct timespec *restrict abstime); 等待，依据传入的时间 设置阻塞时间 int pathread_cond_signal(pthread_cond_t *cond); 唤醒一个或者多个等待线程 int pthread_cond_broadcast(pthead_cond_t *cond); 唤醒全部线程 */ /* 生产者消费者模型 */ #include \u003cpthread.h\u003e #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e struct Node { int num; struct Node * next; }; //头结点 struct Node * head = NULL; //定义互斥锁 pthread_mutex_t mutex; //创建条件变量 pthread_cond_t cond; void * producer(void *arg){ while(1){ pthread_mutex_lock(\u0026mutex); struct Node * newNode = (struct Node *)malloc(sizeof(struct Node)); newNode-\u003enext = head; head = newNode; newNode-\u003enum = rand()%1000; printf(\"add node,num : %d,tid : %ld \\n\",newNode-\u003enum,pthread_self()); //只要生产了一个就通知消费者 pthread_cond_signal(\u0026cond); pthread_mutex_unlock(\u0026mutex); usleep(100); } return NULL; } void * customer(void *arg){ while(1){ pthread_mutex_lock(\u0026mutex); struct Node * temp = head; if(head!=NULL){ head = head-\u003enext; printf(\"del node num : %d, tid : %ld\\n\",temp-\u003enum,pthread_self()); temp-\u003enext = NULL; free(temp); pthread_mutex_unlock(\u0026mutex); usleep(100); }else{ //释放 pthread_mutex_unlock(\u0026mutex); //没有数据等待 //当这个函数调用阻塞的时候，会释放锁，生产者开始生成 //但不阻塞的时候，继续向下执行，不阻塞 pthread_cond_wait(\u0026cond,\u0026mutex); } } return NULL; } int main(){ //创建互斥锁 pthread_mutex_init(\u0026mutex,NULL); //初始化cond pthreaD_cond_init(\u0026cond,NULL); //创建5个生产，5个消费 pthread_t ptids[5]; pthread_t ctids[5]; for(int i=0;i\u003c5;i++){ pthread_create(\u0026ptids[i],NULL,producer,NULL); } for(int i=0;i\u003c5;i++){ pthread_create(\u0026ctids[i],NULL,customer,NULL); } //线程连接 for(int i=0;i\u003c5;i++){ pthread_join(ptids[i],NULL); pthread_join(ctids[i],NULL); } // while(1){ // sleep(10); // } // //消除互斥锁 pthread_mutex_destroy(\u0026mutex); //消除条件变量 pthread_cond_destroy(\u0026cond); pthread_exit(NULL);","date":"2023-03-03","objectID":"/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/:2:0","tags":["Linux多线程开发"],"title":"线程同步+锁","uri":"/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"},{"categories":["Linux多线程开发"],"content":"线程概述 1.与进程(process)类似，线程(thread)是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份内存区域，其中包括初始化数据段，未初始化数据段，以及堆内存段。(传统意义上的UNIX进程只是多线程程序的一个特例，该进程只包含一个线程)。 2.进程是CPU分配资源的最小单位，线程是操作系统调度执行的最小单位。 3.线程是轻量级的进程(LWP:Light Weight Process)，在Linux环境下线程的本质是进程。 4.查看指定进程的LWP号:ps -Lf pid ","date":"2023-03-02","objectID":"/%E7%BA%BF%E7%A8%8B/:1:0","tags":["Linux多线程开发"],"title":"线程","uri":"/%E7%BA%BF%E7%A8%8B/"},{"categories":["Linux多线程开发"],"content":"线程和进程的区别 1.进程间的信息难以共享，由于除去只读代码之外，父子进程并未共享内存，因此必须采用一些进程间通信的方式，在进程间进行信息交换。 2.调用fork()来创建进程的代价相对较高，即便利用写时复制技术，但仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着fork()调用在时间上的开销依然不菲。 3.线程之间能够方便，快速的共享信息。只需要将数据复制到共享(全局或堆)变量中即可。 4.创建线程比创建进程通常要快10倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表。 ","date":"2023-03-02","objectID":"/%E7%BA%BF%E7%A8%8B/:1:1","tags":["Linux多线程开发"],"title":"线程","uri":"/%E7%BA%BF%E7%A8%8B/"},{"categories":["Linux多线程开发"],"content":"线程之间共享和非共享资源 共享资源 进程ID和父进程ID 进程组ID和会话ID 用户ID和用户组ID 文件描述符 信号处理 文件系统的相关信息:文件权限掩码，当前工作目录 虚拟地址空间(除栈,text) 非共享资源 线程ID 信号掩码 线程特有数据 error变量 实时调度策略和优先级 栈，本地变量和函数的调用链接信息 ","date":"2023-03-02","objectID":"/%E7%BA%BF%E7%A8%8B/:1:2","tags":["Linux多线程开发"],"title":"线程","uri":"/%E7%BA%BF%E7%A8%8B/"},{"categories":["Linux多线程开发"],"content":"线程的创建 线程操作函数 pthread_t pthread_self(void); int pthread_equal(pthread_t t1,pthread_t t2); int pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(*start_routine)(void *),void *arg); void pthread_exit(void *retval); int pthread_join(pthread_t thread,void **retval); int pthread_detach(pthread_t thread); int pthread_cancel(pthread_t thread); int pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(*start_routine)(void *),void *arg); /* 一般情况下，main函数所在的线程称之为主线程，之后创建的称之为子线程 #include \u003cpthread.h\u003e int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); 作用:创建一个子线程 参数: pthread_t *thread:传出参数，代表的是线程创建成功之后，子线程的线程ID会写到这个参数里 const pthread_attr_t *attr:需要设置的线程的属性，一般使用默认值，NULL void *(*start_routine) (void *):函数指针，子线程需要处理的逻辑代码 void *arg:给第三个参数使用，传参 返回值： 成功:0 错误:失败会返回错误号码，这个错误号和之前的errno不太一样 不能通过perror()，而是使用char *strerror(int errornum); */ #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cpthread.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e //子线程需要处理的逻辑代码 void *callback(){ printf(\"chil thread。。。。\\n\"); return NULL; } int main(){ //创建一个线程 pthread_t tid; int ret = pthread_create(\u0026tid,NULL,callback(),NULL); if(ret !=0){ char *str = strerror(ret); printf(\"error : %s\\n\",str); } for(int i = 0;i \u003c 5;i++){ printf(\"%d\\n\",i); } sleep(1); return 0; } void pthread_exit(void *retval); /* #include \u003cpthread.h\u003e void pthread_exit(void *retval); 作用L:终止一个线程，在哪个线程调用，就终止哪个线程 参数: -retval:需要传递一个指针，作为一个返回值，可以再pthread_join()中获取到 pthread_t pthread_self(void); 作用:获取当前线程的ID */ #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cpthread.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e void *callback(){ printf(\"child thread id:%ld\\n\",pthread_self()); return NULL; } int main(){ //创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid,NULL,callback,NULL); if(ret!=0){ char *str = strerror(ret); printf(\"%s\\n\",str); exit(0); } //主线程 for(int i = 0;i \u003c 5;i++){ printf(\"%d\\n\",i); } printf(\"tid : %ld ,main thread id:%ld\\n\",tid,pthread_self()); //让主线程退出，当主线程退出时，不会影响其他正常运行的线程 pthread_exit(NULL); return 0; } int pthread_join(pthread_t thread,void **retval); /* #include \u003cpthread.h\u003e int pthread_join(pthread_t thread, void **retval); 作用：和一个终止的线程进行连接 回收子线程的资源 这个函数是阻塞函数，调用一次只能回收一个子线程 一般在主线程中去使用 参数: -thread：需要回收的子线程的id -retval: 接受子线程退出时的返回值 返回值： 成功返回0 失败返回错误号 */ #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cpthread.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e void *callback(){ printf(\"child thread id:%ld\\n\",pthread_self()); int num = 10; pthread_exit((void *)\u0026num); } int main(){ //创建一个子线程 pthread_t tid; int ret = pthread_create(\u0026tid,NULL,callback,NULL); if(ret!=0){ char *str = strerror(ret); printf(\"%s\\n\",str); exit(0); } //主线程 for(int i = 0;i \u003c 5;i++){ printf(\"%d\\n\",i); } printf(\"tid : %ld ,main thread id:%ld\\n\",tid,pthread_self()); //主线程调用pthread_join去回收子线程的资源 int *thread_return_value = NULL; ret = pthread_join(tid,(void **)\u0026thread_return_value); if(ret!=0){ char *str = strerror(ret); printf(\"%s\\n\",str); exit(0); } printf(\"exit date : %d\\n\",*thread_return_value); printf(\"回收子线程资源成功\\n\"); //让主线程退出，当主线程退出时，不会影响其他正常运行的线程 pthread_exit(NULL); return 0; } int pthread_detach(pthread_t thread); /* #include \u003cpthread.h\u003e int pthread_detach(pthread_t thread); 作用:分离一个线程 参数: -pthread_t thread:传入一个线程ID,将指定ID的线程标记为分离 返回值： 成功返回 0 错误返回 error number 注意： 1.不可多次分离，否则会产生不可预料的行为。 2.不可以join一个已经detach的线程 */ #include \u003cpthread.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003cstring.h\u003e void * callback(void * arg){ printf(\"child thread id : %ld\\n\",pthread_self()); return NULL; } int main(){ //创建一个线程 pthread_t tid; int ret = pthread_create(\u0026tid,NULL,callback,NULL); if(ret != 0){ char * str = strerror(ret); printf(\"error1 :%s\\n\",str); exit(0); } // 输出主线程和子线程的id printf(\"tid = %ld,main thread id = %ld\\n\",tid,pthread_self()); //设置子线程分离,子线程结束时对应的资源就不需要主线程释放 ret = pthread_detach(tid); if(ret != 0){ char * str = strerror(ret); printf(\"error2 :%s\\n\",str); exit(0); } //设置分离后，对分离的子线程进程链接，pthread_join()//Invalid argument ret = pthread_join(tid","date":"2023-03-02","objectID":"/%E7%BA%BF%E7%A8%8B/:2:0","tags":["Linux多线程开发"],"title":"线程","uri":"/%E7%BA%BF%E7%A8%8B/"},{"categories":["Linux多线程开发"],"content":"线程属性操作函数 int pthread_attr_init(pthread_addr_t *attr); -初始化线程属性变量 int pthread_attr_destory(pthread_addr_t *addr); -释放线程资源 int pthread_attr_getdetachstate(const pthread_attr_t *attr,int *detachstate); -获取线程分离的状态属性 int pthread_attr_setdetachstate(pthread_attr_t *addr,int detachstate); -设置线程分离的状态属性 在终端输入 man pthread_attr + Tab 可以查看其余函数 ","date":"2023-03-02","objectID":"/%E7%BA%BF%E7%A8%8B/:2:1","tags":["Linux多线程开发"],"title":"线程","uri":"/%E7%BA%BF%E7%A8%8B/"},{"categories":["Linux多进程开发"],"content":"共享内存 1.共享内存允许两个或者多个进程共享物理内存的同一块区域(通常被称为段)。由于一个共享内存段会称为一个进程用户空间的一部分。因此这种IPC机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。 2.与管道等，要求进程发送数据，并将数据从用户空间的缓冲区复制进内核内存以及接受进程讲数据从内核内存复制进用户空间的缓冲区的做法对比，这种IPC技术的速度更快。 ","date":"2023-03-02","objectID":"/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:1:0","tags":["Linux多进程开发"],"title":"共享内存","uri":"/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux多进程开发"],"content":"共享内存的使用步骤 1.调用shmget()，创建一个新共享内存段或取得一个既有共享内存的标识符(即由其他进程创建的共享内存段)。这个调用将返回后续调用中需要额共享内存标识符。 2.使用shmat()来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分 3.此刻在进程中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由shmat()调用后返回的addr值，他是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。 4.调用shmdt()来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了，这步是可选额，并且在进程终止时会自动完成这一步。 5.调用shmctl()来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。 ","date":"2023-03-02","objectID":"/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:2:0","tags":["Linux多进程开发"],"title":"共享内存","uri":"/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux多进程开发"],"content":"贡献内存相关函数 共享内存相关的函数 #include \u003csys/ipc.h\u003e #include \u003csys/shm.h\u003e int shmget(key_t key, size_t size, int shmflg); - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。 新创建的内存段中的数据都会被初始化为0 - 参数： - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。 一般使用16进制表示，非0值 - size: 共享内存的大小 - shmflg: 属性 - 访问权限 - 附加属性：创建/判断共享内存是不是存在 - 创建：IPC_CREAT - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用 IPC_CREAT | IPC_EXCL | 0664 - 返回值： 失败：-1 并设置错误号 成功：\u003e0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。 void *shmat(int shmid, const void *shmaddr, int shmflg); - 功能：和当前的进程进行关联 - 参数： - shmid : 共享内存的标识（ID）,由shmget返回值获取 - shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定 - shmflg : 对共享内存的操作 - 读 ： SHM_RDONLY, 必须要有读权限 - 读写： 0 - 返回值： 成功：返回共享内存的首（起始）地址。 失败(void *) -1 int shmdt(const void *shmaddr); - 功能：解除当前进程和共享内存的关联 - 参数： shmaddr：共享内存的首地址 - 返回值：成功 0， 失败 -1 int shmctl(int shmid, int cmd, struct shmid_ds *buf); - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进程被销毁了对共享内存是没有任何影响。 - 参数： - shmid: 共享内存的ID - cmd : 要做的操作 - IPC_STAT : 获取共享内存的当前的状态 - IPC_SET : 设置共享内存的状态 - IPC_RMID: 标记共享内存被销毁 - buf：需要设置或者获取的共享内存的属性信息 - IPC_STAT : buf存储数据 - IPC_SET : buf中需要初始化数据，设置到内核中 - IPC_RMID : 没有用，NULL key_t ftok(const char *pathname, int proj_id); - 功能：根据指定的路径名，和int值，生成一个共享内存的key - 参数： - pathname:指定一个存在的路径 /home/nowcoder/Linux/a.txt / - proj_id: int类型的值，但是这系统调用只会使用其中的1个字节 范围 ： 0-255 一般指定一个字符 'a' 问题1：操作系统如何知道一块共享内存被多少个进程关联？ - 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch - shm_nattach 记录了关联的进程个数 问题2：可不可以对共享内存进行多次删除 shmctl - 可以的 - 因为shmctl 标记删除共享内存，不是直接删除 - 什么时候真正删除呢? 当和共享内存关联的进程数为0的时候，就真正被删除 - 当共享内存的key为0的时候，表示共享内存被标记删除了 如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。 共享内存和内存映射的区别 1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外） 2.共享内存效果更高 3.内存 所有的进程操作的是同一块共享内存。 内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。 4.数据安全 - 进程突然退出 共享内存还存在 内存映射区消失 - 运行进程的电脑死机，宕机了 数据存在在共享内存中，没有了 内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。 5.生命周期 - 内存映射区：进程退出，内存映射区销毁 - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机 如果一个进程退出，会自动和共享内存进行取消关联。 ","date":"2023-03-02","objectID":"/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/:3:0","tags":["Linux多进程开发"],"title":"共享内存","uri":"/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"categories":["Linux多进程开发"],"content":"终端 1.在UNIX系统中，用户通过终端登陆系统后得到一个shell进程，这个终端成为shell进程的控制终端(Controlling Terminal),进程中，控制终端是保存在PCB中的信息，而fork()会复制PCB中的信息，因此由Shell进程启动的其他进程的控制终端也是这个终端。 2.默认情况下(没有重定向)，每个进程的标准输入，标准输出和标准错误输出都是指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写，也就是输出到显示器上。 3。在控制终端输入一些特殊额控制键可以给前台进程发信号。例如Ctrl+C会产生SIGINT信号，CTRL+\\会产生SIGQUIT信号 ","date":"2023-03-02","objectID":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/:1:0","tags":["Linux多进程开发"],"title":"守护进程","uri":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux多进程开发"],"content":"进程组 1.进程组和会话在进程之间形成了一种两级层次的关系:进程组是一组相关进程的集合。会话是一组相关进程组的集合。进程组和会话是为了支持shell作业控制，而定义的抽象概念，用户通过shell能够交互式的在前台或者后台运行命令。 2.进程组由一个或多个共享同一进程组标识符(PGID)的进程组成，一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程ID为该进程组的ID，新警察会继承其父进程的所属的进程组ID。 3.进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入另一个进程组而退出当前进程组。进程组首进程无需是最后一个离开进程组的成员 ","date":"2023-03-02","objectID":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/:2:0","tags":["Linux多进程开发"],"title":"守护进程","uri":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux多进程开发"],"content":"会话 1.会话是一组进程组的集合。会话首进程是创建新会话额进程。其进程ID会称为会话ID。新进程会继承其父进程的会话ID。 2.一个会话中的所有进程共享一个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。 3.在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端读取输入。当用户在控制终端中输入终端字符产生信号后，该信号会被发送到前台进程组中的所有成员。 4.当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。 ","date":"2023-03-02","objectID":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/:3:0","tags":["Linux多进程开发"],"title":"守护进程","uri":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux多进程开发"],"content":"进程组，会话，控制终端之间的关系 如下图： ","date":"2023-03-02","objectID":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/:4:0","tags":["Linux多进程开发"],"title":"守护进程","uri":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux多进程开发"],"content":"进程组，会话操作函数 pid_t getpgrp(void);//获取组id pid_t getpgid(pid_t pid);//获取当前进程的进程组id int setpgid(pid_t pid,pid_t pgid);//设置进程的进程组id pid_t getsid(pid_t pid);//获取会话id pid_t setsid(void);//设置会话id ","date":"2023-03-02","objectID":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/:5:0","tags":["Linux多进程开发"],"title":"守护进程","uri":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux多进程开发"],"content":"守护进程 1.守护进程(Daemon Process),也就是通常说的Daemon进程(精灵进程),是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用d结尾的名字。 2.守护进程具备一下特性： 2.1 生命周期长，守护进程会在系统启动的时候被创建并一直运行知道系统关闭 2.2 他在后台运行并且不拥有控制终端，没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号 3Linux的大多数服务器就是用守护进程实现的。比如Internet服务器inetd，Web服务器httpd等 ","date":"2023-03-02","objectID":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/:6:0","tags":["Linux多进程开发"],"title":"守护进程","uri":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux多进程开发"],"content":"守护进程创建步骤 1.执行一个fork(),之后父进程退出，子进程继续执行 2.子进程调用setsid()并开启一个会话。 3.清除进程的umask以确保当守护进程创建文件和目录时拥有所需的权限 4.修改进程的当前工作目录，通常会改为根目录(/) 5、关闭守护进程从其父进程继承而来的所有打开着的文件描述符 6 在关闭了文件描述符0,1,2之后，守护进程通常会打开/dev/null并使用dup2()使所有这些描述符指向这个设备、 7 核心业务逻辑 例子 使用守护进程去实现每2秒记录系统时间并写入磁盘 /* 写一个守护进程，每隔两秒获取一下系统时间，将这个时间写入磁盘文件中 */ #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e #include \u003csys/time.h\u003e #include \u003csignal.h\u003e #include \u003ctime.h\u003e #include \u003cstring.h\u003e void work(int num){ printf(\"捕捉到信号:%d\\n\",num); //获取系统时间 time_t t = time(NULL); //将描述转换成系统时间 struct tm * loc = localtime(\u0026t); // char buffer[1024]; // sprintf(buffer,\"%d-%d-%d %d:%d:%d\\n\",loc-\u003etm_year,loc-\u003etm_mon,loc-\u003etm_mday,loc-\u003etm_hour,loc-\u003etm_min,loc-\u003etm_sec); char *buffer = asctime(loc); //写文件 int fd = open(\"time.txt\",O_RDWR|O_CREAT|O_APPEND,0775); write(fd,buffer,strlen(buffer)); close(fd); } int main(){ //创建子进程，退出父进程 pid_t pid = fork(); if(pid\u003e0){ //父进程直接退出 exit(0); } //将子进程重新创建一个会话 //新的会话脱离终端 setsid(); //修改进程的umask umask(022); //更改工作目录 chdir(\"/home/zxl/\"); //关闭重定向文件描述符 int fd = open(\"/dev/null\",O_RDWR); dup2(fd,STDIN_FILENO); dup2(fd,STDERR_FILENO); dup2(fd,STDOUT_FILENO); //业务逻辑 //需要信号捕捉 struct sigaction act; act.sa_flags = 0; act.sa_handler =work; sigemptyset(\u0026act.sa_mask); sigaction(SIGALRM,\u0026act,NULL); //每隔两秒获取系统时间 struct itimerval val; val.it_value.tv_sec=2; val.it_value.tv_usec=0; val.it_interval.tv_sec=2; val.it_interval.tv_usec=0; setitimer(ITIMER_REAL,\u0026val,NULL); //不让进程结束 while(1){ sleep(3); } return 0; } ","date":"2023-03-02","objectID":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/:6:1","tags":["Linux多进程开发"],"title":"守护进程","uri":"/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux多进程开发"],"content":"信号的概念 1.信号是Linux进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式，信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某个突发事件 2.发往进程的诸多信号，通常都源于内核。引发内核为进程产生信号的各类事件如下： 2.1 对于前台进程，用户可以通过输入特殊的终端字符给它发送信号。比如输入Ctrl+C通常会给进程发送一个终端信号 2.2 硬件发生异常，及硬件检测到一个错误条件并通知内核，随机再由内核发送响应信号给相关进程。比如执行一条异常的机器语言指令，比如被0除，或者引用了无法访问的内存区域 2.3 系统状态变化，比如alarm定时器到期引起SIGALRM信号，进程执行cpu时间超限，或者该进程的某个子进程退出 2.4 运行kill命令 或者 kill函数 ","date":"2023-03-01","objectID":"/%E4%BF%A1%E5%8F%B7/:0:0","tags":["Linux多进程开发"],"title":"信号","uri":"/%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux多进程开发"],"content":"使用信号的目的 1.使用信号的两个主要目的: 1.1让进程知道已经发生了特定的事情 1.2强迫进程执行他自己代码中的信号处理程序 2.信号的特点 2.1 简单 2.2 不能携带大量信息 2.3 满足某个特定条件才发送 2.4 优先级比较高 3.查看系统定义的信号列表 kill -i 4.前31个信号为常规信号，其余为实时信号 ","date":"2023-03-01","objectID":"/%E4%BF%A1%E5%8F%B7/:1:0","tags":["Linux多进程开发"],"title":"信号","uri":"/%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux多进程开发"],"content":"信号列表 编号 信号名称 对应事件 默认动作 1 SIGHUP 用户退出shell时，由该shell启动的所有进程将收到这个信号 终止进程 2 SIGINT 当用户按下CTRL+C组合键时，用户终端向正在运行中的由该终端启动的程序发送此信号 终止进程 3 SICQUIT 用户按下CTRL+\\组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发送该信号 终止进程 4 SIGILL CPU检测到某进程执行了非法指令 终止并产生core文件 5 SIGTRAP 该信号由断点指令或其他trap指令产生 终止并产生core文件 6 SIGABRT 调用abort函数时产生该信号 终止并产生core文件 7 SIGBUS 非法访问内存地址，包括内存对其出错 终止并产生core文件 8 SIGFPE 在发生致命的运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误 终止并产生core文件 9 SIGKILL 无条件终止进程，该信号不能被忽略，处理和阻塞 终止进程，可以杀死任何进程 10 SIGUSEL 用户定义的信号，即程序员可以再程序中定义并使用 终止进程 11 SIGSECV 指示进程进行了无效内存访问(段错误) 终止并产生core文件 12 SIGUSR2 另外一个用户自定义信号，程序员可以在程序中定义并使用 终止进程 13 SIGPIPE Broken pipe向一个没有读端的管道写数据 终止进程 14 SIGALRM 定时器超时，超时的时间，由系统调用alarm设置 终止进程 15 SIGTERM 程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来表示程序正常退出。执行shell命令kill时，缺省产生这个信号 进程终止 16 SIGSTKFLT LINUX早期版本出现的信号，现在仍然保留 程序终止 17 SIGCHLD 子进程结束时，父进程会收到这个信号 忽略信号 18 SIGCONT 如果进程已停止，则使其继续运行 继续/忽略 19 SIGSTOP 停止进程的执行，信号不能被忽略，处理和阻塞 为终止进程 20 SIGTSTP 停止终端交互进程的运行，按下CTRL+X发出该信号 暂停进程 21 SIGTTIN 后台程序读终端控制台 暂停进程 22 SIGTTOU 该信号类似于SIGTTIN，后台进程向终端发送数据 暂停进程 23 SIGURG 套接字上有紧急数据时，向当前正在运行的进程发出信号，报告有紧急数据到达，如网络带外数据到达 忽略该信号 24 SIGXCPU 进程执行时间超过了分配给该进程的CPU时间，系统产生该信号并发送给进程 终止进程 25 SIGXFSZ 超过文件的最大长度设置 终止进程 26 SIGVTALRM 虚拟时钟超时时产生该信号，类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间 终止进程 27 SIGPROF 类似于SIGVTALRM，它不仅包括该进程占用CPU时间还包括执行系统调用时间 终止进程 28 SIGWINCH 窗口大小变化时发出 忽略 29 SIGIO 此信号向进程指示发出一个异步IO事件 忽略 30 SIGPWR 关机 终止进程 31 SIGSYS 无效系统调用 终止进程并产生core文件 34-64 SIGRTIMN—SIGRTMAX 没有固定含义 终止进程 ","date":"2023-03-01","objectID":"/%E4%BF%A1%E5%8F%B7/:2:0","tags":["Linux多进程开发"],"title":"信号","uri":"/%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux多进程开发"],"content":"信号的5种默认处理动作 1.查看信号的详细信息: man 7 signal 2.信号的5种默认处理动作 2.1 Term 终止进程 2.2 Ign 当前进程忽略掉这个信号 2.3 Core 终止进程，并产生一个Core文件 2.4 Stop 暂停当前进程 2.5 Cont 继续执行当前被暂停的进程 信号的几种状态：产生，未决，递达 SIGKILL 和 SIGSTOP信号不能被捕捉，阻塞或忽略 ","date":"2023-03-01","objectID":"/%E4%BF%A1%E5%8F%B7/:3:0","tags":["Linux多进程开发"],"title":"信号","uri":"/%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux多进程开发"],"content":"信号相关函数 int kill(pid_t pid,int sig); int raise(int sig); void abort(void); unsigned int alarm(unsigned int seconds); in setitimer(int which,const struct itimerval *new_val,struct itimerval * old_value); kill,raise,abort函数详细 #include \u003csys/types.h\u003e #include \u003csignal.h\u003e int kill(pid_t pid,int sig); 作用:给某个进程pid，发送信号sig 参数: pid:需要发送的进程的pid pid\u003e0:将信号发送给指定的进程 pid=0：将信号发送给当前的进程组 pid=-1:将信号发送给每一个有权限接受这个信号的进程 pid\u003c-1：pid=某个进程组的id取反，给进程组内所有成员发送信号 sig:需要发送的sig编号或者宏值 例如：kill(getppid(),9); int raise(int sig); 功能:给当前进程发送信号 参数: sig:需要发送的sig编号或者宏值 返回值： 成功0 失败除0外的数字 void abort(void); 功能：发送SIGABRT信号给当前进程，杀死当前进程 kill(getpid(),SIGABRT); alarm(),setitimer(..) #include \u003cunistd.h\u003e unsigned int alarm(unsigned int seconds); 功能:定时 参数：seconds 秒 返回值：返回调用时的时间 #include \u003csys/time.h\u003e int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value); 功能:设置定时器(闹钟)，可以替代alarm函数，精度好，实现周期性定时 参数: which：定时器以什么时间计时 ITIMER_REAL:真实时间,时间到达，发送SIGALRM 常用的 ITIMER_VIRTUAL:用户时间，时间到达，发送SIGVTALRM ITIMER_PROF:以该进程在用户态和内核态下所消耗额时间来计算，时间到达，发送SIGPROF new_value:设置定时器的属性, struct itimerval { //定时器的结构体 struct timeval it_interval; //间隔时间 struct timeval it_value; //延迟多长时间执行定时器 }; struct timeval { //时间的结构体 time_t tv_sec; // 秒数 suseconds_t tv_usec; // 微秒 }; old_value:记录上一次的定时的时间参数，一般不使用，可以指定NULL 返回值: 成功：0 失败:-1 设置errno ","date":"2023-03-01","objectID":"/%E4%BF%A1%E5%8F%B7/:3:1","tags":["Linux多进程开发"],"title":"信号","uri":"/%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux多进程开发"],"content":"信号捕捉函数 sighandler_ signal(int signum,sighandler_t handler); int sigaction(int signum,const struct sigaction *act,struct sigaciton *oldact); sighandler_ signal(int signum,sighandler_t handler); /* #include \u003csignal.h\u003e typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); 功能: 参数: -signum:要捕捉的信号 -handler:捕捉到信号如何处理 SIG_IGN:忽略，捕捉到就忽略 进程不终止 SIG_DFL:使用信号默认的行为，原本的行为 回调函数:去执行操作 返回值: 成功:返回上一次注册的信号处理函数的地址，第一次调用返回NULL 失败:返回SIG_ERR，设置errno 回调函数: -需要程序员自己实现，提前准备好，函数的类型根据实际需要 -不是程序员调用，而是当信号产生的时候，内核自动调用 */ int sigaction(int signum,const struct sigaction *act,struct sigaciton *oldact); #include \u003csignal.h\u003e int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); - 功能：检查或者改变信号的处理。信号捕捉 - 参数： - signum : 需要捕捉的信号的编号或者宏值（信号的名称） - act ：捕捉到信号之后的处理动作 - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL - 返回值： 成功 0 失败 -1 struct sigaction { // 函数指针，指向的函数就是信号捕捉到之后的处理函数 void (*sa_handler)(int); // 不常用 void (*sa_sigaction)(int, siginfo_t *, void *); // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。 sigset_t sa_mask; // 使用哪一个信号处理对捕捉到的信号进行处理 // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction int sa_flags; // 被废弃掉了 void (*sa_restorer)(void); }; ","date":"2023-03-01","objectID":"/%E4%BF%A1%E5%8F%B7/:3:2","tags":["Linux多进程开发"],"title":"信号","uri":"/%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux多进程开发"],"content":"信号集 1.许多信号相关的系统调用都需要能够表示一组不同信号，多个信号可使用一个称之为信号集的数据结构表示，其系统数据类型为sigset_t。 2.在PCB中有两个非常重要的信号集，一个称之为’阻塞信号集’，另一个称之为’未决信号集’。这两个信号集都是内核是由位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。 3.信号的’未决’是一种状态，指的是从信号的产生到信号被处理前的这一段时间。 4.信号的’阻塞’是一个开关动作,指的是阻止信号被处理，而不是阻止信号产生。 5.信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感操作。 以下信号集相关的函数都是对自定义的信号集进行操作。 int sigemptyset(sigset_t *set); - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0 - 参数：set,传出参数，需要操作的信号集 - 返回值：成功返回0， 失败返回-1 int sigfillset(sigset_t *set); - 功能：将信号集中的所有的标志位置为1 - 参数：set,传出参数，需要操作的信号集 - 返回值：成功返回0， 失败返回-1 int sigaddset(sigset_t *set, int signum); - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号 - 参数： - set：传出参数，需要操作的信号集 - signum：需要设置阻塞的那个信号 - 返回值：成功返回0， 失败返回-1 int sigdelset(sigset_t *set, int signum); - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号 - 参数： - set：传出参数，需要操作的信号集 - signum：需要设置不阻塞的那个信号 - 返回值：成功返回0， 失败返回-1 int sigismember(const sigset_t *set, int signum); - 功能：判断某个信号是否阻塞 - 参数： - set：需要操作的信号集 - signum：需要判断的那个信号 - 返回值： 1 ： signum被阻塞 0 ： signum不阻塞 -1 ： 失败 int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); int sigpending(sigset_t *set); int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换） - 参数： - how : 如何对内核阻塞信号集进行处理 SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变 假设内核中默认的阻塞信号集是mask， mask | set SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞 mask \u0026= ~set SIG_SETMASK:覆盖内核中原来的值 - set ：已经初始化好的用户自定义的信号集 - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL - 返回值： 成功：0 失败：-1 设置错误号：EFAULT、EINVAL int sigpending(sigset_t *set); - 功能：获取内核中的未决信号集 - 参数：set,传出参数，保存的是内核中的未决信号集中的信息。 ","date":"2023-03-01","objectID":"/%E4%BF%A1%E5%8F%B7/:3:3","tags":["Linux多进程开发"],"title":"信号","uri":"/%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux多进程开发"],"content":"SIGCHLD信号 1.SIGCHLD信号产生的条件 1.1 子进程终止时 1.2 子进程接收到SIGSTOP信号停止时 1.3 子进程处在停止态，接受SIGCONT后唤醒时 2 以上三种条件都会给父进程发送SIGCHLD信号，父进程默认忽略该信号 ","date":"2023-03-01","objectID":"/%E4%BF%A1%E5%8F%B7/:3:4","tags":["Linux多进程开发"],"title":"信号","uri":"/%E4%BF%A1%E5%8F%B7/"},{"categories":["Linux多进程开发"],"content":"内存映射 内存映射(Memory-mapped I/O)是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。 ","date":"2023-03-01","objectID":"/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/:0:0","tags":["Linux多进程开发"],"title":"内存映射","uri":"/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"},{"categories":["Linux多进程开发"],"content":"内存映射相关系统调用 #include \u003csys/mman.h\u003e void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset); int munmap(void *addr, size_t length); ","date":"2023-03-01","objectID":"/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/:1:0","tags":["Linux多进程开发"],"title":"内存映射","uri":"/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"},{"categories":["Linux多进程开发"],"content":"使用父子进程通信 /* #include \u003csys/mman.h\u003e void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 功能:将一个文件或者设备的数据映射到内存中 参数： -void *addr:NULL 由内核指定 -size_t lenght:映射的数据的长度，这个值不能为0，建议使用文件的长度 int port:申请的内存映射区的操作权限 PROT_EXEC Pages may be executed. PROT_READ Pages may be read. PROT_WRITE Pages may be written. PROT_NONE Pages may not be accessed. int flag: - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步 - MAP——PRIVATE：映射区的数据会自动和磁盘文件不同步 int fd: 需要映射的文件的文件描述符 注意:通过open得到 文件的大小不能为0，open指定的权限不能和port冲突 port:PROT_READ open：只读/只写 prot:PROT_READ | PROT_WRITE open open:读写 off_t offset : 偏移量，一般不用，必须指定4K的整数倍，0 表示从头 返回值： 成功：返回首地址 错误：返回MAP_FAILED 并且set errno int munmap(void *addr, size_t length); -功能：释放内存映射 -参数： -addr : 要释放的内存的地址 length: 释放的内存的大小,要和mmap里的length大小相同 */ #include \u003csys/mman.h\u003e #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e #include \u003csys/wait.h\u003e int main(){ //1.打开一个文件 int fd = open (\"test.txt\",O_RDWR); //获取文件大小 int size = lseek(fd,0,SEEK_END); //创建内存映射区 void *addr = mmap(NULL,size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); if(addr == MAP_FAILED){ perror(\"mmap\"); exit(0); } //创建子进程 pid_t pid = fork(); if(pid\u003e0){ //父 //回收 wait(NULL); //定义数组 char buffer[64]; strcpy(buffer,(char * )addr); printf(\"read date : %s\\n\",buffer); }else if(pid == 0){ //子 strcpy((char *)addr,\"你好\"); } //关闭 munmap(addr,size); return 0; } ","date":"2023-03-01","objectID":"/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/:1:1","tags":["Linux多进程开发"],"title":"内存映射","uri":"/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"},{"categories":["Linux多进程开发"],"content":"无关系进程通信 process1 #include \u003csys/mman.h\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e int main(){ //执行没有关系的两个文件的读写操作 //打开文件 int fd1 = open(\"test1.txt\",O_RDWR); int size1 = lseek(fd1,0,SEEK_END); //创建内存映射区 void * ptr1 = mmap(NULL,size1,PROT_READ|PROT_WRITE,MAP_SHARED,fd1,0); if(ptr1==MAP_FAILED){ perror(\"mmap\"); exit(0); } //执行写入数据 strcpy((char *)ptr1,\"呵呵呵呵呵呵\"); munmap(ptr1,size1); } process2 #include \u003csys/mman.h\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e int main(){ //执行没有关系的两个文件的读写操作 //打开文件 int fd1 = open(\"test1.txt\",O_RDONLY); int size1 = lseek(fd1,0,SEEK_END); //创建内存映射区 void * ptr1 = mmap(NULL,size1,PROT_READ,MAP_SHARED,fd1,0); if(ptr1==MAP_FAILED){ perror(\"mmap\"); exit(0); } //执行读 char buffer[128]; memset(buffer,'0',128); strcpy(buffer,(char * )ptr1); printf(\"recv data :%s\\n\",buffer); munmap(ptr1,size1); } ","date":"2023-03-01","objectID":"/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/:1:2","tags":["Linux多进程开发"],"title":"内存映射","uri":"/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"},{"categories":["Linux多进程开发"],"content":"思考问题 1.如果对mmap的返回值(ptr)做++操作，mmap是否能够成功? void * ptr - mmap(..) ptr++;//可以进程操作 munmap(ptr,len);//错误，需要保存之前的地址 2.如果open时O_RDONLY,mmap时port参数指定PORT_READ|PORT_WRITE会如何？ 错误，会返回MAP_FAILED 不可以执行写权限 3.如果文件偏移量为1000 偏移量必须是4 * 1024的整数倍，一般情况错误返回MAP_FAILED 4.mmap什么情况下调用失败? 第二个参数length： = 0,会调用失败 第三个参数PORT权限，如果只是指定了PORT_WRITE也会失败，一般需要指定PORT_READ|PORT_WRITE 如果权限大于open的权限，也会失败 5.可以open的时候O_CREAT一个新文件来创建映射区么？ 可以的，但是创建的文件的大小如果为0的话，肯定不行 可以对新的文件进行拓展,lseek();truncate() 6.mmap后关闭文件描述符，对mmap有无影响？ int fd = open(...) void* ptr = mmap(..,..,..,fd,..); close(fd) 映射区还是存在的 7.对ptr越界操作会如何 void * ptr = mmap(NULL,100,...); 会以内存的分页的大小，来指定大小 越界操作的是非法的内存，会产生段错误 ","date":"2023-03-01","objectID":"/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/:2:0","tags":["Linux多进程开发"],"title":"内存映射","uri":"/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"},{"categories":["Linux多进程开发"],"content":"实现文件拷贝 /* 使用内存映射拷贝文件 思路: 1.对原始文件进行内存映射 2.创建新文件，lseek，truncate 3.把新文件的数据映射到内存中 4.通过内存拷贝，将第一个文件的内存数据拷贝到第二个文件的内存中 5.释放资源 */ #include \u003csys/mman.h\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e int main(){ //1.对原始文件进行内存映射 int fd = open(\"english.txt\",O_RDWR); if(fd==-1){ perror(\"open\"); exit(0); } //创建新的文件 int fd2 = open(\"copy.txt\",O_RDWR|O_CREAT,0664); if(fd2==-1){ perror(\"open\"); exit(0); } //获取源文件的大小 int size = lseek(fd,0,SEEK_END); //对新创建的文件进行拓展 // lseek(fd2,size,SEEK_SET); truncate(\"copy.txt\",size); write(fd2,\" \",1); //内存映射 void * ptr1 = mmap(NULL,size,PROT_READ,MAP_SHARED,fd,0); void * ptr2 = mmap(NULL,size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); if(ptr1==MAP_FAILED||ptr2==MAP_FAILED){ perror(\"mmap\"); exit(0); } //内存拷贝 memcpy(ptr2,ptr1,size); //关闭 munmap(ptr1,size); munmap(ptr2,size); close(fd2); close(fd); return 0; } ","date":"2023-03-01","objectID":"/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/:2:1","tags":["Linux多进程开发"],"title":"内存映射","uri":"/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"},{"categories":["Linux多进程开发"],"content":"进程间通讯概念 1.进程是一个独立的资源分配单元，不同的进程(用户进程)之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源 2.但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信 3.进程间通信的目的 3.1数据传输:一个进程需要将它的数据发送给另一个进程 3.2通知时间:一个进程需要向另一个或一组进程发送信息，通知他们发生了某种时间(如进程终止时通知父进程) 3.3资源共享:多个进程之间共享同样的资源，为了做到这一点，需要内核提供互斥和同步机制 3.4进程控制:游戏进程希望完全控制另一个进程的执行(如DEBUG)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变. ","date":"2023-03-01","objectID":"/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5/:0:0","tags":["Linux多进程开发"],"title":"进程间通信概念","uri":"/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5/"},{"categories":["Linux多进程开发"],"content":"同一主机进程间通信 Unix进程间通信方式:1.匿名管道2.有名管道3.信号 SystemV进程间通信方式:1.消息队列2.共享内存3.信号量 POSIX进程间通信方式:1.消息队列2.共享内存3.信号量 ","date":"2023-03-01","objectID":"/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5/:1:0","tags":["Linux多进程开发"],"title":"进程间通信概念","uri":"/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5/"},{"categories":["Linux多进程开发"],"content":"匿名管道 1.管道也叫匿名管道，他是UNIX系统IPC(进程间通信)最古老的形式，所有UNIX系统都支持这种通信机制 2.统计一个目录中文件的数目命令：ls|wc -l,为了执行该命令，shell创建了两个进程来分别执行ls和wc 管道的特点 1.管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同 2.管道拥有文件的特质:读操作.写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据，可以按照操作文件的方式对管道进行操作。 3.一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少 4.通过管道传递的数据是顺序的，从管道中读取的字节的顺序和它们被写入管道的顺序是一样的。 管道的特点 1.在管道中的数据传递方向是单向的，一端用于写入，一端用于读取，管道时半双工的 2.从管道读数据是一次操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用lseek()来随机访问数据 3.匿名管道只能在具有公共先祖的进程(父进程子进程，兄弟进程)之间使用。 匿名管道的使用 1.创建匿名管道 #include \u003cunistd.h\u003e int pipe(int pipefd(2)); 2.查看管道缓冲大小命令 ulimit -a 3.查看管道缓冲大小的函数 #include \u003cunistd.h\u003e long fpathconf(int fd,int name); example int pipe(int pipefd(2)); /* #include \u003cunistd.h\u003e int pipe(int pipefd[2]); 作用：创建一个匿名管道 参数: int pipefd[2]:这个数组是一个传出参数 pipefd[0]:对应的是读端 pipefd[1]:对应的是写端 返回值： success:0 fail：-1 and set errno 管道默认是阻塞的，如果管道中没有数据 read阻塞，如果管道满了，write阻塞 注意:匿名管道只能用于有关系的进程间通信 */ #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e //子进程发送数据给父进程 int main(){ //管道需要在fork之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret==-1){ perror(\"pipe\"); exit(0); } //创建子进程 pid_t pid =fork(); //判断 if(pid \u003e 0){ //父进程 printf(\"parent process pid %d\\n\",getpid()); char buf[1024]={0}; while(1){ int len = read(pipefd[0],buf,sizeof(buf)); printf(\"parent recv %s, pid %d\\n\",buf,getpid()); char * str = \"Hello I m parent\"; write(pipefd[1],str,strlen(str)); sleep(1); } }else if(pid == 0){ printf(\"child process, pid %d\\n\",getpid()); while(1){ //从管道的读取端读取数据 char * str = \"Hello I m child\"; write(pipefd[1],str,strlen(str)); sleep(1); char buf[1024]={0}; int len = read(pipefd[0],buf,sizeof(buf)); printf(\"child recv %s, pid %d\\n\",buf,getpid()); } } return 0; } example long fpathconf(int fd,int name); /* #include \u003cunistd.h\u003e long fpathconf(int fd, int name); long pathconf(const char *path, int name); */ #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(int argc ,char *argv[]){ int pipefd[2]; int ret = pipe(pipefd); if(ret==-1){ perror(\"pipe\"); exit(0); } pid_t pid = fork(); if(pid\u003e0){ //father process printf(\"father process pid = %d\\n\",getpid()); printf(\"pipe read buffer size = %ld,pipe write buffer size = %ld\\n\",fpathconf(pipefd[0],_PC_PIPE_BUF),fpathconf(pipefd[1],_PC_PIPE_BUF)); }else if(pid==0){ printf(\"child process pid = %d\\n\",getpid()); printf(\"pipe read buffer size = %ld,pipe write buffer size = %ld\\n\",fpathconf(pipefd[0],_PC_PIPE_BUF),fpathconf(pipefd[1],_PC_PIPE_BUF)); } return 0; } 由于上述代码使用sleep控制输出，才没有导致单一进程读写管道内数据。基本上管道只作为单一方向通信时使用。其使用的模型分为三种，如下图所示 所以，如果我们想要双方通信的话，可以选择模式3，关闭写方读通道，关闭读方写通道。具体代码如下： /* #include \u003cunistd.h\u003e int pipe(int pipefd[2]); 作用：创建一个匿名管道 参数: int pipefd[2]:这个数组是一个传出参数 pipefd[0]:对应的是读端 pipefd[1]:对应的是写端 返回值： success:0 fail：-1 and set errno 管道默认是阻塞的，如果管道中没有数据 read阻塞，如果管道满了，write阻塞 注意:匿名管道只能用于有关系的进程间通信 */ #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e //子进程发送数据给父进程 int main(){ //管道需要在fork之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret==-1){ perror(\"pipe\"); exit(0); } //创建子进程 pid_t pid =fork(); //判断 char buf[1024]={0};//buffer if(pid \u003e 0){ //父进程读 printf(\"parent process pid %d\\n\",getpid()); //关闭写 close(pipefd[1]); while(1){ int len = read(pipefd[0],buf,sizeof(buf)); printf(\"parent recv %s, pid %d\\n\",buf,getpid()); memset(buf,'\\0',sizeof(buf)); sleep(1); } }else if(pid == 0){ //子进程写 printf(\"child process, pid %d\\n\",getpid()); //关闭读 close(pipefd[0]); char *str = \"我爱洗澡皮肤好好,噢噢噢噢！\"; while(1){ write(pipefd[1],str,strlen(str)); sleep(1); } } return 0; } 案例 实现ps aux | grep xxx /* 实现ps aux | grep xxx 父子进程间通信 子进程执行ps aux，子进程结束之后，将数据发送给父进程 父进程获取到数据，过滤 pipe() fork() execlp() 子进程讲标准输出stdout_fileno 重定向到管道的写端 dup */ #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cregex.h\u003e #include \u003cwait.h\u003e int main(int argc,char * argv[]){ //先创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret==-1){ perror(\"pipe\"); exit(0); } /","date":"2023-03-01","objectID":"/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5/:1:1","tags":["Linux多进程开发"],"title":"进程间通信概念","uri":"/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5/"},{"categories":["Linux多进程开发"],"content":"有名管道 1.匿名管道，由于没有名字，只能用于亲缘关系的进程间通信，为了克服这一点，提出了有名管道(FIFO)，也叫命名管道，FIFO文件 2.有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的。这样及时与FIFO的创建进程不存在亲缘关系的进程，也可以访问该路径，就能够彼此通过FIFO通信。 3.一旦打开了FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的IO系统调用(read,write,close)。与管道一样，FIFO也有一个写入端和一个读取端。并且从个管道中读取数据的顺序与写入的顺序是一样的。FIFO的名称也由此而来，First in First out 区别 有名管道(FIFO)和匿名管道(pipe)有一些特点相同，不一样的地方在于: 1.FIFO在文件系统中作为一个特殊文件存在，但FIFO中的内容却存放在内存中 2.当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用. 3.FIFO有名字，不相干的进程可以打开有名管道进行通信 有名管道的使用 1.通过命令创建有名管道 mkfifo 名字 2.通过函数创建 #include \u003csys/types/h\u003e #inclued \u003csys/stat.h\u003e int mkfifo(const char *pathname,mode_t mode); 3.一旦使用mkfifo创建了一个FIFO,就可以使用open打开，使用IO函数操作 4.不支持lseek()等文件定位操作 ","date":"2023-03-01","objectID":"/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5/:1:2","tags":["Linux多进程开发"],"title":"进程间通信概念","uri":"/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5/"},{"categories":["hugo使用","Git使用"],"content":"关于Hugo在GitAction部署期间的问题 参参照网站: 1.利用GitHub Action实现Hugo博客在GitHub Pages自动部署(Access day:2023/02/28) 2.Hugo + GitHub Action，搭建你的博客自动发布系统(Access day:2023/02/28) ","date":"2023-02-28","objectID":"/gitaction_hugo/:0:0","tags":["hugo"],"title":"Hugo + GitHub Action + 腾讯云 搭建你的博客自动发布系统","uri":"/gitaction_hugo/"},{"categories":["hugo使用","Git使用"],"content":"hugo使用请参照 创建Blog流程 ","date":"2023-02-28","objectID":"/gitaction_hugo/:1:0","tags":["hugo"],"title":"Hugo + GitHub Action + 腾讯云 搭建你的博客自动发布系统","uri":"/gitaction_hugo/"},{"categories":["hugo使用","Git使用"],"content":"搭建流程(域名),其他可参考上述网站 1.进入腾讯云购买个人域名 2.进入腾讯云的管理节点，点击自己购买的域名，选择添加记录，并选择记录类型CNAME，将记录值修改为自己的github.io，如下图: 3.进入github,在自己的github.io仓库下进入Settings，并在侧边栏找到Pages,修改Custom Domain，将其修改为自己购买的域名。如下图 4.修改个人博客的配置文件(config.yml),将其中的baseUrl设置为自己的域名。如下图: ","date":"2023-02-28","objectID":"/gitaction_hugo/:2:0","tags":["hugo"],"title":"Hugo + GitHub Action + 腾讯云 搭建你的博客自动发布系统","uri":"/gitaction_hugo/"},{"categories":["hugo使用","Git使用"],"content":"问题1 hugo调用的主题是一个Git仓库 如果hugo调用的主题是一个Git仓库的，可以使用以下命令，将主题的Git仓库作为你的仓库的子目录，它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 默认情况下，子模块会将子项目放到一个与仓库同名的目录中，即“XXX”。 如果你想要放到其他地方，那么可以在命令结尾添加一个不同的路径。如果这时运行 git status，注意到新的.gitmodules文件。该配置文件保存了项目URL与已经拉取的本地目录之间的映射。 $ git status On branch master Your branch is up-to-date with 'origin/master'. Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) new file: .gitmodules new file: XXX .gitmodules的配置具体为下： [submodule \"themes/LoveIt\"] path = themes/LoveIt url = https://github.com/dillonzq/LoveIt.git branch = release ","date":"2023-02-28","objectID":"/gitaction_hugo/:3:0","tags":["hugo"],"title":"Hugo + GitHub Action + 腾讯云 搭建你的博客自动发布系统","uri":"/gitaction_hugo/"},{"categories":["hugo使用","Git使用"],"content":"问题2 未知但解决的问题 错误为以下问题 /usr/bin/git push origin main fatal: unable to access 'https://x-access-token:***@github.com/zxlkgf/zxlkgf.github.io.git/': URL using bad/illegal format or missing URL Error: Action failed with \"The process '/usr/bin/git' failed with exit code 128 原先在YML中使用的是PERSONAL_TOKEN,不知道为什么报错，原因目前未知。 查看以下网页，发现可以改名尝试。 GitHub Actions: actions/checkout で、repository not found エラーが出るときの回避策 遂改为ZXL_BLOG_TOKEN之后问题解决。 YML文件如下 name: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \"0 0 * * *\" jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"latest\" extended: true - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.ZXL_BLOG_TOKEN }} EXTERNAL_REPOSITORY: zxlkgf/zxlkgf.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} ","date":"2023-02-28","objectID":"/gitaction_hugo/:4:0","tags":["hugo"],"title":"Hugo + GitHub Action + 腾讯云 搭建你的博客自动发布系统","uri":"/gitaction_hugo/"},{"categories":["Linux编程入门"],"content":"exec函数族介绍 1.exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件 2.exec函数组的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段，堆栈等已经被新的内容取代了，只留下进程ID等表面上的信息仍保持原样，只有调用失败了，它们才会返回-1，从原程序的调用点接着往下执行 ","date":"2023-02-07","objectID":"/exec%E5%87%BD%E6%95%B0%E6%97%8F/:0:0","tags":["Linux编程入门"],"title":"exec函数族","uri":"/exec%E5%87%BD%E6%95%B0%E6%97%8F/"},{"categories":["Linux编程入门"],"content":"exec函数族 int execl(const char *pathname, const char arg, … / (char *) NULL */); int execlp(const char *file, const char arg, …/ (char *) NULL */); int execle(const char *pathname, const char arg, …/, (char *) NULL, char *const envp[] */); int execv(const char *pathname, char *const argv[]); int execvp(const char *file, char *const argv[]); int execvpe(const char *file, char *const argv[],char *const envp[]); l(list) 参数地址列表，以空指针结尾 v(vector) 存有各参数地址的指针数组的地址 p(path) 按PATH环境变量指定的目录搜索可执行文件 e(environment) 存有环境变量字符串地址的指针数组的地址 ","date":"2023-02-07","objectID":"/exec%E5%87%BD%E6%95%B0%E6%97%8F/:1:0","tags":["Linux编程入门"],"title":"exec函数族","uri":"/exec%E5%87%BD%E6%95%B0%E6%97%8F/"},{"categories":["进程","Linux"],"content":"进程 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:0:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"查看进程 ps aux/ajx a:显示终端上所有进程，包括其他用户的进程 u:显示进程的详细信息 x:显示没有控制终端的进程 j:列出与作业息息相关的信息 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:1:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"进程相关STAT参数 D 不可中断 R 正在运行，或在队列中的进程 S 休眠状态 T 停止或被追踪 Z 僵尸进程 W 进入内存交换(kneral2.6开始无效) X 死掉的进程 \u003c 高优先级 N 低优先级 s 包含子进程 + 位于前台的进程组 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:2:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"进程相关命令 top 可以再使用top命令上加-G来指定显示信息更新的时间间隔，在top命令执行后，可以按一下按键显示的结果进行排序： M 根据内存使用量排序 P 根据CPU占有率进行排序 T 根据进程运行时间长短排序 U 根据用户名来筛选 K 输入指定的PID杀死线程 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:3:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"杀死进程 kill [-signal] pid kill -l 列出所有信号 kill -SIGKILL 进程ID kill -9 进程ID killall name 根据进程名杀死进程 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:4:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"进程号和相关函数 1.每个进程都由进程号来标识，其类型为pid_t(整型),进程号的范围为0-32767，进程号总是唯一的，但可以重复使用 2.任何进程(除了init进程)都是由另一个进程创建，该进程成为被创建进程的父进程，对于的进程号为父进程号(PPID) 3.进程组是一个或多个进程的集合，他们之间互相关联，进程组可以接受同一终端的各种信号，关联的进程有一个进程组号(PGID)，默认情况下，当前的进程号会当做当前的进程组号 4.进程号和进程组的相关函数 pid_t getpid(void); pid_t getppid(void); pid_t getpgid(void); ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:5:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"孤儿进程 1.父进程允许结束，但是子进程还在运行，这样的进程成为孤儿进程 2.每当出现一个孤儿进程的时候，内存就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。 3.因此孤儿进程并不是什么危害 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:6:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"僵尸进程 1.每个进程结束之后，，都会释放自己地址空间中的用户数据，内核区的pcb没有办法自己去释放需要父进程去释放 2.进程终止时，父进程尚未回收，子进程残留资源(pcb)存放于内核中，变成僵尸进程 3.僵尸进程不可被kill -9杀死 4.这样会导致一个问题 ，父进程不调用wait()或者waitpid()的话，那么保留的那段信息不会被释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的僵尸进程产生，，将因为没有可以使用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:7:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"进程回收 1.在每个进程退出的时候，内核释放进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息，这些信息主要指向控制块PCB的信息 2.父进程可以通过调用wait或者waitpid得到它的退出状态同时彻底清除掉这个进程。 3.wait()和waitpid()函数功能一样，区别在于，wait()函数会阻塞，waitpid()可以设置不阻塞，waitpid()可以指定等待哪个子进程结束。 4.注意 一次wait或waitpid调用只能清理一个子进程，清理多个子进程需要循环 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:8:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"退出信息相关宏函数 WIFEXITED(status) 非0 进程正常退出 WEXITSTATUS(status) 如果宏为真，获取进程退出的状态 WIFSIGNALED(status) 非0 进程异常退出 WTERMSIG(status) 如果上宏为真，获取使进程停止的信号编号 WIFSTOPPED(status) 非0 进程处于暂停 WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号 WIFCONTINUED(status) 非0 进程暂停后已经继续运行 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:9:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["Linux多进程开发"],"content":"进程的创建 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/:0:0","tags":["Linux多进程开发"],"title":"进程创建","uri":"/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"},{"categories":["Linux多进程开发"],"content":"01进程创建 系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建子进程，形成进程树结构模型 #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e pid_t fork(void); 返回值: 成功:子进程中返回0,父进程中返回子进程ID 失败:返回-1; 失败原因: 1.当前系统的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN 2.系统内存不足，这时errno的值为ENOMEM ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/:1:0","tags":["Linux多进程开发"],"title":"进程创建","uri":"/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"},{"categories":["Linux多进程开发"],"content":"fork()进程创建总结 首先父进程执行到fork的时候会创建子进程，fork后会给父子进程分别返回一个pid号（父进程fork后返回的pid是子进程的pid，子进程的pid为0），此时系统会将父进程的用户区数据和内核数据区拷贝过来生成一个虚拟地址空间供子进程使用，之后，如果没有执行写操作的时候，父子进程共同指向一个虚拟地址空间，但是一旦发生内存写操作，就会生成新的内存空间将父子进程的变量分开，防止内存碰撞。 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/:2:0","tags":["Linux多进程开发"],"title":"进程创建","uri":"/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"},{"categories":["Linux多进程开发"],"content":"GDB多进程调试 使用GDB调试的时候，GDB默认只能跟踪一个进程，可以再fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者跟踪子进程，默认跟踪父进程 设置调试父进程或者子进程: set follow-fork–mode [parent (默认)|child] 设置调试模式:set detach-on-fork [on|off] 默认为on,表示调试当前进程的时候，其他的进程可以运行，如果为off，调试当前进程的时候，其他进程会被GDB挂起 查看调试进程:info inferiors 切换当前调试进程: inferior id 使进程脱离GDB调试:detach inferiors id ","date":"2023-02-04","objectID":"/gdb%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95/:0:0","tags":["Linux多进程开发"],"title":"GDB多线程调试","uri":"/gdb%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":["Linux编程入门"],"content":"1.什么是GDB ","date":"2023-02-04","objectID":"/gdb/:0:0","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"GDB是由GNU软件系统社区提供的调试工具，同GCC配套组成的一套完整的开发环境，GDB是Linux和许多类Unix系统中的标准开发环境。 一般来说，GDB主要帮助你完成下面四个方面的功能: 1.启动程序，可以按照自定义的要求随心所欲的允许程序 2.可让被调试的程序在所指定的调置的断点处停住 3.可程序被停止住，可以检查此程序中所发生的事 4，可以改变程序，讲一个BUG产生的影响修正从而测试其他BUG ","date":"2023-02-04","objectID":"/gdb/:1:0","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"准备工作 通常，在为调试而编译时，我们会关掉编译器的优化选项(’-o’),并打开调试选项(’-g’)。另外，’-Wall’在尽量不影响程序行为的情况下选项打开所有的warning，也可以发现许多问题，避免一些不必要的BUG gcc -g -Wall program.c -o program ‘-g’ 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件 ","date":"2023-02-04","objectID":"/gdb/:2:0","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"命令 ","date":"2023-02-04","objectID":"/gdb/:3:0","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"启动和退出 gdb 可执行程序 quit ","date":"2023-02-04","objectID":"/gdb/:3:1","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"给程序设置参数/获取设置参数 set args 10 20 show args ","date":"2023-02-04","objectID":"/gdb/:3:2","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"GDB使用帮助 help ","date":"2023-02-04","objectID":"/gdb/:3:3","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"常看当前文件代码 list/l (从默认位置显示) list/l 行号 (从制定的行显示) list/l 函数名(从指定的函数显示) ","date":"2023-02-04","objectID":"/gdb/:3:4","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"查看非当前文件的代码 list/l 文件名:行号 list/l 文件名:函数名 ","date":"2023-02-04","objectID":"/gdb/:3:5","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"设置显示的行数 show list/listsize set list/listsize 行数 ","date":"2023-02-04","objectID":"/gdb/:3:6","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"GDB命令–断点操作 ","date":"2023-02-04","objectID":"/gdb/:4:0","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"设置断点 b/break 行号 b/break 函数名 b/break 文件名:行号 b/break 文件名:函数 ","date":"2023-02-04","objectID":"/gdb/:4:1","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"查看断点 i/info b/break ","date":"2023-02-04","objectID":"/gdb/:4:2","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"删除断点 d/del/delete 断点编号 ","date":"2023-02-04","objectID":"/gdb/:4:3","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"设置断点无效 dis/disable 断点编号 ","date":"2023-02-04","objectID":"/gdb/:4:4","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"断点生效 ena/enable 断点编号 ","date":"2023-02-04","objectID":"/gdb/:4:5","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"设置条件断点(一般用在循环的位置) b/break 10 if i==5 ","date":"2023-02-04","objectID":"/gdb/:4:6","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"GDB命令–调试命令 ","date":"2023-02-04","objectID":"/gdb/:5:0","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"允许GDB程序 start (程序停在第一行) run (遇到断点才停) ","date":"2023-02-04","objectID":"/gdb/:5:1","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"继续允许，到下一个断点停 c/continue ","date":"2023-02-04","objectID":"/gdb/:5:2","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"向下执行一行代码(不会进入函数体) n/next ","date":"2023-02-04","objectID":"/gdb/:5:3","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"变量操作 p/print 变量名 (打印变量值) ptype 变量名 (打印变量类型) ","date":"2023-02-04","objectID":"/gdb/:5:4","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"向下单步调试(遇到函数进入函数体) s/step finish(跳出函数体) ","date":"2023-02-04","objectID":"/gdb/:5:5","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"自动变量操作 display num(自动打印制定变量的值) i/info display undisplay 编号 ","date":"2023-02-04","objectID":"/gdb/:5:6","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"其他操作 set var 变量名=变量值 until (跳出循环) ","date":"2023-02-04","objectID":"/gdb/:5:7","tags":["Linux编程入门"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux编程入门"],"content":"什么是Makefile 1.一个工程中的源码不计其数，其按照类型，功能，模块分别放在若干个目录中，Makefile文件定义了一系列的规则来制定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile文件就像个Shell脚本一样，也可以执行操作系统命令 2.Makefile带来的好处就是’自动化编译’，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率，make是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令 Makefile文件命名和规则 ","date":"2023-02-03","objectID":"/makefile/:0:0","tags":["Linux编程入门"],"title":"Makefile","uri":"/makefile/"},{"categories":["Linux编程入门"],"content":"文件命名 makefile 或者Makefile ","date":"2023-02-03","objectID":"/makefile/:1:0","tags":["Linux编程入门"],"title":"Makefile","uri":"/makefile/"},{"categories":["Linux编程入门"],"content":"Makefile规则 一个Makefile文件中可以有一个或者多个规则 目标 …:依赖 … 命令(Shell 命令) … 目标:最终要生成的文件（伪目标除外） 依赖:生成目标所需要的文件或者目标 命令:通过执行命令对依赖操作生成目标(命令前必须Tal缩进) 工作原理 1.命令在执行之前，需要先检查规则中的依赖是否存在 1.1 如果存在 则执行命令 1.2 如果不存在，向下检查其他规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该条规则的命令 2.检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间 2.1 如果依赖的时间比目标的时间晚，则需要重新生成目标 2.2 如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行 变量 1.自定义变量 变量名=变量值 var=hello 2.预定义变量 AR : 归档维护程序的名称 默认值是ar CC : C编译器的名称 默认值是cc CXX : C++编译器的名称，默认值是g++ $@ : 目标的完整名称 $\u003c : 第一个依赖文件的名称 $^ : 所有的依赖文件 3.获取变量的值 $（变量名） 模式匹配 %.o:%.c -%:通配符，匹配一个字符串 两个%匹配的是同一个字符串 %.c:%.c gcc -c %\u003c -o $@ 函数1 $(wilecard PATTERN..) 功能:获取制定目录下制定类型的文件列表 参数:PATTERN 指的是某个获多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔 返回:得到的若干个文件的文件列表，文件名之间使用空格间隔 例子:$(wildcard .c ./sub/.c) 返回值格式: a.c b.c…. 函数2 $(patsubst ,,) 功能:查找中的单词（单词以’空格’,‘Tab’或‘回车’‘换行‘分割）是否符合模式,如果匹配的话，则以替换 可以包括通配符’%’,表示任意长度的字符串，如果中也包含’%’，那么中的这个’%‘将是中的那个’%‘所代表的的字符串 返回:函数返回被替换过后的字符号串 例子:$(patsubst %.c,%.o,x.c bar.c) 返回格式:x.o bar.o ","date":"2023-02-03","objectID":"/makefile/:2:0","tags":["Linux编程入门"],"title":"Makefile","uri":"/makefile/"},{"categories":["Linux编程入门"],"content":"01动态库的制作 命名规则 Linux:libxxx.so lib:前缀（固定） xxx:库的名字 自己起 .so:后缀（固定） 在Linux下是一个可执行文件 Windows:libxxx.dll 02动态库的制作: gcc得到.o文件，得到和位置无关的代码 gcc -c -fpic/-fPIC a.c b.c gcc得到动态库 gcc -shared a.o b.o -o libcalc.so 03工作原理 ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:0:0","tags":["Linux编程入门"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["Linux编程入门"],"content":"静态库: gcc进行连接时，会把静态库中的代码打包到可执行程序中 ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:1:0","tags":["Linux编程入门"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["Linux编程入门"],"content":"动态库: gcc进行连接时，动态库的代码不会被打包到可执行程序中 程序启动之后，动态库会被动态加载到内存中，通过ldd(list dynamic dependencies)命令检查动态库依赖关系 ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:2:0","tags":["Linux编程入门"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["Linux编程入门"],"content":"04如何定位共享库文件呢？ 当系统加载可执行代码时，能够知道其所依赖的库的名字，但是还需要知道绝对路径，此时就需要 系统的动态载入器获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的， 它先后搜索elf文件的 DT_RPATH段–\u003e环境变量LD_LIBRARY_PATH–\u003e/etc/ld.so.cache文件列表 –\u003e/lib/./usr/lib目录找到库文件后将其载入到内存 ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:3:0","tags":["Linux编程入门"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["Linux编程入门"],"content":"05解决动态库加载失败的问题 只需要在上述的环境变量LD_LIBRARY_PATH或者/etc/ld.so.cache文件列表 或者/lib/./usr/lib目录内，添加需要使用的动态库绝对路径即可 ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:4:0","tags":["Linux编程入门"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["Linux编程入门"],"content":"1.在PATH内添加LD_LIBRARY_PATH即可 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:[动态库的绝对路径] 但是由于配置的环境变量是临时的，终端关掉之后再打开就会失效，需要按照用户级别或者root级别配置 ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:4:1","tags":["Linux编程入门"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["Linux编程入门"],"content":"2.用户级别配置 在Home下使用vim .bashrc 在最底下添加 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:[动态库的绝对路径] 然后输入 source .bashrc或者 . .bashrc ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:4:2","tags":["Linux编程入门"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["Linux编程入门"],"content":"3.系统级别的配置 sudo vim /etc/profile 在最后一行插入export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:[动态库的绝对路径] 记得刷新profile ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:4:3","tags":["Linux编程入门"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["Linux编程入门"],"content":" 01什么是库 1.库文件是计算机上的一类文件，可以简单的把库文件看成代码仓库，它提供给使用者一些可以直接拿来用的变量，函数，类 2.库是特殊的程序，编写库的程序和编写一般的程序区别不大，只是库不能单独允许 3.库文件有两种，静态库和动态库(共享库)，区别是:静态库在程序的连接阶段被复制到了程序中，动态库在连接阶段没有被复制到程序中，而是在程序运行时由系统加载到内存中供程序使用 4.库的好处:1.代码保密 2.方便部署和分发 02静态库的制作 ","date":"2023-02-02","objectID":"/%E9%9D%99%E6%80%81%E5%BA%93/:0:0","tags":["Linux编程入门"],"title":"静态库","uri":"/%E9%9D%99%E6%80%81%E5%BA%93/"},{"categories":["Linux编程入门"],"content":"命名规则； Linux；libxxx.a lib:前缀(固定) xxx:库的名字，自己起 .a :后缀（固定） Window；libxxx.lib 静态库的制作: 1.gcc获得.o文件 2.将.o文件打包。使用 ar工具（archive） ar rcs libxxx.a xxx.o xxx.o r - 将文件插入备存文件中 c - 简历备存文件 s - 索引 ","date":"2023-02-02","objectID":"/%E9%9D%99%E6%80%81%E5%BA%93/:1:0","tags":["Linux编程入门"],"title":"静态库","uri":"/%E9%9D%99%E6%80%81%E5%BA%93/"},{"categories":["Linux编程入门"],"content":" 什么是GCC 1.GCC原名为GUN C语言编译器 2.GCC是由GNU开发的编程语言编译器 3.GCC不仅支持C的多种方言，也可以区别不同C的标准，可以使用命令行选项控制编译器在翻译源码时应该遵守那个C标准。例如，当使用命令行‘-std=99’启动GCC时，编译器支持C99标准 4.安装命令 sudo apt install gcc g++ 5.查看版本 gcc/g++ -v/–version GCC工作流程 源代码-\u003e预处理后源代码-\u003e汇编代码-\u003e目标代码-\u003e连接并输出 .h—– .i ———–.s .cpp .c 指令 gcc编译选项 说明 -E 预处理制定的源文件，不进行编译 -s 编译制定的源文件，不进行汇编 -c 编译，汇编制定的源文件，但是不进行连接 -o [file1][file2] / [file2] -o [file1] 将文件file2编译成可执行文件file1 -I directory 制定include包含文件的搜索目录 -g 在编译的时候，生成调试信息，该程序可以被调试器调试 -D 在程序编译的时候，制定一个宏 -w 不生成任何警告 -Wal 生成警告信息 -On n的取值范围:0-3 编译器的优化选项的4个级别 -l 在程序编译的时候，使用指定的库 -L 指定编译的时候，搜索的库的路径 -fPIC/fpic 生成与位置无关的代码 -shared 生成共享目标文件，通常用在建立共享库时 -std 制定C方言:如:-std=c99 gcc和g++ ","date":"2023-02-01","objectID":"/gcc/:0:0","tags":["Linux编程入门"],"title":"GCC基础","uri":"/gcc/"},{"categories":["Linux编程入门"],"content":"gcc 和 g++都是GNU的一个编译器 误区1：gcc只能编译c代码，g++只能编译C++代码。两者都可以 1.1后缀为.c的，gcc会将它当成c程序，而g++当做c++程序 1.2后缀为.cpp的 两则都会认为是c++程序，c++的语法规则更加严谨一些 1.3编译阶段，g++会调用gcc，对c++代码，两者是等价的，但是因为gcc命令 不能自动和C++程序使用的库连接，所以通常用g++完成连接 ","date":"2023-02-01","objectID":"/gcc/:1:0","tags":["Linux编程入门"],"title":"GCC基础","uri":"/gcc/"},{"categories":["Linux编程入门"],"content":"误区2：gcc不会定义__cplusplus宏，而g++会 2.1 实际上，这个宏只是标志编译器将会把代码按照c还是c++语法解释 ","date":"2023-02-01","objectID":"/gcc/:2:0","tags":["Linux编程入门"],"title":"GCC基础","uri":"/gcc/"},{"categories":["Linux编程入门"],"content":"误区3：编译只能用gcc，连接只能用g++ 3.1：严格来说，这句话不算错误，但是它会混淆了概念，应该这样说：编译可以用gcc/g++，而连接可以用g++或者gcc -lstdc++ 3.2：gcc命令不能自动和C++程序使用的库连接在一起，所以通常会使用g++来完成连接。但是在编译阶段，g++会自动调用gcc，二者等价 ","date":"2023-02-01","objectID":"/gcc/:3:0","tags":["Linux编程入门"],"title":"GCC基础","uri":"/gcc/"},{"categories":["算法"],"content":"差分数组 如果给你一个包含5000万个元素的数组，然后会有频繁区间修改操作，那什么是频繁的区间修改操作呢？比如让第1个数到第1000万个数每个数都加上1，而且这种操作时频繁的。 此时你应该怎么做？很容易想到的是，从第1个数开始遍历，一直遍历到第1000万个数，然后每个数都加上1，如果这种操作很频繁的话，那这种暴力的方法在一些实时的系统中可能就拉跨了。 因此，今天的主角就出现了——差分数组。 ","date":"2022-11-16","objectID":"/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/:0:0","tags":["差分数组"],"title":"差分数组","uri":"/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"},{"categories":["算法"],"content":"1.定义 差分数组就是与原数组同样大小的数组 原数组记为:a[] 差分数组记为:d[] 公式: 1.i=1时 d[i]=a[i] 2.i\u003e1时,d[i]=a[i]-a[i-1] 恢复公式 a[i]=d[i]+a[i-1] index 0 1 2 3 4 原数组a 1 3 7 5 2 差分d 1 2 4 -2 -3 sum.d 1 3 7 5 2 ","date":"2022-11-16","objectID":"/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/:1:0","tags":["差分数组"],"title":"差分数组","uri":"/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"},{"categories":["算法"],"content":"2.差分数组的应用:区间的快速加减 对区间[L,R]统一加上X,只需要在差分数组d[L]+X,d[R+1]-X即可 例如，对区间[1,3]加3 index 0 1 2 3 4 原数组 1 3 7 5 2 原差分d 1 2 4 -2 -3 减差分 1 5 4 -2 0 还原数组 1 6 10 8 2 ","date":"2022-11-16","objectID":"/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/:2:0","tags":["差分数组"],"title":"差分数组","uri":"/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"},{"categories":["算法"],"content":"1.前缀和 ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:0:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"1.问题 输入一个长度为n的整数数列, 接下来在输入m个询问, 每个询问都输入一对l(left),r(right) ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:1:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"2.输入格式 第一行输入长度n和询问m 第二行包含n个整数 接下来的m行，每行包含两个整数l(left)和r(right)，表示查询区间范围 ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:2:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"3.输出格式 共m行，每行表示一个结果 ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:3:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"4.数据范围 1≤l≤r≤n 1≤n,m≤100000 −1000≤数列中元素的值≤1000 ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:4:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"5.输入样例： 输入n,m : 5 3 输入n个整数 : 2 1 3 6 4 输入询问: 1 2 1 3 2 4 ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:5:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"6.输出样例: 3 6 10 以上是一道最纯粹的前缀和的问题 接下来，讨论一下什么是前缀和 2.什么是前缀和 我们先给出一个数组: 1,2,3,4,5,6,7,8,9 那么这个数组的前缀和即为: 1,3,6,10,15,21,28,36,45 前缀和就是从第1个数到当前数组的区间和 为了更好的了解前缀和 我们把上述内容放入数组中进行表示 数组a[]表示原数组: a[9]={1,2,3,4,5,6,7,8,9}; 数组res[]表示原数组的前缀和数组: res[9]={1,3,6,10,15,21,28,36,45}; 前缀和与原数组之间的代数关系 res[0] = a[0] = 1 res[1] = a[0] + a[1] = 1 + 2 res[2] = a[0] + a[1] + a[2] = 1 + 2 + 3 res[3] = a[0] + a[1] + a[2] + a[3] = 1 + 2 + 3 + 4 ............ res[8] = a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45 res[i-1] = a[0] + a[1] + ....... + a[i-1] (0\u003c=i \u003c 9) ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:6:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"前缀和的计算与输出 int a[9]={1,2,3,4,5,6,7,8,9}; int res[] = new int[a.length]; res[0] = a[0]; for(int i = 1; i \u003c n ; i++){ res[i] = a[i]+res[i-1]; } ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:7:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"前缀和的优势：以(o1)的时间复杂度得到某块区间的总和 那么如何求出某块区间的和呢? 我们用L和R表示区间的左端点和右端点 res[L]和res[R]表示左右端点 res[L]=a[0]+a[1]+a[2]+...+a[L] res[R]=a[0]+a[1]+a[2]+...+a[L]+a[L+1]+a[L+2]+...+a[R] (L\u003c=R) 我们要求的是[L,R]之间的和 即a[L]+a[L+1]+a[L+2]+...+a[R] 即res[R]-res[L-1] ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:8:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"问题的解答 #include \u003ciostream\u003e using namespace std; //定义范围 +10为防止数据溢出 const int N = 100010; int n, m; int a[N], s[N]; int main(){ //输入数组范围，查询次数 cin \u003e\u003e n \u003e\u003e m; //计算前缀和数组 for (int i = 1; i \u003c= n; i ++ ) { cin \u003e\u003e a[i], s[i] = s[i - 1] + a[i]; } //遍历查询 while (m -- ){ int l, r; cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c s[r] - s[l - 1] \u003c\u003c endl; } return 0; } ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:9:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["Git使用"],"content":"1.什么是.gitignore 在一些项目中，我们不想让本地仓库的所有文件都上传到远程仓库, 比如:万恶的.DS_Store ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:1:0","tags":["Git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["Git使用"],"content":"2.使用规则 ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:0","tags":["Git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["Git使用"],"content":"2.1 注释 # this is .gitignore file. # 以下是忽略的文件 .DS_Store 上述例子中，#开头的就是注释 ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:1","tags":["Git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["Git使用"],"content":"2.2 忽略特定的后缀 # 忽略后缀为exe的文件 *.exe ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:2","tags":["Git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["Git使用"],"content":"2.3 忽略整个文件夹 如果我们想要忽略某个路径下文件夹的所有内容 我们可以在该文件夹路径的后面加入/,如下 folder/ ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:3","tags":["Git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["Git使用"],"content":"2.4 忽略文件和目录 例如:folder 表示忽略folder文件和folder目录 会搜索多级目录，找到所有名为folder的文件 folder ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:4","tags":["Git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["Git使用"],"content":"2.5 !表示取反 如果我们想要保留src/lib下的man.txt 那么我们可以写下如下内容 !man.txt ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:5","tags":["Git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["Git使用"],"content":"2.6 glob通配符 常用的通配符 (1) * :可以代表一切的字符串，可以是0个也可以是任意多个字符 (2) ? :匹配除了’/‘以外的任意一个字符 (3) []:匹配多个列表中的字符 例如想要清除所有.txt文件 *.txt 如果想要清除目标文档下的所有.json文件 src/*.json ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:6","tags":["Git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["Git使用"],"content":"2.7 双星号 斜杠后面紧跟两个连续的星号**,表示多级目录 src/**/folder ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:7","tags":["Git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["Git使用"],"content":"3 其他规则 (1) .gitignore 文件也会上传到远程仓库 (2) 如果本地仓库已被跟踪，那么即使在.gitignore中设置了忽略，也不起作用 ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:3:0","tags":["Git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["hugo使用"],"content":"使用hugo创建Blog ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:0:0","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.创建流程 ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:0","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.1 下载 hugo //使用homebrew下载hugo brew install hugo ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:1","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.2 快速创建 hugo new site mysite ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:2","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.3 下载主题 //在刚刚创建的mysite/themes文件下打开终端 //LoveIt为当前作者选择的主题 git clone https://github.com/dillonzq/LoveIt.git LoveIt ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:3","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.4 阅读主题demo或者文档 ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:4","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.5 快速创建写作文档 执行以下命令，在mysite/content下创建posts/my-first-post.md文档 hugo new posts/my-first-post.md 按照想要你想要编辑的方式，去改写my-first-post.md文档 在启用drafts参数的条件下开启Hugo内置的服务器。 hugo server -D ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:5","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.6 上传github 在github创建后缀为github.io的仓库 将hugo的baseUrl设置为GitHub仓库的地址 并将主题设置为当前主题 hugo --theme=LoveIt --baseUrl=\"http://zxlkgf.github.io/\" --buildDrafts 再将public文件夹上传到github即可 ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:6","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.7 hugo基本使用 使用方法: hugo hugo [flags] hugo [command] hugo [command] [flags] 例如 command: new 为你的站点创建新的内容 server 一个高性能的web服务器 节选的 flags: -D, –buildDrafts 包括被标记为draft的文章 -E, –buildExpired 包括已过期的文章 -F, –buildFuture 包括将在未来发布的文章 例子: hugo -D 生成静态文件并包括draft为true的文章 hugo new post/new-content.md 新建一篇文章 hugo new site mysite 新建一个称为mysite的站点 hugo server –buildExpired 启动服务器并包括已过期的文章 ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:7","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["SpringBoot","Mybatis"],"content":"Kaptcha ","date":"2022-10-23","objectID":"/springboot%E9%A1%B9%E7%9B%AE-kaptcha/:0:0","tags":["computerStore"],"title":"SpringBoot项目-Kaptcha","uri":"/springboot%E9%A1%B9%E7%9B%AE-kaptcha/"},{"categories":["SpringBoot","Mybatis"],"content":"1.1 Kaptcha简介 Kaptcha 是一个扩展自simplecaptcha的验证码库，默认情况下，Kaptcha非常易于设置和使用，并且默认输出会产生一个很难验证的验证码。默认情况下，它生成的验证码看起来与上面的非常相似。如果您想更改输出的外观，则有几个配置选项，并且该框架是模块化的，因此您可以编写自己的变形代码。 参考资料:( kaptcha验证码使用) ","date":"2022-10-23","objectID":"/springboot%E9%A1%B9%E7%9B%AE-kaptcha/:1:0","tags":["computerStore"],"title":"SpringBoot项目-Kaptcha","uri":"/springboot%E9%A1%B9%E7%9B%AE-kaptcha/"},{"categories":["SpringBoot","Mybatis"],"content":"1.2 Kaptcha详细配置表 2 Maven依赖 \u003c!-- 验证码 --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003ekaptcha-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.1.0\u003c/version\u003e \u003c/dependency\u003e 3.创建配置类 package com.zxl.store.config; import com.google.code.kaptcha.impl.DefaultKaptcha; import com.google.code.kaptcha.util.Config; import lombok.extern.slf4j.Slf4j; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.Properties; /** * @author zxl * @version 1.0 * @description: kaptcha配置类 * @date 2022/10/30 */ @Slf4j @Configuration public class KaptchaConfig { //kaptcha @Bean public DefaultKaptcha getKaptcheCode() { DefaultKaptcha defaultKaptcha = new DefaultKaptcha(); // 创建properties Properties properties = new Properties(); //是否有边框 NO properties.setProperty(\"kaptcha.border\", \"no\"); //字体颜色 black properties.setProperty(\"kaptcha.textproducer.font.color\", \"black\"); //图片宽度 100 properties.setProperty(\"kaptcha.image.width\", \"100\"); //图片高度 36 properties.setProperty(\"kaptcha.image.height\", \"36\"); //字体大小 30px properties.setProperty(\"kaptcha.textproducer.font.size\", \"30\"); //图片样式 阴影 properties.setProperty(\"kaptcha.obscurificator.impl\", \"com.google.code.kaptcha.impl.ShadowGimpy\"); //session key = code properties.setProperty(\"kaptcha.session.key\", \"code\"); //干扰实现类 properties.setProperty(\"kaptcha.noise.impl\", \"com.google.code.kaptcha.impl.NoNoise\"); //背景渐变颜色 开始颜色 properties.setProperty(\"kaptcha.background.clear.from\", \"232,240,254\"); //背景渐变颜色 结束颜色 properties.setProperty(\"kaptcha.background.clear.to\", \"232,240,254\"); //验证码长度 properties.setProperty(\"kaptcha.textproducer.char.length\", \"4\"); //字体 properties.setProperty(\"kaptcha.textproducer.font.names\", \"彩云,宋体,楷体,微软雅黑\"); //设置参数 Config config = new Config(properties); defaultKaptcha.setConfig(config); return defaultKaptcha; } } 创建控制类 package com.zxl.store.controller; import com.google.code.kaptcha.Constants; import com.google.code.kaptcha.Producer; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import javax.imageio.ImageIO; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.awt.image.BufferedImage; /** * @author zxl * @version 1.0 * @description: kaptcha的控制层,kaptcha调用 * @date 2022/10/30 */ @Slf4j @RestController @RequestMapping(\"/kaptcha\") public class KaptchaController { @Autowired private Producer producer; @GetMapping(\"/kaptcha-image\") public void getKaptchaImage(HttpServletRequest request, HttpServletResponse response) throws Exception { //禁止server缓存 response.setDateHeader(\"Expires\", 0); //设置标准的http/1.1 no-cache headers response.setHeader(\"Cache-Control\", \"no-store, no-cache, must-revalidate\"); // 设置IE扩展 HTTP/1.1 no-cache headers (use addHeader) response.addHeader(\"Cache-Control\", \"post-check=0, pre-check=0\"); // 设置标准 HTTP/1.0 不缓存图片 response.setHeader(\"Pragma\", \"no-cache\"); // 返回一个 jpeg 图片，默认是text/html(输出文档的MIMI类型) response.setContentType(\"image/jpeg\"); // 为图片创建文本 String capText = producer.createText(); // 输出验证码 log.info(\"******************当前验证码为：{}******************\", capText); // 将验证码存于session中 request.getSession().setAttribute(Constants.KAPTCHA_SESSION_KEY, capText); // 创建带有文本的图片 BufferedImage bi = producer.createImage(capText); ServletOutputStream out = response.getOutputStream(); // 向页面输出验证码 ImageIO.write(bi, \"jpg\", out); try { // 清空缓存区 out.flush(); } finally { // 关闭输出流 out.close(); } } } ","date":"2022-10-23","objectID":"/springboot%E9%A1%B9%E7%9B%AE-kaptcha/:2:0","tags":["computerStore"],"title":"SpringBoot项目-Kaptcha","uri":"/springboot%E9%A1%B9%E7%9B%AE-kaptcha/"},{"categories":["SpringBoot","Mybatis"],"content":"AOP ","date":"2022-10-22","objectID":"/springboot%E9%A1%B9%E7%9B%AE-aop/:1:0","tags":["computerStore"],"title":"SpringBoot项目-AOP","uri":"/springboot%E9%A1%B9%E7%9B%AE-aop/"},{"categories":["SpringBoot","Mybatis"],"content":"1 Spring AOP AOP：面向切面（Aspect）编程。AOP并不是Spring框架的特性，只是Spring很好的支持了AOP。 如果需要在处理每个业务时，都执行特定的代码，则可以假设在整个数据处理流程中存在某个切面，切面中可以定义某些方法，当处理流程执行到切面时，就会自动执行切面中的方法。最终实现的效果就是：只需要定义好切面方法，配置好切面的位置（连接点），在不需要修改原有数据处理流程的代码的基础之上，就可以使得若干个流程都执行相同的代码。 ","date":"2022-10-22","objectID":"/springboot%E9%A1%B9%E7%9B%AE-aop/:1:1","tags":["computerStore"],"title":"SpringBoot项目-AOP","uri":"/springboot%E9%A1%B9%E7%9B%AE-aop/"},{"categories":["SpringBoot","Mybatis"],"content":"2 切面方法 1.切面方法的访问权限是public。 2.切面方法的返回值类型可以是void或Object，如果使用的注解是@Around时，必须使用Object作为返回值类型，并返回连接点方法的返回值；如果使用的注解是@Before或@After等其他注解时，则自行决定。 3.切面方法的名称可以自定义。 4.切面方法的参数列表中可以添加ProceedingJoinPoint接口类型的对象，该对象表示连接点，也可以理解调用切面所在位置对应的方法的对象，如果使用的注解是@Around时，必须添加该参数，反之则不是必须添加。 ","date":"2022-10-22","objectID":"/springboot%E9%A1%B9%E7%9B%AE-aop/:1:2","tags":["computerStore"],"title":"SpringBoot项目-AOP","uri":"/springboot%E9%A1%B9%E7%9B%AE-aop/"},{"categories":["SpringBoot","Mybatis"],"content":"3 统计业务方法执行时长 1.在使用Spring AOP编程时，需要先在pom.xml文件中添加两个关于AOP的依赖aspectjweaver和aspectjtools。 \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjtools\u003c/artifactId\u003e \u003c/dependency\u003e 2.在com.cy.store.aop包下创建TimerAspect切面类，在类之前添加@Aspect和@Component注解修饰。 package com.cy.store.aop; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.stereotype.Component; @Aspect @Component public class TimerAspect { } 3.在类中添加切面方法around(ProceedingJoinPoint pjp)。 public Object around(ProceedingJoinPoint pjp) throws Throwable { // 记录起始时间 long start = System.currentTimeMillis(); // 执行连接点方法，即切面所在位置对应的方法。本项目中表示执行注册或执行登录等 Object result = pjp.proceed(); // 记录结束时间 long end = System.currentTimeMillis(); // 计算耗时 System.err.println(\"耗时：\" + (end - start) + \"ms.\"); // 返回连接点方法的返回值 return result; } 4.最后需要在方法之前添加@Around注解，以配置连接点，即哪些方法需要应用该切面。 @Around(\"execution(* com.zxl.store.service.impl.*.*(..))\") 5.启动项目，在前端浏览器访问任意一个功能模块进行功能的测试。 ","date":"2022-10-22","objectID":"/springboot%E9%A1%B9%E7%9B%AE-aop/:1:3","tags":["computerStore"],"title":"SpringBoot项目-AOP","uri":"/springboot%E9%A1%B9%E7%9B%AE-aop/"},{"categories":["SpringBoot","Mybatis"],"content":"9 商品搜索 ","date":"2022-10-20","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/:1:0","tags":["computerStore"],"title":"SpringBoot项目-商品搜索","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/"},{"categories":["SpringBoot","Mybatis"],"content":"9.1 关于商品的模糊搜索 9.1.1 后端-持久层 1.编写sql SELECT id,title,sell_point,price,image FROM t_product WHERE STATUS = 1 AND title LIKE '%${title}%' ORDER BY priority DESC; 2.编写Mapper接口的抽象方法 /** * 按照输入的标题查找 * @param title * @return */ List\u003cProduct\u003e findProductByTitle(String title); 3.编写Mapper接口的映射文件 \u003c!-- List\u003cProduct\u003e findProductByTitle(String title);--\u003e \u003cselect id=\"findProductByTitle\" resultType=\"com.zxl.store.entity.Product\"\u003e SELECT id,title,sell_point,price,image FROM t_product WHERE STATUS = 1 AND title LIKE '%${title}%' ORDER BY priority DESC \u003c/select\u003e ","date":"2022-10-20","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/:1:1","tags":["computerStore"],"title":"SpringBoot项目-商品搜索","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/"},{"categories":["SpringBoot","Mybatis"],"content":"9.1.2 后端-业务层 1.处理异常 2.编写业务层抽象方法 /** * 按照标题查询 * @param title * @param pageNum * @param pageSize * @return */ PageInfo\u003cProduct\u003e findProductByTitle(String title,Integer pageNum, Integer pageSize); 3.编写业务层逻辑 @Override public PageInfo\u003cProduct\u003e findProductByTitle(String title, Integer pageNum, Integer pageSize) { //开启分页功能 PageHelper.startPage(pageNum,pageSize); //查询结果 List\u003cProduct\u003e res = productMapper.findProductByTitle(title); //返回结果 return new PageInfo\u003c\u003e(res); } ","date":"2022-10-20","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/:1:2","tags":["computerStore"],"title":"SpringBoot项目-商品搜索","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/"},{"categories":["SpringBoot","Mybatis"],"content":"9.1.3 后端-控制层 1.处理异常 2.设计请求 请求路径：/product/findWithTitle 请求参数：Integer pageNum，Integer pageSize，String title 请求类型：get 响应类型：JsonResult\u003cPageInfo\u003c Product» 3.处理请求，编写控制层方法 @RequestMapping(value = \"/{pageNum}/{pageSize}/{title}\",method = RequestMethod.GET) public JsonResult\u003cPageInfo\u003cProduct\u003e\u003e findWithTitle(@PathVariable(\"pageNum\") Integer pageNum, @PathVariable(\"pageSize\") Integer pageSize, @PathVariable(\"title\") String title){ PageInfo\u003cProduct\u003e res = productService.findProductByTitle(title, pageNum, pageSize); return new JsonResult\u003c\u003e(OK,res); } 4.前端页面 具体请参考github \u003cscript type=\"text/javascript\"\u003e //获取标题 var title = getOne(); title = title.substring(0,title.indexOf(\"\u0026\")); function getUrlParam(name) { var reg = new RegExp(\"(^|\u0026)\" + name + \"=([^\u0026]*)(\u0026|$)\"); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null; } var num = getUrlParam(\"pageNum\"); //为了查询设置的全局参数 var pageNum = 0; var pageSize = 0; var prePage = 0; var nextPage = 0; var navigatepageNums = []; //记录fid var fid = 0; //根据分页条的选择的页数进行查询 function PaginationListSelect(num,size,res) { //进行查询的关键字 let title = $(\"#search\").val() llocation.href = \"/web/search.html?title=\" + title + \"\u0026pageNum=\" + num + \"\u0026pageSize=\" + size; //填充分页条信息 addPaginationData(res); } //按照标题查询数据 function searchByTitle(pageNum,pageSize,title){ $.ajax({ url:\"/product/\" + pageNum + \"/\" + pageSize + \"/\" + title, dataType:\"json\", success:function (res) { if(res.state==200){ if(res.data.list.length!=0){ $(\"#resultTest\").html(\"\\\"\"+ title + \"\\\"\"); addData(res); }else{ $(\"#resultTest\").html(\"\\\"\"+ title + \"\\\"\"); $(\"#errmsg\").html(\"目前该商品并不在库\"); } } } }); } //填充数据 function addData(res){ //清空目标内容 $(\"#productList\").empty(); $(\"#PaginationList\").empty(); let productListStr = \"\"; //获取分页信息中商品的长度 let dataLength = res.data.list.length; //填充商品到信息页面 for (let i = 0; i \u003c dataLength; i++) { let product = res.data.list[i] productListStr = \"\u003cdiv class=\\\"col-md-3\\\"\u003e\" + \"\u003cdiv class=\\\"goods-panel\\\"\u003e\" + \"\u003cimg src=..\" + product.image + \"collect.png\" + \" class=\\\"img-responsive\\\" /\u003e\" + \"\u003cp\u003e￥\" + product.price + \".00\" + \"\u003c/p\u003e\" + \"\u003cdiv class=\\\"text-row-3\\\"\u003e\" + \"\u003ca href=product.html?pid=\" + product.id + \"\u003e\u003csmall\u003e\" + product.title + \"\u003c/small\u003e\u003c/a\u003e\u003c/div\u003e\" + \"\u003cspan style='padding-right: 10px'\u003e\" + \"\u003ca href='javascript:void(0)' onclick='addToCollect(#{id})' id='product#{num}' class='btn btn-default btn-xs add-fav'\u003e\u003cspan class='fa fa-heart-o'\u003e\u003c/span\u003e加入收藏\u003c/a\u003e\" + \"\u003c/span\u003e\" + \"\u003cspan style='padding-right: 10px'\u003e\" + \"\u003ca href='javascript:void(0)' onclick='addCollectToCart(#{id},#{price})' class=\\\"btn btn-default btn-xs add-cart\\\"\u003e\u003cspan class=\\\"fa fa-cart-arrow-down\\\"\u003e\u003c/span\u003e加入购物车\u003c/a\u003e\" + \"\u003c/span\u003e\u003c/div\u003e\u003c/div\u003e\" productListStr = productListStr.replaceAll(\"#{id}\",product.id); productListStr = productListStr.replaceAll(\"#{price}\",product.price); $(\"#productList\").append(productListStr) } //填充分页条信息 addPaginationData(res); } //填充分页条信息 function addPaginationData(res) { //重新填充分页条 //将数据返回的部分需要数据进行填充至全局参数 pageNum = res.data.pageNum //当前页 pageSize = res.data.pageSize //每页显示数 prePage = res.data.prePage //上一页 nextPage = res.data.nextPage //下一页 navigatepageNums = res.data.navigatepageNums //分页栏的数字 let firstPage = \"\u003ca id='first' href='#' onclick='PaginationListSelect(prePage,pageSize)' style='padding-right: 8px'\u003e上一页\u003c/a\u003e\" let lastPage = \"\u003ca id='end' href='javascript:void(0)' onclick='PaginationListSelect(nextPage,pageSize)' style='padding-right: 8px'\u003e下一页\u003c/a\u003e\" let PaginationListStr = \"\"; //判断是否是第一页 if (res.data.isFirstPage){ //为true表示当前是第一页 firstPage = \"\u003ca id='first' href='javascript:void(0)' \" + \"style='opacity: 0.2;padding-right: 8px;color: black'\u003e上一页\u003c/a\u003e\" PaginationListStr += firstPage; }else { //为false表示当前不是第一页 PaginationListStr += firstPage; } //填充分页的页码数 for (let i = 0; i \u003c navigatepageNums.length; i++) { //当前页的页码 let nowNum = navigatepageNums[i] if (nowNum === pageNum){ //相等表示i的次数和当前也相同，对页数显示做变化 PaginationListStr += \"\u003ca href='javascript:void(0)' \" + \"style='padding-right: 8px;color: black' disabled='disabled'\u003e\" + \"【\" + nowNum + \"","date":"2022-10-20","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/:1:3","tags":["computerStore"],"title":"SpringBoot项目-商品搜索","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/"},{"categories":["SpringBoot","Mybatis"],"content":"分页插件学习 1.github:https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md 2.CSDN:https://blog.csdn.net/m0_48736673/article/details/124805124 ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:0:0","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"1.使用步骤 ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:1:0","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"1.在pom.xml添加如下依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.github.pagehelper\u003c/groupId\u003e \u003cartifactId\u003epagehelper-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e最新版本\u003c/version\u003e \u003c!--\u003cversion\u003e1.2.3\u003cversion\u003e--\u003e \u003c/dependency\u003e ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:1:1","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"2.在springboot中添加部分配置 在application.properties中添加配置 #pagehelper配置 pagehelper.helper-dialect=mysql pagehelper.reasonable=true pagehelper.support-methods-arguments=true pagehelper.params=count=countSql ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:1:2","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"3.注册一个PageHelper类 @Bean public PageHelper pageHelper() { PageHelper pageHelper = new PageHelper(); Properties properties = new Properties(); properties.setProperty(\"offsetAsPageNum\", \"true\"); properties.setProperty(\"rowBoundsWithCount\", \"true\"); properties.setProperty(\"reasonable\", \"true\"); properties.setProperty(\"dialect\", \"mysql\"); pageHelper.setProperties(properties); return pageHelper; } ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:1:3","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"4.业务层或者需要使用的层设置开启 @Override public PageInfo\u003cFavorite\u003e findFavorite(Integer uid, Integer pageNum, Integer pageSize) { //开启分页功能 //pageNum是当前页,pageSize是每页显示的数据量 PageHelper.startPage(pageNum,pageSize); // List\u003cFavorite\u003e favorites = favoriteMapper.findFavoritesByUidAndStatus(uid, 1); // PageInfo\u003cFavorite\u003e pageInfo = new PageInfo\u003c\u003e(favorites); return pageInfo; } ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:1:4","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"5.控制层返回查询结果即可 @RequestMapping(value = \"/findFavorites\",method = RequestMethod.GET) public JsonResult\u003cPageInfo\u003cFavorite\u003e\u003e findFavorites(HttpSession session, Integer pageNum, Integer pageSize){ Integer uid = getUserIdFromSession(session); PageInfo\u003cFavorite\u003e favorites = favoriteService.findFavorite(uid, pageNum, pageSize); return new JsonResult\u003c\u003e(OK,favorites); } ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:1:5","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"部分参数的解释 1.dialect：默认情况下会使用 PageHelper 方式进行分页， 如果想要实现自己的分页逻辑,可以实现 Dialect(com.github.pagehelper.Dialect)接口 然后配置该属性为实现类的全限定名称。 2.reasonable:分页合理化参数，默认值为false。当该参数设置为true时， pageNum\u003c=0 时会查询第一页,pageNum\u003epages（超过总数时),会查询最后一页。 默认false时，直接根据参数进行查询。 ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:2:0","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"pageInfo参数大全 //当前页 private int pageNum; //每页的数量 private int pageSize; //当前页的数量 private int size; //由于startRow和endRow不常用，这里说个具体的用法 //可以在页面中\"显示startRow到endRow 共size条数据\" //当前页面第一个元素在数据库中的行号 private int startRow; //当前页面最后一个元素在数据库中的行号 private int endRow; //总记录数 private long total; //总页数 private int pages; //结果集(每页显示的数据) private List\u003cT\u003e list; //第一页 private int firstPage; //前一页 private int prePage; //是否为第一页 private boolean isFirstPage = false; //是否为最后一页 private boolean isLastPage = false; //是否有前一页 private boolean hasPreviousPage = false; //是否有下一页 private boolean hasNextPage = false; //导航页码数 private int navigatePages; //导航页第一页 private int navigateFirstPage; //导航页第二页 private int navigateLastPage; //所有导航页号 private int[] navigatepageNums; ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:2:1","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"8 收藏管理 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:0:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.1 创建实体类 CREATE TABLE t_favorites( fid INT PRIMARY KEY AUTO_INCREMENT COMMENT '收藏商品在数据表的id', uid INT COMMENT '归属的用户id', pid INT COMMENT '归属的商品id', image VARCHAR(255) COMMENT '商品图片保存地址', price BIGINT COMMENT '商品的价格', title VARCHAR(255) COMMENT '商品的标题', sell_point VARCHAR(255) COMMENT '商品的卖点', status INT COMMENT '商品的状态' ); ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:1:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.2 创建实体类 /** * @author zxl * @description 收藏实体类 * @date 2022/11/6 */ @Data @AllArgsConstructor @NoArgsConstructor public class Favorite extends BaseEntity { private Integer fid; private Integer uid; private Integer pid; private String image; private Long price; private String title; private String sellPoint; private Integer status; } ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:2:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.3 加入收藏 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:3:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.3.1 后端-持久层 1.编写sql //插入收藏 insert into t_favorite(除了fid)values(值) //判断是否存在该收藏 SELECT * FROM t_favorite WHERE uid = ? AND pid = ? 2.编写Mapper接口 /** * 根据pid和uid查询收藏商品是否在库 * @param uid * @param pid * @return */ Favorite findFavoriteByPidAndUid(Integer uid,Integer pid); /** * 插入收藏 * @param favorite 收藏数据 * @return */ Integer addFavorite(Favorite favorite); 3.编写映射文件 \u003cmapper namespace=\"com.zxl.store.mappers.FavoriteMapper\"\u003e \u003c!-- Integer addFavorite(Favorite favorite);--\u003e \u003cinsert id=\"addFavorite\" parameterType=\"com.zxl.store.entity.Favorite\" useGeneratedKeys=\"true\" keyProperty=\"fid\"\u003e INSERT INTO t_favorite( uid, pid, image, price, title, sell_point, status ) VALUES ( #{uid}, #{pid}, #{image}, #{price}, #{title}, #{sellPoint}, #{status} ) \u003c/insert\u003e \u003c!-- Favorite findFavoriteByPidAndUid(Integer uid,Integer pid);--\u003e \u003cselect id=\"findFavoriteByPidAndUid\" resultType=\"com.zxl.store.entity.Favorite\"\u003e SELECT * FROM t_favorite WHERE uid = #{uid} AND pid = #{pid} \u003c/select\u003e \u003c/mapper\u003e 4.单元测试 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:3:1","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.3.2 后端-业务层 1.编写异常 //收藏已经存在异常 public class FavoriteExistException extends ServiceException {} 2.编写业务层抽象方法 /** * @author zxl * @description 收藏业务层的接口 * @date 2022/11/6 */ public interface IFavoriteService { /** * 插入收藏 * @param uid * @param pid */ Integer addFavorite(Integer uid,Integer pid); } 3.编写实现逻辑 /** * @author zxl * @description 收藏接口的业务层实现类 * @date 2022/11/6 */ @Service public class IFavoriteServiceImpl implements IFavoriteService { @Autowired(required = false) private FavoriteMapper favoriteMapper; @Autowired private IProductService productService; @Override public Integer addFavorite(Integer uid, Integer pid) { //先判断是否已经存在收藏 Favorite res = favoriteMapper.findFavoriteByPidAndUid(uid, pid); //判断结果 if(res!=null){ throw new FavoriteExistException(\"该收藏品已经存在！\"); } //商品不存在的话，执行下一步 Favorite favorite = new Favorite(); //根据pid查询信息 Product p = productService.findProductById(pid); //加入数据 favorite.setUid(uid); favorite.setPid(pid); favorite.setImage(p.getImage()); favorite.setPrice(p.getPrice()); favorite.setTitle(p.getTitle()); favorite.setSellPoint(p.getSellPoint()); favorite.setStatus(p.getStatus()); //执行插入 Integer row = favoriteMapper.addFavorite(favorite); //判断插入结果 if(row!=1)throw new InsertException(\"插入收藏时出现未知错误\"); System.out.println(favorite.getFid()); return favorite.getFid(); } } 4.单元测试 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:3:2","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.3.3 后端-控制层 1.处理异常 将异常交给全局处理 2.设计请求 请求路径：/favorite/addFavorite 请求类型：HttpSession session,Integer pid 请求方式：post 响应类型：JsonResult\u003c Integer\u003e 3.处理请求编写控制类 /** * @author zxl * @description 添加收藏的控制类 * @date 2022/11/6 */ @RestController @RequestMapping(\"/favorite\") public class FavoriteController extends BaseController { @Autowired private IFavoriteService favoriteService; @RequestMapping(value = \"/addFavorite\",method = RequestMethod.POST) public JsonResult\u003cInteger\u003e addFavorite(Integer pid, HttpSession session){ //uid Integer uid = getUserIdFromSession(session); //执行插入 Integer fid = favoriteService.addFavorite(uid, pid); return new JsonResult\u003c\u003e(OK,fid); } } 4.前端页面 //绑定收藏事件 $(\"#btn-add-to-collect\").click(function () { if (confirm(\"确定要将此商品加入收藏吗？\")) { $.ajax({ url: \"/favorite/addFavorite\", type: \"post\", data: {\"pid\": pid}, dataType: \"json\", success: function (res) { if (res.state == 200) { alert(\"收藏成功！\"); } else { alert(res.message); } }, error: function (err) { alert(\"服务器出现错误，加入购物车失败！\") } }) } }); ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:3:3","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.4 显示收藏 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:4:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.4.1 后端-持久层 1.编写sql //根据用户uid和收藏商品的状态去查找 SELECT * FROM t_favorite WHERE uid = #{uid} AND status=#{status} 2.编写Mapper接口抽象方法 /** * 按照uid和status查找用户的收藏列表 * @param uid 用户的id * @param status 商品状态 * @return 返回结果集合 */ List\u003cFavorite\u003e findFavoritesByUidAndStatus(Integer uid,Integer status); 3.编写映射文件 \u003c!-- List\u003cFavorite\u003e findFavoritesByUidAndStatus(Integer uid,Integer status);--\u003e \u003cselect id=\"findFavoritesByUidAndStatus\"\u003e SELECT * FROM t_favortie WHERE uid = #{uid} AND status = 1; \u003c/select\u003e 4.单元测试 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:4:1","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.4.2 后端-业务层 1.编写异常 2.编写业务层抽象方法 /** * 查找指定条件的收藏 * @param uid 用户uid * @param pageNum 当前页码 * @param pageSize 每页数据多少 * @return */ PageInfo\u003cFavorite\u003e findFavorite(Integer uid, Integer pageNum, Integer pageSize); 3.编写实现逻辑 @Override public PageInfo\u003cFavorite\u003e findFavorite(Integer uid, Integer pageNum, Integer pageSize) { //开启分页功能 //pageNum是当前页,pageSize是每页显示的数据量 PageHelper.startPage(pageNum,pageSize); // List\u003cFavorite\u003e favorites = favoriteMapper.findFavoritesByUidAndStatus(uid, 1); // PageInfo\u003cFavorite\u003e pageInfo = new PageInfo\u003c\u003e(favorites); return pageInfo; } 4.单元测试 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:4:2","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.4.3 后端-控制层 1.处理异常 2.设计请求 请求路径：/favorite/findFavorites 请求类型：HttpSession session,Integer pageNum,Integer pageSize 请求方式：get 响应类型：JsonResult 3.处理请求 编写控制方法 //查询 @RequestMapping(value = \"/findFavorites\",method = RequestMethod.GET) public JsonResult\u003cPageInfo\u003cFavorite\u003e\u003e findFavorites(HttpSession session, Integer pageNum, Integer pageSize){ Integer uid = getUserIdFromSession(session); PageInfo\u003cFavorite\u003e favorites = favoriteService.findFavorite(uid, pageNum, pageSize); return new JsonResult\u003c\u003e(OK,favorites); } 4.前端页面 \u003cscript type=\"text/javascript\"\u003e //为了查询设置的全局参数 var pageNum = 0; var pageSize = 0; var prePage = 0; var nextPage = 0; var navigatepageNums = []; //根据分页条的选择的页数进行查询 function PaginationListSelect(num,size) { showCollectProduct(num,size) } function addDataToList(res) { //在填充数据之前必须先将这两个div标签内的所有元素情况，不然会出现叠加情况 $(\"#collectList\").empty(); $(\"#PaginationList\").empty(); let collectListStr = \"\"; //获取分页数据中的数据数量 let dataLength = res.data.list.length; //填充商品到页面 for(let i = 0;i\u003cdataLength;i++){ let favorite = res.data.list[i]; collectListStr = \"\u003cdiv class=\\\"col-md-3\\\"\u003e\" + \"\u003cdiv class=\\\"goods-panel\\\"\u003e\" + \"\u003cimg src=..\" + favorite.image + \"collect.png\" + \" class=\\\"img-responsive\\\" /\u003e\" + \"\u003cp\u003e￥\" + favorite.price + \".00\" + \"\u003c/p\u003e\" + \"\u003cdiv class=\\\"text-row-3\\\"\u003e\" + \"\u003ca href=product.html?pid=\" + favorite.pid + \"\u003e\u003csmall\u003e\" + favorite.title + \"\u003c/small\u003e\u003c/a\u003e\u003c/div\u003e\" + \"\u003cspan style='padding-right: 10px'\u003e\" + \"\u003ca href='javascript:void(0)' onclick='CancelCollect(#{fid})' class='btn btn-default btn-xs add-fav'\u003e\u003cspan class='fa fa-heart'\u003e\u003c/span\u003e取消收藏\u003c/a\u003e\" + \"\u003c/span\u003e\" + \"\u003cspan style='padding-right: 10px'\u003e\" + \"\u003ca href='javascript:void(0)' onclick='addCollectToCart(#{pid},#{price})' class=\\\"btn btn-default btn-xs add-cart\\\"\u003e\u003cspan class=\\\"fa fa-cart-arrow-down\\\"\u003e\u003c/span\u003e加入购物车\u003c/a\u003e\" + \"\u003c/span\u003e\u003c/div\u003e\u003c/div\u003e\"; collectListStr = collectListStr.replaceAll(\"#{fid}\",favorite.fid); collectListStr = collectListStr.replaceAll(\"#{pid}\",favorite.pid); collectListStr = collectListStr.replaceAll(\"#{price}\",favorite.price); $(\"#collectList\").append(collectListStr); } //重新填充分页条 // 将数据返回的部分需要数据进行填充至全局参数 pageNum = res.data.pageNum; //当前页 pageSize = res.data.pageSize; //每页显示数 prePage = res.data.prePage; //上一页 nextPage = res.data.nextPage; //下一页 navigatepageNums = res.data.navigatepageNums;//分页栏的数字 let firstPage = \"\u003ca id='first' href='#' onclick='PaginationListSelect(prePage,pageSize)' style='padding-right: 8px'\u003e上一页\u003c/a\u003e\"; let lastPage = \"\u003ca id='end' href='javascript:void(0)' onclick='PaginationListSelect(nextPage,pageSize)' style='padding-right: 8px'\u003e下一页\u003c/a\u003e\"; let PaginationListStr = \"\"; //判断是否是第一页 if (res.data.isFirstPage){ //为true表示当前是第一页 firstPage = \"\u003ca id='first' href='javascript:void(0)' \" + \"style='opacity: 0.2;padding-right: 8px;color: black'\u003e上一页\u003c/a\u003e\"; PaginationListStr += firstPage; }else { //为false表示当前不是第一页 PaginationListStr += firstPage; } //填充分页的页码数 for (let i = 0; i \u003c navigatepageNums.length; i++) { //当前页的页码 let nowNum = navigatepageNums[i]; if (nowNum === pageNum){ //相等表示i的次数和当前也相同，对页数显示做变化 PaginationListStr += \"\u003ca href='javascript:void(0)' \" + \"style='padding-right: 8px;color: black' disabled='disabled'\u003e\" + \"【\" + nowNum + \"】\" +\"\u003c/a\u003e\" }else { PaginationListStr += \"\u003ca href='javascript:void(0)' onclick='PaginationListSelect(#{nowNum},pageSize)' \" + \"style='padding-right: 8px'\u003e\" + nowNum +\"\u003c/a\u003e\" } PaginationListStr = PaginationListStr.replaceAll(\"#{nowNum}\",nowNum) } //判断是否是末页 if (!res.data.isLastPage){ //取反为false表示当前是末页 PaginationListStr += lastPage; }else { //为true表示当前是末页 lastPage = \"\u003ca id='end' href='javascript:void(0)' style='opacity: 0.2;padding-right: 8px;color: black'\u003e下一页\u003c/a\u003e\" PaginationListStr += lastPage; } //将拼接的str串插入指定id处 $(\"#PaginationList\").append(PaginationListStr); } function showCollectProduct(num,size){ $.ajax({ url: \"/favorite/findFavorites\", type: \"get\", data: \"pageNum=\" + num + \"\u0026pageSize=\" + size, dataType: \"json\", success: function (res) { if(res.data.list.length !== 0){ //代表有数据 //从showPageDataIntoHtml.js中导入的方法 addDataToList(res) }else { //代表没数据 alert(\"暂无收藏商","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:4:3","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.5 删除收藏 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:5:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.5.1 后端-持久层 1.编写sql //取消收藏 DELETE FROM t_favorite WHERE fid = #{fid} 2.编写Mapper抽象方法 /** * 删除收藏 * @param fid 收藏id * @return */ Integer deleteCollect(Integer fid); 3.编写Mapper映射 \u003c!-- Integer deleteCollect(Integer fid);--\u003e \u003cdelete id=\"deleteCollect\"\u003e DELETE FROM t_favorite WHERE fid = #{fid} \u003c/delete\u003e 4.单元测试 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:5:1","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.5.2 后端-业务层 1.编写异常 删除异常已经定义 2.编写业务层抽象方法 /** * 删除收藏 * @param fid */ void deleteCollect(Integer fid); 3.编写实现逻辑 @Override public void deleteCollect(Integer fid) { Integer row = favoriteMapper.deleteCollect(fid); if(row!=1)throw new DeleteException(\"删除收藏是出现错误\"); } 4.单元测试 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:5:2","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.5.3 后端-控制层 1.处理异常 2.设计请求 请求路径：/favorite/cancelFavorite 请求类型：Integer fid 请求方式：post 响应类型：JsonResult 3.处理请求 编写控制方法 //删除 @RequestMapping(value = \"/cancelFavorite\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e cancelFavorite (Integer fid){ favoriteService.deleteCollect(fid); return new JsonResult\u003c\u003e(OK); } 4.前端页面 //取消收藏 function CancelCollect(fid) { if(confirm(\"确定取消收藏吗？\")){ $.ajax({ url:\"/favorite/cancelFavorite\", type: \"POST\", data:{\"fid\":fid}, dataType: \"json\", success:function (res) { if(res.state == 200){ alert(\"取消收藏成功\"); location.reload(); }else{ alert(\"取消收藏失败\"); } } }); } } ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:5:3","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.6 加入购物车 已经被实现，只需要调用即可 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:6:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.6.1 前端页面 //加入购物车功能 function addCollectToCart(pid,price){ if (confirm(\"确定要将此商品加入购物车吗？\")){ $.ajax({ url: \"/cart/addCart\", type: \"post\", data: {pid:pid,price:price,num:1}, dataType: \"json\", success: function (res) { alert(\"已成功加入购物车，在购物车等您结算哟！\") }, error : function (err) { alert(\"服务器出现错误，加入购物车失败！\") } }) } } ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:6:1","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"订单管理 ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:0:0","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"7.1 创建数据表 CREATE TABLE t_order ( oid INT AUTO_INCREMENT COMMENT '订单id', uid INT NOT NULL COMMENT '用户id', aid INT NOT NULL COMMENT '收货地址id', recv_name VARCHAR(20) NOT NULL COMMENT '收货人姓名', recv_phone VARCHAR(20) COMMENT '收货人电话', recv_province VARCHAR(15) COMMENT '收货人所在省', recv_city VARCHAR(15) COMMENT '收货人所在市', recv_area VARCHAR(15) COMMENT '收货人所在区', recv_address VARCHAR(50) COMMENT '收货详细地址', total_price BIGINT COMMENT '总价', status INT COMMENT '状态：0-未支付，1-已支付，2-已取消，3-已关闭，4-已完成', order_time DATETIME COMMENT '下单时间', pay_time DATETIME COMMENT '支付时间', created_user VARCHAR(20) COMMENT '创建人', created_time DATETIME COMMENT '创建时间', modified_user VARCHAR(20) COMMENT '修改人', modified_time DATETIME COMMENT '修改时间', PRIMARY KEY (oid) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE t_order_item ( id INT AUTO_INCREMENT COMMENT '订单中的商品记录的id', oid INT NOT NULL COMMENT '所归属的订单的id', pid INT NOT NULL COMMENT '商品的id', title VARCHAR(100) NOT NULL COMMENT '商品标题', image VARCHAR(500) COMMENT '商品图片', price BIGINT COMMENT '商品价格', num INT COMMENT '购买数量', created_user VARCHAR(20) COMMENT '创建人', created_time DATETIME COMMENT '创建时间', modified_user VARCHAR(20) COMMENT '修改人', modified_time DATETIME COMMENT '修改时间', PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:1:0","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"7.2 创建实体类 /** * @author zxl * @description t_order表对应的实体类 * @date 2022/11/6 */ @Data @AllArgsConstructor @NoArgsConstructor public class Order extends BaseEntity{ private Integer oid; private Integer uid; private Integer aid; private String recvName; private String recvPhone; private String recvProvince; private String recvCity; private String recvArea; private String recvAddress; private Long totalPrice; private Integer status; private Date orderTime; private Date payTime; } /** * @author zxl * @description t_order_item表对应的实体类 * @date 2022/11/6 */ public class OrderItem extends BaseEntity { private Integer id; private Integer oid; private Integer pid; private String title; private String image; private Long price; private Integer num; } ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:2:0","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"7.3 创建订单 ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:3:0","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"7.3.1 后端-持久层 1.编写sql //在t_order表中插入数据 INSERT INTO t_order(oid除外)VALUES(字段的值) //在t_order_item中插入数据 INSERT INTO t_order_item (id除外)VALUES(字段的值) 2.编写Mapper接口的抽象方法 /** * @author zxl * @description 订单类的Mapper接口 * @date 2022/11/6 */ public interface OrderMapper { /** * 插入order * @param order 订单数据 * @return */ Integer insertOrder(Order order); /** * 插入order_item数据 * @param orderItem * @return */ Integer insertOrderItem(OrderItem orderItem); } 3.编写Mapper接口的映射文件 \u003cmapper namespace=\"com.zxl.store.mappers.OrderMapper\"\u003e \u003c!-- Integer insertOrder(Order order);--\u003e \u003cinsert id=\"insertOrder\" useGeneratedKeys=\"true\" keyProperty=\"oid\"\u003e insert into t_order(uid,aid,recv_name,recv_phone,recv_province, recv_city,recv_area,recv_address, total_price,status,order_time,pay_time, created_user,created_time,modified_user,modified_time) values( #{uid},#{aid},#{recvName},#{recvPhone},#{recvProvince},#{recvCity}, #{recvArea},#{recvAddress},#{totalPrice},#{status},#{orderTime}, #{payTime},#{createdUser},#{createdTime},#{modifiedUser},#{modifiedTime} ) \u003c/insert\u003e \u003c!-- Integer insertOrderItem(OrderItem orderItem);--\u003e \u003cinsert id=\"insertOrderItem\"\u003e insert into t_order_item(oid,pid,title,image,price,num, created_user,created_time,modified_user,modified_time) values(#{oid},#{pid},#{title},#{image},#{price}, #{num},#{createdUser},#{createdTime},#{modifiedUser},#{modifiedTime} ) \u003c/insert\u003e \u003c/mapper\u003e 单元测试 ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:3:1","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"7.3.2 后端业务层 1.编写异常 插入失败，已经被定义 2.编写业务层抽象方法 /** * 插入订单数据 * @param aid 收货地址id * @param uid 用户id * @param totalPrice 商品总价 * @param username 操作人 */ Order insertOrder(Integer aid,Integer uid,Long totalPrice,String username); /** * 添加orderItem * @param oid * @param cid * @param num * @param username */ void insertOrderItem(Integer oid,Integer cid,Integer num,String username); 3.实现逻辑 /** * @author zxl * @description 订单的业务层接口实现类 * @date 2022/11/6 */ @Service public class IOrderServiceImpl implements IOrderService { @Autowired(required = false) private OrderMapper orderMapper; @Autowired private IAddressService addressService; @Autowired private ICartService cartService; @Autowired private IProductService productService @Override public Order insertOrder(Integer aid, Integer uid, Long totalPrice, String username) { //根据控制层传入的aid进行查询 Address address = addressService.findAddressByAid(aid); //创建一个用于向持久层传输的Order实体类对象 Order order = new Order(); //补全order对象的空白字段 order.setUid(uid); order.setAid(aid); order.setRecvName(address.getName()); order.setRecvPhone(address.getPhone()); order.setRecvProvince(address.getProvinceName()); order.setRecvCity(address.getCityName()); order.setRecvArea(address.getAreaName()); order.setRecvAddress(address.getAddress()); order.setTotalPrice(totalPrice); order.setStatus(0); //表示未支付 Date createdTime = new Date(); order.setOrderTime(createdTime); order.setPayTime(null); order.setCreatedUser(username); order.setModifiedUser(username); order.setCreatedTime(createdTime); order.setModifiedTime(createdTime); //调用持久层进行插入 int result = orderMapper.insertOrder(order); if (result == 0){ throw new InsertException(\"服务器出现错误，创建订单失败\"); } //根据oid查询指定的订单，并返回给控制层 return orderMapper.findOrderByOid(order.getOid()); } @Override public void insertOrderItem(Integer oid, Integer cid, Integer num, String username) { //根据cid查询订单获取pid Cart cart = cartService.findCartByCid(cid); //取出pid的值 Integer pid = cart.getPid(); //根据pid查询商品信息 Product product = productService.findProductById(pid); //创建一个用于向持久层传输的OrderItem实体类对象 OrderItem orderItem = new OrderItem(); //补全orderItem对象的空白字段 orderItem.setOid(oid); orderItem.setPid(pid); orderItem.setTitle(product.getTitle()); orderItem.setImage(product.getImage()); orderItem.setPrice(product.getPrice()); orderItem.setNum(num); Date createdTime = new Date(); orderItem.setCreatedUser(username); orderItem.setCreatedTime(createdTime); orderItem.setModifiedUser(username); orderItem.setModifiedTime(createdTime); //调用持久层进行插入 int result = orderMapper.insertOrderItem(orderItem); if (result == 0){ throw new InsertException(\"服务器出现错误，创建订单失败\"); } } } 4.单元测试 ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:3:2","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"7.3.3 后端控制层 1.处理异常 2.设计请求 请求路径： /order/createOrder 请求参数：Integer aid,Long totalPrice,HttpSession session ​ ②Integer oid,Integer cid,Integer pid,Integer num,HttpSession session 请求类型：post 响应类型：JsonResult\u003c Order\u003e 3.设计控制类 /** * @author zxl * @description * @date 2022/11/6 */ @RestController @RequestMapping(\"/Order\") public class OrderController extends BaseController { @Autowired private IOrderService orderService; /** * Description : 处理用户创建order订单的请求 * @date 2022/7/18 * @param aid 用户选中的地址aid * @param totalPrice 商品的总金额 * @param session 项目启动自动生成的session对象 * @return top.year21.computerstore.utils.JsonResult\u003cjava.lang.Void\u003e **/ @PostMapping(\"/createOrder\") public JsonResult\u003cOrder\u003e createOrder(Integer aid, Long totalPrice, HttpSession session){ //从session中取出用户名和uid Integer uid = getUserIdFromSession(session); String username = getUsernameFromSession(session); //调用业务层方法执行插入操作 Order order = orderService.insertOrder(aid,uid, totalPrice,username); return new JsonResult\u003c\u003e(OK,order); } } 4.前端页面 ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:3:3","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6 购物车 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:1:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.1 创建数据表 CREATE TABLE t_cart ( cid INT AUTO_INCREMENT COMMENT '购物车数据id', uid INT NOT NULL COMMENT '用户id', pid INT NOT NULL COMMENT '商品id', price BIGINT COMMENT '加入时商品单价', num INT COMMENT '商品数量', created_user VARCHAR(20) COMMENT '创建人', created_time DATETIME COMMENT '创建时间', modified_user VARCHAR(20) COMMENT '修改人', modified_time DATETIME COMMENT '修改时间', PRIMARY KEY (cid) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:2:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.2 创建实体类 /** * @author zxl * @description 购物车商品信息实体类 * @date 2022/11/4 */ @Data @AllArgsConstructor @NoArgsConstructor public class Cart extends BaseEntity{ // cid INT AUTO_INCREMENT COMMENT '购物车数据id', // uid INT NOT NULL COMMENT '用户id', // pid INT NOT NULL COMMENT '商品id', // price BIGINT COMMENT '加入时商品单价', // num INT COMMENT '商品数量', // created_user VARCHAR(20) COMMENT '创建人', // created_time DATETIME COMMENT '创建时间', // modified_user VARCHAR(20) COMMENT '修改人', // modified_time DATETIME COMMENT '修改时间', private Integer cid; private Integer uid; private Integer pid; private Long price; private Integer num; } ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:3:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.3 加入购物车 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:4:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.3.1 后端-持久层 1.编写sql语句 //1.向购物车插入数据 INSERT INTO t_cart (aid除外) values （值列表） //2.当当前购物车内已经存在当前商品，则直接更换当前商品数量 UPDATE t_cart SET num = ? WHERE cid = ? //3.插入和更新的操作是取决于购物车是否有该商品 //所有需要查询商品是否存在 SELECT * FROM t_cart WHERE uid = ? AND cid = ? 2.编写Mapper接口和抽象方法 /** * @author zxl * @description 购物车持久层的Mapper接口 * @date 2022/11/4 */ public interface CartMapper { /** * 插入Cart数据 * @param cart 购物车数据 * @return */ Integer addCart(Cart cart); /** * 更新Cart内容 * @param cid 购物车id * @param num 更新物品数量 * @param modifiedUser 更新人 * @param modifiedTime 更新时间 * @return */ Integer updateCartInfo(Integer cid, Integer num, String modifiedUser, Date modifiedTime); /** * 按照用户的uid和商品的pid查找某条购物车数据 * @param uid 用户的uid * @param pid 商品的id * @return 返回购物车数据 */ Cart findCartByUidAndPid(Integer uid,Integer pid); } 3.编写Mapper接口的映射文件 \u003cmapper namespace=\"com.zxl.store.mappers.CartMapper\"\u003e \u003c!-- Integer addCart(Cart cart);--\u003e \u003cinsert id=\"addCart\" useGeneratedKeys=\"true\" keyProperty=\"cid\"\u003e INSERT INTO t_cart(uid,pid,price,num,created_user,created_time,modified_user,modified_time) VALUES (#{uid},#{pid},#{price},#{num},#{createdUser},#{createdTime},#{modifiedUser},#{modifiedTime}) \u003c/insert\u003e \u003c!-- Integer updateCartInfo(Integer cid, Integer num , String modifiedUser, Date modifiedTime);--\u003e \u003cupdate id=\"updateCartInfo\"\u003e UPDATE t_cart SET num = #{num},modified_user = #{modifiedUser},modified_time = #{modifiedTime} WHERE cid = #{cid} \u003c/update\u003e \u003c!-- Cart findCartByUidAndPid(Integer uid,Integer pid);--\u003e \u003cselect id=\"findCartByUidAndPid\" resultType=\"com.zxl.store.entity.Cart\"\u003e SELECT * FROM t_cart WHERE uid = #{uid} AND pid = #{pid} \u003c/select\u003e \u003c/mapper\u003e 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:4:1","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.3.2 后端-业务层 1.规划异常 2.编写业务层接口和抽象方法 /** * 将商品加入购物车 * @param uid 用户id * @param pid 商品id * @param num 商品数量 * @param username 用户名 */ void addCart(Integer uid,Integer pid,Integer num,Integer username); 3.编写抽象方法的具体实现逻辑 /** * @author zxl * @description 购物车业务层接口的实现类 * @date 2022/11/4 */ @Service public class ICartServiceImpl implements ICartService { @Autowired(required = false) private CartMapper cartMapper; @Override public void addCart(Cart cart, String createdUser, Date createdTime, String modifiedUser, Date modifiedTime) { //查询当前商品是否在购物车存在 Integer pid = cart.getPid(); Integer uid = cart.getUid(); Cart destCart = cartMapper.findCartByUidAndPid(uid, pid); //判断查询结果 if(destCart==null){//如果不存在 //补全四个字段 cart.setCreatedUser(createdUser); cart.setModifiedUser(modifiedUser); cart.setCreatedTime(createdTime); cart.setModifiedTime(modifiedTime); //执行插入操作 Integer integer = cartMapper.addCart(cart); //判断插入结果 if(integer!=1){ throw new InsertException(\"插入购物车数据时遭遇未知异常\"); } }else{//表示该商品存在数据 //取出查询的数据数量 Integer destNum = destCart.getNum(); //取出新添加产品的数量 Integer cartNum = cart.getNum(); //计算结果 Integer num = destNum + cartNum; //设置需要更新的字段 cart.setNum(num); cart.setModifiedUser(modifiedUser); cart.setModifiedTime(modifiedTime); //执行更新操作 Integer row = cartMapper.updateCartInfo(cart); if(row != 1 ){ throw new UpdateException(\"更新购物车数据是遭遇未知异常\"); } } } } 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:4:2","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.3.3 后端控制层 1.处理异常 插入异常和更新异常均已被处理 2.设计请求 请求地址:/cart/add_cart 请求参数:Integer pid,Integer price,Integer num, HttpSession session 请求类型:post 响应类型:JsonResult 3.处理请求 编写控制方法 /** * @author zxl * @description 处理购物车请求的控制类 * @date 2022/11/5 */ @RestController @RequestMapping(\"/cart\") public class CartController extends BaseController { @Autowired private ICartService cartService; @RequestMapping(value = \"/add_cart\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e addCart(Integer pid,Integer price,Integer num, HttpSession session){ //从session获取uid和username String username = getUsernameFromSession(session); Integer uid = getUserIdFromSession(session); Date currentTime = new Date(); //设置参数 Cart cart = new Cart(); cart.setUid(uid); cart.setPid(pid); cart.setPrice(Long.valueOf(price)); cart.setNum(num); System.out.println(cart); //执行插入操作 cartService.addCart(cart,username,currentTime,username,currentTime); return new JsonResult\u003c\u003e(OK); } } 4. 前端页面 //将物品加入购物车 function addProductToCart(){ $(\"#btn-add-cart\").click(function () { if(confirm(\"确定要将此商品加入购物车吗？\")){ let price = $(\"#product-price\").text(); let num = $(\"#num\").val(); alert(price + \":\"+num); $.ajax({ url:\"/cart/add_cart\", type:\"post\", data:{ \"pid\":pid, \"price\":price, \"num\":num }, dataType: \"json\", success:function (json) { if(json.state==200){ alert(\"已经成功加入购物车\"); }else{ alert(\"加入购物车失败\"); } }, }); } }); } ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:4:3","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.4 展示购物车 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:5:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.4.1 后端-持久层 1.创建多表查询的实体类 /** * @author zxl * @description Cart表和Product表联合查询的结果映射实体类 * @date 2022/11/5 */ @Data @AllArgsConstructor @NoArgsConstructor public class CartVo { private Integer cid; private Integer pid; private Integer uid; private Long price; private Integer num; private String title; private String image; private String realPrice; } 2. 编写sql语句 由于购物车展示需要显示: 商品名称(product) 单价(product,cart) 数量(cart) 金额(product) SELECT c.cid, c.uid, c.pid, c.price, c.num, p.title, p.image, p.price AS realPrice FROM t_cart c LEFT JOIN t_product p ON c.pid=p.id WHERE c.uid = #{uid} ORDER BY c.created_time DESC 3.编写对应的Mapper接口的抽象方法 /** * 按照用户uid 查询所有的购物车记录 * @param uid 用户uid * @return 返回购物车集合 */ List\u003cCartVo\u003e findAllCartByUid(Integer uid); 4.编写Mapper接口对于的映射文件 \u003c!-- List\u003cCartVo\u003e findAllCartByUid(Integer uid);--\u003e \u003cselect id=\"findAllCartByUid\" resultType=\"com.zxl.store.vo.CartVo\"\u003e SELECT c.cid, c.uid, c.pid, c.price, c.num, p.title, p.image, p.price AS realPrice FROM t_cart c LEFT JOIN t_product p ON c.pid=p.id WHERE c.uid = #{uid} ORDER BY c.created_time DESC \u003c/select\u003e 5.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:5:1","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.4.2 后端-业务层 1.异常处理 2.编写业务层抽象方法 /** * 根据用户uid查询购物车数据 * @param uid 用户uid * @return */ List\u003cCartVo\u003e findAllCartByUid(Integer uid); 3.编写业务层方法的实现 @Override public List\u003cCartVo\u003e findAllCartByUid(Integer uid) { return cartMapper.findAllCartByUid(uid); } 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:5:2","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.4.3 后端-控制层 1.异常处理 2.设计请求 请求地址：/cart/show_carts 请求参数：HttpSession session 请求类型：get 响应类型：JsonResult\u003c List\u003c Cart» 3.处理请求，编写控制方法 @RequestMapping(value = \"/show_carts\",method = RequestMethod.GET) public JsonResult\u003cList\u003cCartVo\u003e\u003e showCarts(HttpSession session){ //获取uid Integer uid = getUserIdFromSession(session); //获取数据 List\u003cCartVo\u003e data = cartService.findAllCartByUid(uid); //返回数据 return new JsonResult\u003c\u003e(OK,data); } 4.前端页面 \u003cscript type=\"text/javascript\"\u003e function showCarts(){ $.ajax({ url: \"/cart/show_carts\", type: \"get\", dataType: \"json\", success: function (res) { if (res.data.length !== 0){ //先清空列表 $(\"#cart-list\").empty(); for (let i = 0; i \u003c res.data.length; i++) { let cart = res.data[i]; let idNum = i; let image = \"..\" + cart.image + \"collect.png\"; let totalPrice = cart.price * cart.num let str = \"\u003ctr\u003e\" +\"\u003ctd\u003e\u003cinput onclick='checkOne()' id=cid\" + idNum + \" name='cids' value=\" + cart.cid + \" type='checkbox' class='ckitem' /\u003e\u003c/td\u003e\" + \"\u003ctd\u003e\u003cimg src=\" + image + \" class='img-responsive' /\u003e\u003c/td\u003e\" + \"\u003ctd\u003e\" + cart.title + \"\u003c/td\u003e\" + \"\u003ctd\u003e¥\u003cspan id=\"+ \"goodsPrice\" + idNum +\"\u003e\"+ cart.price + \"\u003c/span\u003e\u003c/td\u003e\" + \"\u003ctd\u003e\" + \"\u003cinput id=\" + \"countRec\" + idNum + \" type='button' value='-' class='num-btn' onclick='ajaxProductCountRec(#{idNum})' /\u003e\" + \"\u003cinput id=\" + \"goodsCount\"+ idNum + \" type='text' size='2' readonly='readonly' class='num-text' value=\" + cart.num + \"\u003e\" + \"\u003cinput id=\" + \"countAdd\" + idNum + \" class='num-btn' type='button' value='+' onclick='ajaxProductCountAdd(#{idNum})' /\u003e\" + \"\u003c/td\u003e\" + \"\u003ctd\u003e\u003cspan id=\" + \"goodsCast\" + idNum + \"\u003e￥\" + totalPrice + \"\u003c/span\u003e\u003c/td\u003e\" + \"\u003ctd\u003e\" + \"\u003cinput type='button' onclick='delCartItem(#{deletedId})' class='cart-del btn btn-default btn-xs' value='删除' /\u003e\" + \"\u003c/td\u003e\" + \"\u003c/tr\u003e\" //替换数字 str = str.replaceAll(\"#{idNum}\",idNum) str = str.replaceAll(\"#{deletedId}\",cart.cid) //在表格中插入数据 $(\"#cart-list\").append(str) // 计算商品总数量和总价格 totalNum += 1; countPrice = countPrice + totalPrice; } }else{ str = \"\u003ctr\u003e\u003ctd colspan='12' style='font-weight: bold;color: red;padding: 20px;font-size: medium'\u003e\" + \"购物车暂无商品，请先去添加商品\u003c/td\u003e\u003c/tr\u003e\" $(\"#cart-list\").empty().append(str) } }, error : function (err) { alert(\"服务器出现错误，查询失败！\") } ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:5:3","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.5 删除商品 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:6:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.5.1 后端-持久层 1.编写sql DELETE FROM t_cart WHERE cid = #{cid} 2.编写Mapper接口的抽象方法 /** * 按照购物车id 删除购物车内容物 * @param cid 购物车id * @return 返回影响行数 */ Integer deleteCartByCid(Integer cid); 3.编写Mapper接口的映射文件 \u003c!-- Integer deleteCartByCid(Integer cid);--\u003e \u003cdelete id=\"deleteCartByCid\"\u003e DELETE FROM t_cart WHERE cid = #{cid} \u003c/delete\u003e 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:6:1","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.5.2 后端-业务层 1.处理异常 删除异常已经被定义 2.定义业务层抽象方法 /** * 按照cid删除购物车数据 * @param cid cid */ void deleteCartByCid(Integer cid); 3.定义抽象方法实现逻辑 @Override public void deleteCartByCid(Integer cid) { //删除 Integer row = cartMapper.deleteCartByCid(cid); //判断删除结果 if(row!=1){ throw new DeleteException(\"购物车数据删除异常!\"); } } 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:6:2","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.5.3 后端-控制层 1.处理异常 2.\u0008请求设计 请求地址：/cart/delete_cart 请求参数：Integer cid 请求类型：post 响应类型：JsonResult 3,处理请求，编写控制层方法 @RequestMapping(value = \"/delete_cart\",method = RequestMethod.GET) public JsonResult\u003cVoid\u003e showCarts(Integer cid){ cartService.deleteCartByCid(cid); return new JsonResult\u003c\u003e(OK); } 4.前端页面 //给每个删除按钮绑定点击事件 function delCartItem(cid){ if (confirm(\"确定要删除这条商品吗？\")){ $.ajax({ url: \"/cart/delete_cart\", type: \"post\", data: {\"cid\":cid}, dataType: \"json\", success:function (res) { alert(\"删除成功\") location.reload(); }, error:function (error) { alert(\"删除失败\") } }) } } ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:6:3","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.6 购物车数目增减 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:7:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.6.1 数目增减-持久层 1.编写sql //根据cid更新用户商品数量 UPDATE t_cart SET num = #{num},modified_user = #{modifiedUser}, #modified_time = #{modifiedTime} WHERE cid = #{cid} //根据cid查询用户cart信息 SELECT * FROM t_cart WHERE cid = #{cid}; 2.编写Mapper接口抽象方法 /** * 按照cid查询Cart * @param cid * @return */ Cart findCartByCid(Integer cid); /** * 按照cid增减购物车商品的数量 * @param num 数量 * @param cid 购物车id * @param modifiedUser 操作人 * @param modifiedTime 操作时间 * @return */ Integer updateCartNumByCid(Integer num,Integer cid,String modifiedUser,Date modifiedTime); 3.编写Mapper接口映射文件 \u003c!-- Cart findCartByCid(Integer cid);--\u003e \u003cselect id=\"findCartByCid\" resultType=\"com.zxl.store.entity.Cart\"\u003e SELECT * FROM t_cart WHERE cid = #{cid} \u003c/select\u003e \u003c!-- Integer updateCartNumByCid(Integer num,Integer cid,String username,Date time);--\u003e \u003cupdate id=\"updateCartNumByCid\"\u003e UPDATE t_cart SET num = #{num},modified_user = #{modifiedUser},modified_time = #{modifiedTime} WHERE cid = #{cid} \u003c/update\u003e 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:7:1","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.6.2 数目增减-业务层 1.处理异常 2.编写业务层抽象方法 /** * 更新购物车商品数量 * @param cid * @param num * @param modifiedUser */ void updateCartNumByCid(Integer cid,Integer num,String modifiedUser); 3.编写实现逻辑 @Override public void updateCartNumByCid(Integer cid, Integer num, String modifiedUser) { //查询购物车数据 Cart res = cartMapper.findCartByCid(cid); if(res==null){ throw new CartInfoNotExistsException(\"购物车数据不存在\"); } //添加 Integer row = cartMapper.updateCartNumByCid(num, cid, modifiedUser, new Date()); //判断 if(row!=1){ throw new UpdateException(\"更新购物车商品数目出现未知异常\"); } } 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:7:2","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.6.3 数目增减-控制层 1.异常处理 2. 设计请求 请求地址：/cart/update_num 请求参数：Integer cid,Integer num,HttpSession session 请求类型：post 响应类型：JsonResult\u003c void\u003e 3.处理请求，编写控制类 @RequestMapping(value = \"/update_num\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e updateNum(Integer cid,Integer num,HttpSession session){ String modifiedUser = getUsernameFromSession(session); cartService.updateCartNumByCid(cid,num,modifiedUser); return new JsonResult\u003c\u003e(OK); } 4. 前端页面 /*按加号数量增*/ function addNum(num) { var n = parseInt($(\"#goodsCount\"+num).val()); $(\"#goodsCount\"+num).val(n + 1); calcRow(num); } /*按减号数量减少*/ function reduceNum(num) { var n = parseInt($(\"#goodsCount\"+num).val()); if (n == 0) return; $(\"#goodsCount\"+num).val(n - 1); calcRow(num); } //计算单行小计价格的方法 function calcRow(num) { //取单价 parseFloat() 函数可解析一个字符串，并返回一个浮点数。 var vprice = parseFloat($(\"#goodsPrice\"+num).html()); //取数量 var vnum = parseFloat($(\"#goodsCount\"+num).val()); //小计金额 var vtotal = vprice * vnum; //赋值 $(\"#goodsCast\"+num).html(\"¥\" + vtotal); } //向服务器发送ajax请求减少用户购物车的商品数量 function ajaxProductCountRec(num){ reduceNum(num); let cid = $(\"#cid\"+num).val(); let updateNum = $(\"#goodsCount\"+num).val() $.ajax({ url : \"/cart/update_num\", type: \"post\", dataType: \"json\", data:{cid:cid,num:updateNum}, error: function () { alert(\"增加失败，请等待攻城狮修复！！\") } }) } //向服务器发送ajax请求增加用户购物车的商品数量 function ajaxProductCountAdd(num){ addNum(num) let cid = $(\"#cid\"+num).val(); let updateNum = $(\"#goodsCount\"+num).val() $.ajax({ url : \"/cart/update_num\", type: \"post\", dataType: \"json\", data:{cid:cid,num:updateNum}, error: function () { alert(\"增加失败，请等待攻城狮修复！！\") } }) } ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:7:3","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.7 显示勾选的购物车数据 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:8:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.7.1 后端-持久层 1.编写sql 用户在购物车列表随机勾选相关商品，在点击结算按钮之后，跳转到结算页面，在这个页面中需要展示上个页面所勾选的购物车对应数据 SELECT c.cid, c.uid, c.pid, c.price, c.num, p.title, p.image, p.price AS realPrice FROM t_cart c LEFT JOIN t_product p ON c.pid=p.id WHERE c.cid IN (?,?,?) ORDER BY c.created_time DESC ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:8:1","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"2.编写Mapper接口抽象方法 /** * 按照cids查询购物车数据 * @param cids * @return */ List\u003cCartVo\u003e findVoByCid(Integer[] cids); 3.编写映射文件 \u003c!-- List\u003cCartVo\u003e findVoByCid(Integer[] cids);--\u003e \u003cselect id=\"findVoByCid\" resultType=\"com.zxl.store.vo.CartVo\"\u003e SELECT c.cid, c.uid, c.pid, c.price, c.num, p.title, p.image, p.price AS realPrice FROM t_cart c LEFT JOIN t_product p ON c.pid=p.id WHERE c.cid IN ( \u003cforeach collection=\"array\" item=\"cid\" separator=\",\"\u003e #{cid} \u003c/foreach\u003e ) ORDER BY c.created_time DESC \u003c/select\u003e 4 单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:8:2","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.7.2 后端-业务层 1.编写异常 2.编写业务层抽象方法 /** * 按照cids查询购物车数据 * @param cids * @return */ List\u003cCartVo\u003e getVoByCid(Integer[] cids); 3.编写实现逻辑 @Override public List\u003cCartVo\u003e getVoByCid(Integer[] cids) { //查询数据 List\u003cCartVo\u003e data = cartMapper.findVoByCid(cids); //传输数据 return data; } 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:8:3","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.7.3 后端-控制层 1.处理异常 2.设计请求 请求地址：/cart/list 请求参数：Integer[] cids 请求类型：get 响应类型：JsonResult\u003cList\u003e 3.处理请求，编写处理方法 @RequestMapping(value = \"/list\",method = RequestMethod.GET) public JsonResult\u003cList\u003cCartVo\u003e\u003e getCartCids(Integer[] cids){ List\u003cCartVo\u003e data = cartService.getVoByCid(cids); return new JsonResult\u003c\u003e(OK,data); } 4.前端页面 1.将cart.html页面中结算按钮属性变更成type=“submit” 2.orderConfirm.html页面中添加自动加载从上个页面中传递过来的cids数据，再去请求ajax中进行填充当前页面区域中 \u003cscript type=\"text/javascript\"\u003e //展示从购物车界面选中的商品信息 function showOrderItem(){ data = location.search.substr(1);//截取地址栏url?后的第二个元素，即购物车商品的cid //记录商品总数和总价格 let totalNum = 0; let countPrice = 0; //自动发送ajax请求查询url地址上的cid信息 $.ajax({ url : \"/cart/list\", type: \"get\", data: data, dataType: \"json\", success:function(res){ if (res.state === 200){ //填充信息 $(\"#cart-list\").empty() for (let i = 0; i \u003c res.data.length; i++) { let str = \"\"; let cartVo = res.data[i] let totalPrice = cartVo.price * cartVo.num str = \"\u003ctr\u003e\" + \"\u003ctd id=cid\" + i + \" hidden='hidden'\u003e\" + cartVo.cid + \"\u003c/td\u003e\" + \"\u003ctd\u003e\u003cimg src=..\" + cartVo.image + \"collect.png\" + \" class='img-responsive' /\u003e\u003c/td\u003e\" + \"\u003ctd\u003e\" + cartVo.title + \"\u003c/td\u003e\" + \"\u003ctd\u003e¥\u003cspan\u003e\" + cartVo.price + \"\u003c/span\u003e\u003c/td\u003e\" + \"\u003ctd id=num\" + i + \" \u003e\" + cartVo.num + \"\u003c/td\u003e\" + \"\u003ctd\u003e\u003cspan\u003e\" + totalPrice + \"\u003c/span\u003e\u003c/td\u003e\" + \"\u003c/tr\u003e\" $(\"#cart-list\").append(str) //计算商品的数量和总金额 totalNum = totalNum + cartVo.num countPrice = countPrice + totalPrice; } $(\"#all-count\").empty().html(totalNum) $(\"#all-price\").empty().html(countPrice) }else{ location.href = \"500.html\" } }, error: function () { location.href = \"500.html\" } }); } $(function () { //页面加载完成执行查找 showOrderItem(); }); ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:8:4","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5 商品管理 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:0:0","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.1 创建数据表 DROP TABLE IF EXISTS t_product; CREATE TABLE t_product ( id int(20) NOT NULL COMMENT '商品id', category_id int(20) DEFAULT NULL COMMENT '分类id', item_type varchar(100) DEFAULT NULL COMMENT '商品系列', title varchar(100) DEFAULT NULL COMMENT '商品标题', sell_point varchar(150) DEFAULT NULL COMMENT '商品卖点', price bigint(20) DEFAULT NULL COMMENT '商品单价', num int(10) DEFAULT NULL COMMENT '库存数量', image varchar(500) DEFAULT NULL COMMENT '图片路径', status int(1) DEFAULT '1' COMMENT '商品状态 1：上架 2：下架 3：删除', priority int(10) DEFAULT NULL COMMENT '显示优先级', created_time datetime DEFAULT NULL COMMENT '创建时间', modified_time datetime DEFAULT NULL COMMENT '最后修改时间', created_user varchar(50) DEFAULT NULL COMMENT '创建人', modified_user varchar(50) DEFAULT NULL COMMENT '最后修改人', PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; //具体录入信息参照githu ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:1:0","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.2 定义实体类 /** * @author zxl * @description 商品的实体类 * @date 2022/11/4 */ @Data @AllArgsConstructor @NoArgsConstructor public class Product extends BaseEntity{ private Integer id; private Integer categoryId ; private String itemType; private String title; private String sellPoint; private Long price; private Integer num; private String image; private Integer status; private String priority; } ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:2:0","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.3 热销商品 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:3:0","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.3.1 商品排行-持久层 1.编写sql语句 //查询热销商品的sql SELECT * FROM t_product WHERE status = 1 ORDER BY priorty DESC LIMIT 0,4 2.编写Mapper接口和抽象方法 /** * @author zxl * @description 处理商品数据的Mapper接口 * @date 2022/11/4 */ public interface ProductMapper { /** * 按照priority查找热销前五的商品数据 * @return 返回商品数据集合 */ List\u003cProduct\u003e findHotList(); } 3.编写Mapper接口的映射 \u003cmapper namespace=\"com.zxl.store.mappers.ProductMapper\"\u003e \u003c!-- List\u003cProduct\u003e findHotList();--\u003e \u003cselect id=\"findHotList\" resultType=\"com.zxl.store.entity.Product\"\u003e SELECT * FROM t_product WHERE status = 1 ORDER BY priority DESC LIMIT 0,4 \u003c/select\u003e \u003c/mapper\u003e 4.单元测试 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:3:1","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.3.2 商品排行-业务层 1.异常规划 没有异常 2.定义业务层接口和抽象方法 /** * @author zxl * @description 处理商品的业务层接口 * @date 2022/11/4 */ public interface IProductService { /** * 按照priority查找热销前五的商品数据 * @return 返回商品数据集合 */ List\u003cProduct\u003e findHotList(); } 3.编写业务层方法逻辑 /** * @author zxl * @description 处理商品的业务层实现类 * @date 2022/11/4 */ public class IProductServiceImpl implements IProductService { @Autowired(required = false) private ProductMapper productMapper; @Override public List\u003cProduct\u003e findHotList() { //查找数据 List\u003cProduct\u003e res = productMapper.findHotList(); return res; } } 4.单元测试 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:3:2","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.3.3 商品排行-控制层 1.异常处理 没有异常 2.设计请求 请求路径：/product/hot_list 请求参数：无 请求类型：get 响应类型：JsonResult\u003cList\u003c Product» 3.处理请求，编写控制层方法 /** * @author zxl * @description 处理商品相关请求的控制类 * @date 2022/11/4 */ @RestController @RequestMapping(\"/product\") public class ProductController extends BaseController { @Autowired(required = false) private IProductService productService; /** * 返回热销商品 * @return */ @RequestMapping(value = \"/host_list\",method = RequestMethod.GET) public JsonResult\u003cList\u003cProduct\u003e\u003e getHotList(){ List\u003cProduct\u003e data = productService.findHotList(); return new JsonResult\u003c\u003e(OK,data); } } 4.前端页面 function showHotList() { $(\"#hot-list\").empty(); $.ajax({ url:\"/product/hot_list\", type:\"GET\", dataType: \"json\", success: function (res) { for (let i = 0; i \u003c res.data.length; i++) { let str = \"\"; let product = res.data[i] let image = \"..\" + product.image + \"collect.png\" str = \"\u003cdiv class='col-md-12'\u003e\" + \"\u003cdiv class=\\\"col-md-7 text-row-2\\\"\u003e\" + \"\u003ca href='javascript:void(0);'onclick='jumpWithId(#{id})'\u003e\" + product.title + \"\u003c/a\u003e\" + \"\u003c/div\u003e\" + \"\u003cdiv class=\\\"col-md-2\\\"\u003e￥\" + product.price + \"\u003c/div\u003e\" + \"\u003cdiv class=\\\"col-md-3\\\"\u003e\" + \"\u003cimg src=\" + image + \" class='img-responsive' /\u003e\" + \"\u003c/div\u003e\" + \"\u003c/div\u003e\" str = str.replaceAll(\"#{id}\",product.id) $(\"#hot-list\").append(str) } }, error: function () { alert(\"查询错误，请等待攻城狮修复！！\") } }); } ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:3:3","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.4 新到商品 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:4:0","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.4.1 新到商品-持久层 1.编写sql语句 //按照上架物品的修改时间查询新商品 SELET * FROM t_product WHERE status = 1 ORDER BY modified_time DESC LIMIT 0,4 2.定义抽象方法 /** * 按照创建时间查找新到的商品 * @return 返回新商品列表 */ List\u003cProduct\u003e findNewProductList(); 3.定义mapper接口映射文件 \u003c!-- List\u003cProduct\u003e findNewProductList();--\u003e \u003cselect id=\"findNewProductList\" resultType=\"com.zxl.store.entity.Product\"\u003e SELECT * FROM t_product WHERE status = 1 ORDER BY modified_time DESC LIMIT 0,4 \u003c/select\u003e 4.单元测试 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:4:1","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.4.2 新到商品-业务层 1.定义异常 无 2.定义业务层抽象方法 /** * 按照商品状态和创建时间选取新商品集合 * @return */ List\u003cProduct\u003e findNewProductList(); 3. 编写业务层逻辑 @Override public List\u003cProduct\u003e findNewProductList() { //查找数据 List\u003cProduct\u003e res = productMapper.findNewProductList(); return res; } 4. 单元测试 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:4:2","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.4.3 新到商品-控制层 1.处理异常 无 2.定义请求 请求路径：/product/new_list 请求参数：无 请求类型：get 响应类型：JsonResult\u003cList\u003c Product» 3.处理请求，编写控制方法 /** * 返回新商品 * @return */ @RequestMapping(value = \"/new_list\",method = RequestMethod.GET) public JsonResult\u003cList\u003cProduct\u003e\u003e getNewList(){ List\u003cProduct\u003e data = productService.findNewProductList(); return new JsonResult\u003c\u003e(OK,data); } 4.前端页面 function showNewList() { $(\"#new-list\").empty(); $.ajax({ url:\"/product/new_list\", type:\"GET\", dataType: \"json\", success: function (res) { for (let i = 0; i \u003c res.data.length; i++) { let str = \"\"; let product = res.data[i] let image = \"..\" + product.image + \"collect.png\" str = \"\u003cdiv class='col-md-12'\u003e\" + \"\u003cdiv class=\\\"col-md-7 text-row-2\\\"\u003e\" + \"\u003ca href='javascript:void(0);'onclick='jumpWithId(#{id})'\u003e\" + product.title + \"\u003c/a\u003e\" + \"\u003c/div\u003e\" + \"\u003cdiv class=\\\"col-md-2\\\"\u003e￥\" + product.price + \"\u003c/div\u003e\" + \"\u003cdiv class=\\\"col-md-3\\\"\u003e\" + \"\u003cimg src=\" + image + \" class='img-responsive' /\u003e\" + \"\u003c/div\u003e\" + \"\u003c/div\u003e\" str = str.replaceAll(\"#{id}\",product.id) $(\"#new-list\").append(str) } }, error: function () { alert(\"查询错误，请等待攻城狮修复！！\") } }); } ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:4:3","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.5 显示商品 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:5:0","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.5.1 显示商品-持久层 1.编写sql //查找按照商品id查找商品 SELECT id,title,price,image FROM t_product WHERE id = #{id} 2.编写Mapper接口的抽象方法 /** * 按照商品的id查找商品 * @param pid * @return */ Product findProductById(Integer id); 3.编写Mapper接口的映射文件 \u003c!-- Product findProductById(Integer id);--\u003e \u003cselect id=\"findProductById\" resultType=\"com.zxl.store.entity.Product\"\u003e SELECT * FROM t_product WHERE status = 1 AND id = #{id} \u003c/select\u003e 4.单元测试 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:5:1","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.5.2 显示商品-业务层 1.异常处理 商品为找到异常 商品状态异常(为未上架或者已经删除的商品) /** * @author zxl * @description 商品未找到异常 * @date 2022/11/4 */ public class ProductNotFoundException extends ServiceException {} /** * @author zxl * @description 商品状态异常 * @date 2022/11/4 */ public class ProductStatusException extends ServiceException {} 2.编写业务层接口的抽象方法 /** * 根据商品id查找商品 * @param id 商品id * @return 返回商品信息 */ Product findProductById(Integer id); 3.编写业务层具体逻辑 @Override public Product findProductById(Integer id) { //根据id查询商品信息 Product res = productMapper.findProductById(id); //判断商品存在或者商品状态是否为上架 if(res==null){ throw new ProductNotFoundException(\"查询商品不存在\"); } if(res.getStatus()!=1){ throw new ProductStatusException(\"查询商品尚未上架\"); } //传输商品信息 return res; } 4.单元测试 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:5:2","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.5.3 显示商品-控制层 1.异常处理 将上述两个异常加入BaseConrtroller 2.设计请求 请求路径：/product/{id} 请求参数：Integet id 请求类型：get 响应类型：JsonResult\u003c Product\u003e 3.处理请求，设计控制层方法 @RequestMapping(value = \"/{id}\") public JsonResult\u003cProduct\u003e findProductById(@PathVariable(\"id\")Integer id){ //按照获得的id查询商品 Product data = productService.findProductById(id); return new JsonResult\u003c\u003e(OK,data); } 4.前端页面 //index.html function jumpWithId(id) { let jumpUrl = \"product.html?id=\"+id; location.href=jumpUrl; } //function //返回一个参数 function getOne(){ var result; //返回字符串从url的?处开始 var url = decodeURI(window.location.search); //如果等于-1，代表没有找到，即网页连接没有携带任何参数 if (url.indexOf(\"?\") != -1){ //返回一个新的字符串，从url连接=符号处索引+1的位置开始返回 result = url.substr(url.indexOf(\"=\")+1); } return result; } //product.html //接收上一个页面传来的连接 var pid = getOne(); function showInThisProductHtml(){ //判断是否携带参数 if (location.search.substring(1).indexOf(\"id\") === -1){ location.href = \"500.html\" return false; } //在页面加载完成时自动发送此ajax请求并填充表单 $.ajax({ url: \"/product/\" + pid, type: \"get\", dataType: \"json\", success:function (res) { let product = res.data; //将普通的数据填充至页面 $(\"#product-title\").text(product.title) $(\"#product-sell-point\").append(product.sellPoint) $(\"#product-price\").text(product.price) $(\"#stock\").text(product.num) //将数据库查询的图片进行替换 let image = \"..\" + product.image //遍历填充图片数据 for (let i = 1; i \u003c= 5; i++) { $(\"#product-image-\" + i + \"-big\").attr(\"src\",image + i + \"_big.png\") $(\"#product-image-\" + i).attr(\"src\",image + i + \".jpg\") } } }) } ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:5:3","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.地址管理 收货地址的功能模块:列表展示，修改，删除，设置默认，新增收货地址 开发的顺序:新增收货地址-\u003e列表展示-\u003e设置默认收货地址-\u003e修改删除 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:1:0","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.1 创建数据表 创建数据表 CREATE TABLE t_address ( aid INT AUTO_INCREMENT COMMENT '收货地址id', uid INT COMMENT '归属的用户id', NAME VARCHAR(20) COMMENT '收货人姓名', province_name VARCHAR(15) COMMENT '省-名称', province_code CHAR(6) COMMENT '省-行政代号', city_name VARCHAR(15) COMMENT '市-名称', city_code CHAR(6) COMMENT '市-行政代号', area_name VARCHAR(15) COMMENT '区-名称', area_code CHAR(6) COMMENT '区-行政代号', zip CHAR(6) COMMENT '邮政编码', address VARCHAR(50) COMMENT '详细地址', phone VARCHAR(20) COMMENT '手机', tel VARCHAR(20) COMMENT '固话', tag VARCHAR(6) COMMENT '标签', is_default INT COMMENT '是否默认：0-不默认，1-默认', created_user VARCHAR(20) COMMENT '创建人', created_time DATETIME COMMENT '创建时间', modified_user VARCHAR(20) COMMENT '修改人', modified_time DATETIME COMMENT '修改时间', PRIMARY KEY (aid) ) ENGINE=INNODB DEFAULT CHARSET=utf8; ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:1:1","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.2 创建实体类 地址类 @Data @AllArgsConstructor @NoArgsConstructor public class Address extends BaseEntity{ /* * aid INT AUTO_INCREMENT COMMENT '收货地址id', uid INT COMMENT '归属的用户id', name VARCHAR(20) COMMENT '收货人姓名', province_name VARCHAR(15) COMMENT '省-名称', province_code CHAR(6) COMMENT '省-行政代号', city_name VARCHAR(15) COMMENT '市-名称', city_code CHAR(6) COMMENT '市-行政代号', area_name VARCHAR(15) COMMENT '区-名称', area_code CHAR(6) COMMENT '区-行政代号', zip CHAR(6) COMMENT '邮政编码', address VARCHAR(50) COMMENT '详细地址', phone VARCHAR(20) COMMENT '手机', tel VARCHAR(20) COMMENT '固话', tag VARCHAR(6) COMMENT '标签', is_default INT COMMENT '是否默认：0-不默认，1-默认', created_user VARCHAR(20) COMMENT '创建人', created_time DATETIME COMMENT '创建时间', modified_user VARCHAR(20) COMMENT '修改人', modified_time DATETIME COMMENT '修改时间', */ private Integer aid; private Integer uid; private String name; private String provinceName; private String provinceCode; private String cityName; private String cityCode; private String areaName; private String areaCode; private String zip; private String address; private String phone; private String tel; private String tag; private Integer isDefault; } ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:1:2","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.3 新增地址 4.3.1 后端-持久层 1.编写sql语句 //插入语句 insert into t_address(除了aid外字段)value(字段值) //查看收货地址数量(一个用户最大只能20条) select count(*) from t_address where uid = ? 2.定义Mapper接口和抽象方法 /** * @author zxl * @version 1.0.0 * @date 2022/11/02 * @desciption Address所对应的Mapper接口 */ public interface AddressMapper { /** * 插入用户的收货地址数据 * @param address 收货地址 * @return {@link Integer} 受影响的行数 */ Integer addAddress(Address address); /** * 根据用户id统计用户收货地址数量 * @param uid 用户uid * @return {@link Integer} 返回当前用户的收货地址总数 */ Integer userAddressCount(Integer uid); } 3.实现Mapper接口的映射 \u003cmapper namespace=\"com.zxl.store.mappers.AddressMapper\"\u003e \u003c!--addAddress 插入用户的地址--\u003e \u003cinsert id=\"addAddress\" useGeneratedKeys=\"true\" keyProperty=\"aid\"\u003e INSERT INTO t_address ( uid,name, province_name, province_code, city_name, city_code, area_name, area_code, zip, address, phone, tel, tag, is_default, created_user, created_time, modified_user, modified_time ) VALUES ( #{uid}, #{name}, #{provinceName}, #{provinceCode}, #{cityName}, #{cityCode}, #{areaName}, #{areaCode}, #{zip}, #{address}, #{phone}, #{tel}, #{tag}, #{isDefault}, #{createdUser}, #{createdTime}, #{modifiedUser}, #{modifiedTime} ) \u003c/insert\u003e \u003c!--userAddressCount 根据用户uid查询用户地址数量--\u003e \u003cselect id=\"userAddressCount\"\u003e SELECT COUNT(*) FROM t_address WHERE uid = #{uid} \u003c/select\u003e \u003c/mapper\u003e 4.单元测试Mapper接口 4.3.2 后端-业务层 如果用户插入的地址是第一条时，将其设为默认的收货地址 1. 规划异常 用户地址超出数量异常 /** * @author zxl * @description 用户地址数目超出异常 * @date 2022/11/2 */ public class AddressCountLimitException extends ServiceException {} 2.接口和抽象方法 /** * @author zxl * @description 收货地址业务层接口 * @date 2022/11/2 */ public interface IAddressService { /** * 添加用户地址 * @param uid 用户uid * @param username 用户名 * @param address 地址 */ void addAddress(Integer uid, String username, Address address); } 3.实现抽象方法 /** * @author zxl * @description 收货地址业务层的实现类 * @date 2022/11/2 */ @Service public class IAddressServiceImpl implements IAddressService { @Autowired private AddressMapper addressMapper; @Value(\"${user.address.max-count}\") private Integer maxCount; @Override public void addAddress(Integer uid, String username, Address address) { //先判断用户地址的条数 Integer count = addressMapper.userAddressCount(uid); //判断是否超过20条记录 if(count\u003e=maxCount){ throw new AddressCountLimitException(\"用户地址已经到达上限，请删除部分地址\"); } //判断当前地址是否为0 if(count==0){ address.setIsDefault(1); } //补全四项日志 Date currentTime = new Date(); address.setCreatedUser(username); address.setCreatedTime(currentTime); address.setModifiedUser(username); address.setModifiedTime(currentTime); //插入 Integer row = addressMapper.addAddress(address); //判断插入结果 if(row!=1){ throw new InsertException(\"插入时产生未知异常\"); } } } 4.单元测试 4.3.3 后端控制层 1.处理异常 将异常添加到全局异常处理 2.设计请求 请求路径：/address 请求参数：Address address,HttpSession session 请求类型：post 响应类型：JsonResult\u003c Void\u003e 3.处理请求，创建相应controller /** * @author zxl * @description 地址操作的控制层 * @date 2022/11/2 */ @RestController @RequestMapping(\"/address\") public class AddressController extends BaseController{ @Autowired private IAddressService addressService; /** * 处理用户添加地址的操作 * @param address 添加的地址 * @param session 项目自动生成的Session * @return {@link JsonResult}\u003c{@link Void}\u003e */ @PostMapping public JsonResult\u003cVoid\u003e addAddress(Address address, HttpSession session){ //从Session中获取Uid和Username Integer uid = getUserIdFromSession(session); String username = getUsernameFromSession(session); //添加 addressService.addAddress(uid,username,address); return new JsonResult\u003c\u003e(OK); } } 4.前端页面 \u003cscript type=\"text/javascript\"\u003e $(document).ready(function () { $(\"#btn-add-new-address\").click(function() { //判断手机号和收货人是否为空 let name = $(\"#name\").val(); let phone = $(\"#phone\").val(); let zip = $(\"#zip\").val(); let tag = $(\"#tag\").val(); if (phone == \"\" || name == \"\"){ $(\"#error-msg\").html(\"请先填写需要添加的信息！\"); return false; } //验证手机号是否符合要求 let checkPhone = /(^1\\d{10}$)|(^[0-9]\\d{7}$)/; if (!checkPhone.test(phone)){ $(\"#error-msg\").html(\"手机号不符合要求！\"); return false; } //验证邮箱是否为空或者超出最大长度6 if(zip.length\u003e=6){ $(\"#error-msg\").html(\"邮箱的最大长度6\"); return false; } //验证地址类型不可以超过6 if(tag.length\u003e=6){ $(\"","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:1:3","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.4 获取省市区列表 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:2:0","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.4.1 创建数据表 //parent属性代表的是父区域的代码号，省的父代码号是+86 //code代表的是本身的代码号 //name就是code所代表的本身的名称 CREATE TABLE t_dict_district ( id int(11) NOT NULL AUTO_INCREMENT, parent varchar(6) DEFAULT NULL, code varchar(6) DEFAULT NULL, name varchar(16) DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; //部分省市区数据太大 //请参考代码 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:2:1","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.4.2 创建实体类 创建District实体类 ** * @author zxl * @description 省市区的实体类 * @date 2022/11/3 */ @Data @AllArgsConstructor @NoArgsConstructor public class District extends BaseEntity { private Integer id; private String parent; private String code; private String name; } ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:2:2","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.4.3 后端-持久层 1.编写sql语句 //1.查询语句，根据父代号查询 (ASC 升序) SELECT * FROM t_dict_district WHERE parent = ? ORDER BY code ASC //2.根据code查询对应省市区名字 SELECT name FROM t_dict_district WHERE code = ? 2.定义Mapper接口和抽象方法 public interface DistrictMapper { /** * 根据用户的父代号查询区域信息 * @param parent 父代号 * @return 某个父区域下的所有区域列表 */ List\u003cDistrict\u003e findDistrictByParent(String parent); /** * 根据code查询区域名称 * @param code 区域代号 * @return 返回区域名称 */ String findNameByCode(String code); } 3.编写映射文件 \u003cmapper namespace=\"com.zxl.store.mappers.DistrictMapper\"\u003e \u003c!-- List\u003cDistrict\u003e findDistrictByParent(String parent);--\u003e \u003cselect id=\"findDistrictByParent\" resultType=\"com.zxl.store.entity.District\"\u003e SELECT * FROM t_dict_district WHERE parent = #{parent} ORDER BY code ASC \u003c/select\u003e \u003c!-- String findNameByCode(String code);--\u003e \u003cselect id=\"findNameByParent\" resultType=\"java.lang.String\"\u003e SELECT name FROM t_dict_district WHERE code = #{code} \u003c/select\u003e \u003c/mapper\u003e 4.单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:2:3","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.4.4 后端-业务层 1.规划异常 暂无异常可以规划 2.定义Service接口和抽象方法 /** * @author zxl * @description District业务层的接口类 * @date 2022/11/3 */ public interface IDistrictService { /** * 根据父代号查询区域信息(省市区) * @param parent 父代号 * @return 返回多个查询结果 */ List\u003cDistrict\u003e getDistrictByParent(String parent); /** * 按照code查询当前省市区名称 * @param code code * @return 返回省市区名称 */ String getNameByCode(String code); } 3.编写具体的实现方法和处理逻辑 /** * @author zxl * @description 处理省市区业务层接口的实现类 * @date 2022/11/3 */ @Service public class IDistrictServiceImpl implements IDistrictService { @Autowired(required = false) private DistrictMapper districtMapper; //根据父代号查询省市区的信息 @Override public List\u003cDistrict\u003e getDistrictByParent(String parent) { List\u003cDistrict\u003e districtByParent = districtMapper.findDistrictByParent(parent); //无效数据设为null for (District district : districtByParent) { district.setId(null); district.setParent(null); } return districtByParent; } //根据code查询省市区的名称 @Override public String getNameByCode(String code) { return districtMapper.findNameByCode(code); } } 4.单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:2:4","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.4.5 后端-控制层 1.异常处理 没有异常，不需要处理 2.设计请求 请求路径：/district/parent 请求参数：String parent 请求类型：get 响应类型：JsonResult\u003cList\u003c District» 3.处理请求，创建一个控制类 /** * @author zxl * @description 处理省市区相关业务的控制层 * @date 2022/11/3 */ @RestController @RequestMapping(\"/district\") public class DistrictController extends BaseController{ @Autowired(required = false) private IDistrictService districtService; @RequestMapping(value = \"/parent\",method = RequestMethod.GET) public JsonResult\u003cList\u003cDistrict\u003e\u003e getDistrictByParent(String parent){ //查询数据 List\u003cDistrict\u003e Data = districtService.getDistrictByParent(parent); //返回数据 return new JsonResult\u003c\u003e(OK,Data); } } 4. 前端页面 \u003cscript type=\"text/javascript\"\u003e $(document).ready(function () { //页面加载完成时，先把三个省市区的提示设置好 let provinceFirst = '\u003coption value=\"0\"\u003e--- 请选择省 ---\u003c/option\u003e'; let cityFirst = '\u003coption value=\"0\"\u003e--- 请选择市 ---\u003c/option\u003e'; let areaFirst = '\u003coption value=\"0\"\u003e--- 请选择区 ---\u003c/option\u003e'; //插入提示框 $(\"#province-list\").empty(); $(\"#city-list\").empty(); $(\"#area-list\").empty(); $(\"#province-list\").append(provinceFirst); $(\"#city-list\").append(cityFirst); $(\"#area-list\").append(areaFirst); //记录省的点击查询次数 let provinceClick = 0; $(\"#province-list\").click(function () { provinceClick++; console.log(provinceClick); //如果provinceClick为1代表首次点击 if(provinceClick==1){ let str = \"\"; $.ajax({ url:\"/district/parent\", type:\"get\", data:\"parent=86\", dataType:\"json\", success:function (json) { //如果返回消息成功，将数据填充回列表 if(json.state==200){ for(i = 0;i\u003cjson.data.length;i++){ //每个district对象 let district = json.data[i]; str = '\u003coption value=\"' + district.code + '\"\u003e' + district.name + '\u003c/option\u003e'; $(\"#province-list\").append(str); } } }, error:function () { alert(\"查询省市区列表错误，请联系管理员修复！\"); } }); } }); //监听省份的选择 为城市的选择做出变化 $(\"#province-list\").change(function () { //清空select下的所有option元素 $(\"#city-list\").empty(); $(\"#area-list\").empty(); //追加默认值 $(\"#city-list\").append(cityFirst); $(\"#area-list\").append(areaFirst); //获取省份选择的是什么 let provinceChoice = $(\"#province-list\").val(); //等于0 则不做请求 if(provinceChoice==\"0\")return false; let str = \"\"; $.ajax({ url:\"/district/parent\", type:\"get\", data:\"parent=\"+provinceChoice, dataType:\"json\", success:function (json) { if(json.state==200){ for( i = 0;i\u003cjson.data.length;i++){ //每个district对象 let district = json.data[i]; str = '\u003coption value=\"' + district.code + '\"\u003e' + district.name + '\u003c/option\u003e'; $(\"#city-list\").append(str); } } }, error:function () { alert(\"查询省市区列表错误，请联系管理员修复！\"); } }); }); //监听城市选择 为区县的选择做出变化 $(\"#city-list\").change(function () { //获取当前选择的城市是什么 let cityChoice = $(\"#city-list\").val(); //清空select下的option元素 $(\"#area-list\").empty(); //重新设置默认值 $(\"#area-list\").append(areaFirst); //判断默认值是什么 //如果是0则不发送ajax请求 if(cityChoice==\"0\")return false; //发送请求 $.ajax({ url:\"/district/parent\", type:\"get\", data:\"parent=\"+cityChoice, dataType:\"json\", success:function (json) { if(json.state==200){ for( i = 0;i\u003cjson.data.length;i++){ //每个district对象 let district = json.data[i]; str = '\u003coption value=\"' + district.code + '\"\u003e' + district.name + '\u003c/option\u003e'; $(\"#area-list\").append(str); } } }, error:function () { alert(\"查询省市区列表错误，请联系管理员修复！\"); } }); }); //添加地址 $(\"#btn-add-new-address\").click(function() { //判断手机号和收货人是否为空 let name = $(\"#name\").val(); let phone = $(\"#phone\").val(); let zip = $(\"#zip\").val(); let tag = $(\"#tag\").val(); //由于不知道的原因导致省市区的名称无法提交，所以进行这一步 let provinceName = $(\"#province-list\").find(\"option:selected\").text(); $(\"#provinceName\").val(provinceName); let cityName = $(\"#city-list\").find(\"option:selected\").text(); $(\"#cityName\").val(cityName); let areaName = $(\"#area-list\").find(\"option:selected\").text(); $(\"#areaName\").val(areaName); if (phone == \"\" || name == \"\"){ $(\"#error-msg\").html(\"请先填写需要添加的信息！\"); return false; } //验证手机号是否符合要求 let checkPhone = /(^1\\d{10}$)|(^[0-9]\\d{7}$)/; if (!checkPhone.test(phone)){ $(\"#error-msg\").html(\"手机号不符合要求！\"); return false; } //验证邮箱是否为空或者超出最大长度6 if(zip.length\u003e=6){ $(\"#error-msg\").html(\"邮箱的最大长度6\"); return false; } //验证地址类型不可以超过6 if(tag.length\u003e=6){ $(\"#error-msg\").html(\"地址类型的最大长度6\"); return false; } $.aja","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:2:5","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.5 获取用户地址 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:3:0","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.5.1 后端-持久层 1.编写sql语句 //获取用户收货地址 SELECT * FROM t_address WHERE uid = ? ORDER BY is_default DESC , created_time DESC 2.定义抽象方法 只需要在AddressMapper接口中定义新的抽象方法即可 /** * 根据用户的uid查询用户的收货地址集合 * @param uid 用户uid * @return 返回收货地址数据 */ List\u003cAddress\u003e findByUid(Integer uid); 3.编写映射文件 \u003c!-- List\u003cAddress\u003e findByUid(Integer uid);--\u003e \u003cselect id=\"findByUid\" resultType=\"com.zxl.store.entity.Address\"\u003e SELECT * FROM t_address WHERE uid = #{uid} ORDER BY is_default DESC ,created_time DESC \u003c/select\u003e 4.创建Mapper的单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:3:1","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.5.2 后端-业务层 1.异常控制 2.定义业务层抽象方法 /** * 根据用户的uid获取用户的收货地址信息集 * @param uid 用户的uid * @return 返回用户的地址集合 */ List\u003cAddress\u003e getAddressByUid(Integer uid); 3.编写具体的业务处理逻辑 /** * 按照用户uid查询用户的收货地址集合 * @param uid 用户的uid * @return 返回用户的收货地址的集合 */ @Override public List\u003cAddress\u003e getAddressByUid(Integer uid) { //获取结果 List\u003cAddress\u003e res = addressMapper.findByUid(uid); //由于网页端只需要地址类型，收件人姓名，详细地址，联系电话，所以对信息进行部分过滤 for (Address address : res) { address.setUid(null); address.setProvinceCode(null); address.setCityCode(null); address.setAreaCode(null); address.setTel(null); address.setCreatedTime(null); address.setCreatedUser(null); address.setModifiedTime(null); address.setModifiedUser(null); address.setIsDefault(null); } return res; } 4.编写业务层单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:3:2","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.5.3 后端-控制层 1.异常处理 2.设计请求 请求地址:/address 请求参数:HttpSession session 请求类型:GET 相应类型:JsonResult\u003cList\u003e 3.处理请求，编写控制层 /** * 处理网页端自动显示用户收货地址的请求 * @param session 项目自动生成的session * @return 返回JsonResult\u003cList\u003cAddress\u003e\u003e */ @GetMapping public JsonResult\u003cList\u003cAddress\u003e\u003e queryAllAddress(HttpSession session){ List\u003cAddress\u003e res = addressService.getAddressByUid(getUserIdFromSession(session)); return new JsonResult\u003c\u003e(OK,res); } 4.前端页面 //页面初始化加载用户收货地址信息 $(document).ready(function () { $(\"#address-list\").empty(); $.ajax({ url:\"/address\", type:\"GET\", dataType:\"json\", success:function (json) { if(json.data.length!=0){ let list = json.data; for (let i = 0; i \u003c list.length; i++) { let address = list[i]; let str = \" \"; str = \"\u003ctr\u003e\" +\"\u003ctd\u003e\"+address.tag+\"\u003c/td\u003e\" +\"\u003ctd\u003e\"+address.name+\"\u003c/td\u003e\" +\"\u003ctd\u003e\" +address.provinceName + address.cityName + address.areaName + address.address +\"\u003c/td\u003e\" +\"\u003ctd\u003e\"+address.phone+\"\u003c/td\u003e\" + \"\u003ca href='javascript:void(0);' onclick='updateAddress(#{editAid})' class='btn btn-xs btn-info'\u003e\" + \"\u003cspan class='fa fa-edit'\u003e\u003c/span\u003e修改\" + \"\u003c/a\u003e\" + \"\u003c/td\u003e\" + \"\u003ctd\u003e\" + \"\u003ca href='javascript:void(0);' onclick='deleteAddress(#{deleteAid},#{isDefault})' class='btn btn-xs add-del btn-info'\u003e\" + \"\u003cspan class='fa fa-trash-o'\u003e\u003c/span\u003e删除\" + \"\u003c/a\u003e\" + \"\u003c/td\u003e\" + \"\u003ctd\u003e\" + \"\u003ca href='javascript:void(0);' onclick='setDefault(#{defaultAid})' class='btn btn-xs add-def btn-default'\u003e设为默认\u003c/a\u003e\" + \"\u003c/td\u003e\" + \"\u003c/tr\u003e\" //使用正则表达式替换获取该地址的aid值，#{aid}只是一个占位符的含义，没其他含义 str = str.replace(\"#{editAid}\",address.aid) str = str.replace(\"#{deleteAid}\",address.aid) str = str.replace(\"#{defaultAid}\",address.aid) str = str.replace(\"#{isDefault}\",address.isDefault) $(\"#address-list\").append(str) } $(\".add-def:eq(0)\").hide(); }else{ let text = \"\u003ctr\u003e\u003ctd colspan='12' style='font-weight: bold;color: red;padding: 20px;font-size: medium'\u003e\" + \"暂无收货地址，请先添加收货地址\" + \"\u003c/td\u003e\u003c/tr\u003e\" $(\"#address-list\").append(text) } }, error: function (error) { alert(error.message) } }); ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:3:3","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.6 设置默认地址 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:4:0","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.6.1 后端-持久层 1.编写sql语句 //检测当前用户想设置的地址是否存在 SELECT * FROM t_address WHERE aid = ? //将所有的地址都设为非默认地址 UPDATE t_address SET is_default = 0 WHERE uid = ? //更新选中地址的默认值 UPDATE t_address SET is_default = 1,modified_user = ?,modified_time=? WHERE aid = ? 2.定义Mapper接口抽象方法 /** * 根据用户收货地址aid查询收货地址 * @param aid 收货地址id * @return 返回地址 */ Address findByAid(Integer aid); /** * 根据用户uid将所有地址设为非默认地址 * @param uid 用户uid * @return 返回影响行数 */ Integer updateNoneDefault(Integer uid); /** * 按照aid将该条收货地址设为默认地址 * @param aid 用户收货地址aid * @param modifiedUser 执行操作的操作人 * @param modifiedTime 执行操作的操作时间 * @return 返回影响行数 */ Integer updateDefault(Integer aid, String modifiedUser, Date modifiedTime); 3.编写Mapper接口的映射文件 \u003c!-- Address findByAid(Integer aid);--\u003e \u003cselect id=\"findByAid\" resultType=\"com.zxl.store.entity.Address\"\u003e SELECT * FROM t_user WHERE aid = #{aid} \u003c/select\u003e \u003c!-- Integer updateNoneDefault(Integer uid);--\u003e \u003cupdate id=\"updateNoneDefault\"\u003e UPDATE t_address SET is_default = 0 WHERE uid = #{uid} \u003c/update\u003e \u003c!-- Integer updateDefault(Integer aid, String modifiedUser, Date modifiedTime);--\u003e \u003cupdate id=\"updateDefault\"\u003e UPDATE t_address SET is_default = 1,modified_user = #{modifiedUser},modified_time=#{modifiedTime} WHERE aid = #{aid} \u003c/update\u003e 4.编写Mapper接口的单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:4:1","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.6.2 后端-业务层 1.异常处理 更新时异常（已经存在，无需创建） 数据不存在异常 /** * @author zxl * @description 用户地址未找到异常 * @date 2022/11/3 */ public class AddressNotFoundException extends ServiceException {} 2.定义Service层抽象方法 /** *　修改用户选中地址为默认收货地址 * @param uid 用户uid * @param aid 收货地址id * @param username 操作人 * @return void */ void setDefault(Integer uid,Integer aid,String username); 3.编写方法的具体逻辑 @Override public void setDefault(Integer uid, Integer aid, String username) { Address res = addressMapper.findByAid(aid); if(res==null){ throw new AddressNotFoundException(\"用户收货地址不存在\"); } //先将所有的地址设为非默认地址 Integer row = addressMapper.updateNoneDefault(uid); if(row\u003c1){ throw new UpdateException(\"将所有地址设置为非默认地址时出现异常\"); } //按照aid将收货地址设置为默认地址 Integer updateRow = addressMapper.updateDefault(aid, username, new Date()); if(updateRow!=0){ throw new UpdateException(\"设置默认地址时出现异常\"); } } 4.单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:4:2","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.6.3 后端-控制层 1.异常处理 将异常加入到全局处理 2.请求设计 请求路径：/address/set_default/{aid} 请求参数：@PathVariable(“aid”)Integer aid,HttpSession session 请求类型：post 响应类型：JsonResult\u003c void\u003e 3.处理请求，编写控制层 /** * 处理设置默认地址的请求 * @param aid 被设置为默认的收货地址id * @param session 项目启动时生成的session * @return 返回void */ @RequestMapping(value = \"/set_default/{aid}\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e setDefault(@PathVariable(\"aid\")Integer aid,HttpSession session){ //获取uid，username Integer uid = getUserIdFromSession(session); String username = getUsernameFromSession(session); //设置默认 addressService.setDefault(uid,aid,username); return new JsonResult\u003c\u003e(OK); } 4. 前端页面 //为设置默认按钮绑定事件 function setDefault(aid) { if(confirm(\"确定要这条收货地址设为默认地址吗？\")){ $.ajax({ url: \"/address/set_default/\"+aid, type: \"POST\", dataType: \"JSON\", success: function(json) { if (json.state == 200) { alert(\"设置成功\"); location.reload(); } else { alert(\"设置默认收货地址失败！\" + json.message); } }, error: function(json) { alert(\"您的登录信息已经过期，请重新登录！HTTP响应码：\" + json.status); location.href = \"login.html\"; } }); } } ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:4:3","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.7 删除地址 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:5:0","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.7.1 后端-持久层 1.编写sql语句 //根据aid删除用户收货地址的sql DELETE FROM t_address WHERE aid = #{aid} 2.定义Mapper接口抽象方法 /** * 按照aid删除用户的收货地址 * @param aid 用户的收货地址id * @return 返回影响行数 */ Integer DeleteAddressByAid(Integer aid); 3.编写Mapper接口的映射文件 \u003c!-- Integer DeleteAddressByAid(Integer aid);--\u003e \u003cdelete id=\"DeleteAddressByAid\"\u003e DELETE * FROM t_address WHERE aid = #{aid} \u003c/delete\u003e 4.单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:5:1","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.7.2 后端-业务层 1.异常控制 删除时异常 /** * @author zxl * @description 数据库删除时异常 * @date 2022/11/4 */ public class DeleteException extends ServiceException {} 2.定义抽象方法 /** * 按照收货地址id删除收货地址 * @param aid 收货地址id */ void deleteAddressByAid(Integer aid, Integer uid, String username); 3.编写实现逻辑 @Override public void deleteAddressByAid(Integer aid,Integer uid,String username) { //需要先判断用户有多少条地址 Integer count = addressMapper.userAddressCount(uid); //判断用户收货地址是否存在 Address byAid = addressMapper.findByAid(aid); if(byAid==null)throw new AddressNotFoundException(\"用户收货地址不存在\"); //如果地址多条 而且当前要删除的地址为默认地址 if(count\u003e1\u0026\u0026byAid.getIsDefault()==1){ //先删除当前地址 //按照用户aid删除 Integer row = addressMapper.DeleteAddressByAid(aid); //判断是否出现异常 if(row!=1)throw new DeleteException(\"删除用户收货地址时出现未知异常\"); //查询所有的地址，由于查询是按照创造时间排序的 List\u003cAddress\u003e byUid = addressMapper.findByUid(uid); //设置默认地址 addressMapper.updateDefault(aid,username,new Date()); return; } //如果只有一条，就不用判断是否需要再次设置默认地址 //按照用户aid删除 Integer row = addressMapper.DeleteAddressByAid(aid); //判断是否出现异常 if(row!=1)throw new DeleteException(\"删除用户收货地址时出现未知异常\"); } 4.单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:5:2","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.7.3 后端-控制层 1.异常处理 将异常加入全局处理 2.设计请求 请求路径：/address/delete_address/{aid} 请求参数：@PathVariable(“aid”)Integer aid,HttpSession session 请求类型：post 响应类型：JsonResult\u003c void\u003e 3.处理请求，编写控制方法 /** * 处理删除地址的请求 * @param aid 需要删除的收货地址的id * @return 返回OK */ @RequestMapping(value = \"/delete_address/{aid}\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e deleteAddressByAid(@PathVariable(\"aid\")Integer aid,HttpSession session){ //获取uid Integer uid = getUserIdFromSession(session); //获取username String username = getUsernameFromSession(session); //执行删除 addressService.deleteAddressByAid(aid,uid,username); //执行成功返回数据 return new JsonResult\u003c\u003e(OK); } 4.前端页面 //为删除按钮定义事件 function deleteAddress(aid) { if(confirm(\"确定要删除这条收货地址吗?\")){ $.ajax({ url: \"/address/delete_address/\"+aid, type: \"POST\", dataType: \"JSON\", success: function(json) { if (json.state == 200) { location.reload(); } else { alert(\"删除收货地址失败！\" + json.message); } }, error: function(xhr) { alert(\"您的登录信息已经过期，请重新登录！HTTP响应码：\" + xhr.status); location.href = \"login.html\"; } }); } } ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:5:3","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"2环境搭建 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:0:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"2.1基本环境: 1.JDK1.8 2.Maven 3.6.1 3.Mysql 8.0.28 4.IDEA 2019.2.4 3.用户管理 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:1:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.1 创建数据库 CREATE DATABASE IF NOT EXISTS `computer_store` CHARACTER SET 'utf8'; ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:2:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.2 创建数据表 CREATE TABLE t_user ( uid INT AUTO_INCREMENT COMMENT '用户id', username VARCHAR(20) NOT NULL UNIQUE COMMENT '用户名', password CHAR(32) NOT NULL COMMENT '密码', salt CHAR(36) COMMENT '盐值', phone VARCHAR(20) COMMENT '电话号码', email VARCHAR(30) COMMENT '电子邮箱', gender INT COMMENT '性别:0-女，1-男', avatar VARCHAR(50) COMMENT '头像', is_delete INT COMMENT '是否删除：0-未删除，1-已删除', created_user VARCHAR(20) COMMENT '日志-创建人', created_time DATETIME COMMENT '日志-创建时间', modified_user VARCHAR(20) COMMENT '日志-最后修改执行人', modified_time DATETIME COMMENT '日志-最后修改时间', PRIMARY KEY (uid) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 考虑到每个表中都有固定的四个字段,可以使用一个java基类表示 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:3:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.3 创建实体类 //用于与用户四个字段所形成映射关系的基类 public class BaseEntity implements Serializable { private String createdUser;//日志创建人 private Date createdTime;//日志创建时间 private String modifiedUser;//日志最后修改人 private Date modifiedTime;//日志最后修改时间 } //对应数据表的User实体类 public class User extends BaseEntity implements Serializable { private Integer uid;//用户id private String username;//用户名 private String password;//密码 private String salt;//盐值 private String phone;//电话号码 private String email;//电子邮箱 private Integer gender;//性别:0-女，1-男 private String avatar;//头像 private Integer isDelete;//是否删除：0-未删除，1-已删除 } ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:4:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.4 注册 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:5:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.4.1 后端持久层(使用mybatis) 1 编写sql语句 #增加用户的sql语句 INSERT INTO t_user(username,password,)VALUES (？，？) #查询用户是否存在（username在数据库由UNIQUE修饰） SELECT * FROM t_user WHERE username = ? 2 定义mapper接口和抽象方法 由于项目可能有多个mapper接口，所以在项目目录下创建一个mappers包，用于管理所有mapper接口 并在SpringBoot启动类上添加MapperScan注解扫描mapper包或直接在接口说使用@Mapper注解 /*用户模块持久层接口*/ //@Mapper public interface UserMapper { /** * 插入用户数据 * @param user 用户数据 * @return 返回影响行数 */ Integer insert(User user); /** * 根据用户名查询用户数据（数据库中用户名唯一） * @param username 用户名 * @return 返回用户或者null */ User findByUsername(String username); } 3 编写映射文件 项目可能有多个Mapper映射文件，所以需要在项目的resource下创建一个mappers包便于管理。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!--namespace属性:指定当前映射文件和哪个接口映射--\u003e \u003cmapper namespace=\"com.zxl.store.mappers.UserMapper\"\u003e \u003c!--Integer insert(User user);--\u003e \u003c!-- useGeneratedKeys 开启某(主键)个字段的值递增 keyProperty 表示将表中的xxx字段作为主键 --\u003e \u003cinsert id=\"insert\" useGeneratedKeys=\"true\" keyProperty=\"uid\"\u003e INSERT INTO t_user( username,password, salt,phone, email,gender, avatar,is_delete, created_user, created_time, modified_user, modified_time )VALUES ( #{username},#{password}, #{salt},#{phone}, #{email},#{gender}, #{avatar},#{isDelete}, #{createdUser}, #{createdTime}, #{modifiedUser}, #{modifiedTime} ) \u003c/insert\u003e \u003c!--User findByUsername(String username);--\u003e \u003c!-- ResultType 表示查询的结果类型 ResultMap 当表的字段和类的对象属性字段名称不一致时，来自定义结果的映射规则 --\u003e \u003cselect id=\"findByUsername\" resultType=\"com.zxl.store.pojo.User\"\u003e SELECT * FROM t_user WHERE username = #{username} \u003c/select\u003e \u003c/mapper\u003e #针对t_user与User类的名称不对应问题， #可以在application.properties下针对mybatis开启 mybatis.configuration.map-underscore-to-camel-case=true 4 将mapper映射文件的位置在yml配置文件中进行对应的设置 将mapper的映射文件路径添加在application.properties配置文件中进行配置 mybatis.mapper-locations=classpath:mappers/*.xml 在application.properties中配置数据库连接，否则无法连接数据库 (此处以使用mysql为例子设置，具体数据库请参考自己使用的数据库） pring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.username=root spring.datasource.password=123 spring.datasource.url=jdbc:mysql://localhost:3306/store 5 单元测试 进行单元测试，建议尽可能完成所有测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:5:1","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.4.2 后端-业务层 业务层的包下主要有ex、impl、interface，其中ex放置各种异常处理类，impl中放置interface的实现类 1.规划异常处理机制 考虑到在后端处理业务的过程中，会出现各种异常情况，如执行过程中数据库宕机、用户名重复等。 虽然java在异常处理机制已经很完善，以上的情况都是抛出RuntimeException异常，对定位异常不够明确。 因此在业务层的制定中，需要考虑对异常的定义处理。 在业务层制定一个继承RuntimeException异常的异常类ServiceException，再让具体的异常继承这个异常。 /*业务层异常的基类*/ public class ServiceException extends RuntimeException { public ServiceException() { super(); } public ServiceException(String message) { super(message); } public ServiceException(String message, Throwable cause) { super(message, cause); } public ServiceException(Throwable cause) { super(cause); } protected ServiceException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) { super(message, cause, enableSuppression, writableStackTrace); } } 根据业务层不同的 来详细定义具体异常的类型，统一的继承ServiceException异常基类 //用户未找到异常 public class UserNotFoundException extends ServiceException {} //用户名重复异常 public class UsernameDuplicateException extends ServiceException {} //插入时未知异常 public class InsertException extends ServiceException{} //验证码不匹配异常 public class ValidCodeNotMatchException extends ServiceException {} 2 定义业务层接口和抽象方法 public interface IUserService { /** * 处理用户注册 * @param user 用户信息 */ void userRegister(User user); } 3 定义业务层接口的实现类 补全五个字段: is_Delete:便于逻辑删除 create_user:注册记录创建人 create_time:注册日期 modified_user:增删改操作人 modified_time:增删改时间 便于后期数据库管理 @Service public class IUserServiceImpl implements IUserService { @Autowired private UserMapper userMapper; //处理用户注册 @Override public void userRegister(User user) { //首先判断用户名是否在数据库中重复使用 User res = userMapper.findUserByUsername(user.getUsername()); //重复的情况下抛出异常 if(res!=null){ throw new UsernameDuplicateException(\"用户名已被注册\"); } //加密处理:md5算法 //串+password+串---\u003emd5，连续加载3次 //盐值+password+盐值 ---\u003e盐值随机字符串 //记录旧密码 String oldPass = user.getPassword(); //使用UUID获取salt String salt = UUID.randomUUID().toString().toUpperCase(); //进行加密操作 String newPass = getMD5Password(oldPass,salt); //对User进行补全 user.setSalt(salt); user.setPassword(newPass); //修改逻辑删除判定 user.setIsDelete(0); //补全四个操作字段 Date currentTime = new Date(); user.setCreatedTime(currentTime); user.setCreatedUser(user.getUsername()); user.setModifiedTime(currentTime); user.setModifiedUser(user.getUsername()); //调用插入方法 插入用户数据 Integer row = userMapper.addUser(user); //判断插入结果 if(row!=1){ throw new InsertException(\"处理用户注册过程出现未知异常\"); } } /*md5加密*/ private String getMD5Password(String password,String salt){ //加密算法 //加密之后的密匙 for (int i = 0; i \u003c 3 ; i++) { password = DigestUtils.md5DigestAsHex((salt + password + salt).getBytes()).toUpperCase(); } return password; } } 4 业务层进行单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:5:2","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.4.3 后端-控制层 1 设置返回响应信息给前端的基类 /** * @author zxl * @description 相应数据给前端 * @date 2022/10/30 */ @Data public class JsonResult\u003cE\u003e { //响应状态码 200-成功 4000-用户名重复 5000-数据库或服务器异常 private int status; //响应信息 private String message; //响应数据 private E data; public JsonResult() { } public JsonResult(int status) { this.status = status; } public JsonResult(Throwable e) { this.message = e.getMessage(); } public JsonResult(int status, E data) { this.status = status; this.data = data; } } 2 设计请求 请求路径：/user/reg 请求参数：User user,HttpSession session,String code 请求类型：post 响应结果：JsonResult\u003c Void\u003e 3 设计控制层 设计一个BaseController处理全局所有自定义的异常 /*控制层的基类*/ public class BaseController { /*操作成功状态码*/ public static final int OK = 200; /** * 1.当出现了value内的异常之一，就会将下方的方法作为新的控制器方法进行执行 * 因此该方法的返回值也同时是返回给前端的页面 * 2.此外还自动将异常对象传递到此方法的参数列表中，这里使用Throwable e来接收 **/ @ExceptionHandler(ServiceException.class) //统一处理抛出的异常 public JsonResult\u003cVoid\u003e handleException(Throwable e){ JsonResult\u003cVoid\u003e result = new JsonResult\u003c\u003e(e); if (e instanceof UsernameDuplicateException){ result.setStatus(4000); //表示用户名重复 result.setMessage(e.getMessage()); }else if (e instanceof UserNotFoundException){ result.setStatus(4001); //表示用户数据不存在 result.setMessage(e.getMessage()); }else if (e instanceof InsertException){ result.setStatus(5000); //数据库或服务器有问题 result.setMessage(e.getMessage()); } //返回异常处理结果 return result; } } 创建一个UserController处理注册请求 UserController继承了BaseController也就间接拥有了BaseController的属性和方法 @RestController @RequestMapping(\"users\") public class UserController extends BaseController{ @Autowired private IUserService iUserService; //注册用户 @RequestMapping(value = \"reg\",method = RequestMethod.POST) //@ResponseBody//表示此方法的响应结果以json格式进行数据的响应给到前端 public JsonResult\u003cVoid\u003e reg(User user){ iUserService.reg(user); return new JsonResult\u003c\u003e(OK,\"注册成功\"); } } 前端页面 前端页面只需要将表单通过ajax异步向后端服务器发送即可(目标文件:register.html) 只需要通过JavaScript给用户注册按钮绑定事件即可 当前功能: 1.注册信息空缺检测 2.用户名是否合规检测 3.添加验证码 4.验证输入密码是否一致 5.表单提交 \u003cscript type=\"text/javascript\"\u003e $(document).ready(function () { //验证信息和发送ajax注册用户请求 //给用户注册绑定点击事件 $(\"#btn-reg\").click(function () { let name = $(\"#username\").val(); let pwd = $(\"#password\").val(); let rePwd = $(\"#rePwd\").val(); let codeStr = $(\"#code\").val(); //去掉验证码前后空格 codeStr = $.trim(codeStr); if (name == \"\" || pwd == \"\" || rePwd == \"\" || codeStr == \"\") { $(\"#error-msg\").text(\"请先填写需要注册的信息！\"); return false; } //验证用户名是否符合规则 let nameCheck = /^\\w{5,12}$/; let username = $(\"#username\").val(); if (!(nameCheck.test(username))) { $(\"#error-msg\").text(\"用户名必须是5-12位的字母和数字\"); return false; } else { $(\"#error-msg\").empty() } //验证密码是否符合规则 let passCheck = /^\\w{5,12}$/; let password = $(\"#password\").val(); if (!passCheck.test(password)) { $(\"#error-msg\").text(\"密码必须是5-12位的字母和数字\"); return false; } else { $(\"#error-msg\").empty() } //验证确认密码和密码是否相同 let rePass = $(\"#rePwd\").val(); if (rePass !== password) { $(\"#error-msg\").text(\"密码不一致\"); return false; } else { $(\"#error-msg\").empty() } $.ajax({ url: \"/user\", type: \"post\", data: $(\"#form-reg\").serialize(), //获取表单的所有内容 dataType: \"json\", success: function (res) { if (res.status === 200) { alert(\"注册成功！\") location.href = \"login.html\" } else { $(\"#error-msg\").html(res.message) } }, error: function (error) { alert(error.status + \"错误,服务器出现故障，请等待攻城狮修复！！\") } }); }); //显示或隐藏密码的方法 function showPasswordOrNot(eleId,imgId){ let pwd = document.getElementById(eleId) let img = document.getElementById(imgId) if (pwd.type == \"password\"){ pwd.type = \"text\"; img.src = \"../images/img/close.jpeg\" }else { pwd.type = \"password\"; img.src = \"../images/img/open.jpeg\" } } //给图片验证码绑定点击事件，刷新验证码 function reFlashImg(imgId) { let kaptcha = document.getElementById(imgId) kaptcha.src = \"/kaptcha/kaptcha-image?time=\"+ new Date(); } }); \u003c/script\u003e ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:5:3","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.5 用户登录 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:6:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.5.1 后端-持久层 持久层可以利用上面写好的sql语句判断用户是否存在 1.sql语句可以使用上面的 2.Mapper接口用上面的 3.\u0008Mapper接口的映射文件可以使用上面的 4.单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:6:1","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.5.2 后端-业务层 1.规划异常 创建两个异常类继承ServiceException基类 // 表示用户名不存在的异常 public class UserNotFoundException extends ServiceException {} //表示密码错误的异常 public class PasswordNotMatchException extends ServiceException {} 2.编写接口抽象方法 /** * 用户登陆操作 * @param user 用户信息 * @return 返回用户 */ User userLogin(User user); 3.实现类内具体的业务处理流程 //处理用户登陆 @Override public User userLogin(User user) { //用户名 String username = user.getUsername(); //密码 String password = user.getPassword(); //查询用户是否在数据库中 User res = userMapper.findUserByUsername(username); //判断结果为空或者逻辑删除 if(res==null||(res.getIsDelete()==1)){ throw new UserNotFoundException(\"用户数据不存在\"); } //密码校验 String salt = user.getSalt(); String databasePass = res.getPassword(); //获取加密密码 String md5Password = getMD5Password(password, salt); // if(!(md5Password.equals(databasePass))){ throw new PasswordNotMatchException(\"密码错误\"); } //密码正确返回查询结果 //将查询结果中的uid、username、avatar封装到新的user对象中 User ret = new User(); user.setUid(res.getUid()); user.setUsername(res.getUsername()); user.setAvatar(res.getAvatar()); return ret; } 进行单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:6:2","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.5.3 后端-控制层 1.在全局的BaseController中添加异常处理 2.设计请求 请求路径：/user/login 请求参数：User user, HttpSession session,String code 请求类型：get 响应结果：JsonResult\u003c User\u003e 3. 处理请求 //用户登陆 @GetMapping public JsonResult\u003cUser\u003e userLogin(User user,HttpSession session,String code){ //从session取出验证码 String validCode = (String) session.getAttribute(Constants.KAPTCHA_SESSION_KEY); //判断验证码是否正确 if (!validCode.equals(code)) { throw new ValidCodeNotMatchException(\"验证码错误,请重试！\"); } //执行登陆操作 User LoginUser = userService.userLogin(user); //将用户名和uid保存到session中 session.setAttribute(\"uid\",LoginUser.getUid()); session.setAttribute(\"username\", LoginUser.getUsername()); //返回数据 return new JsonResult\u003c\u003e(OK,LoginUser); } 4.单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:6:3","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.5.4 前端页面 登录成功以及登录成功后需要做的事情： 需要在登录成功后跳转至首页 window.location.href = “xxx.html” 这个直接跳转到指定页面 保存用户信息到session域中 3.5.4.1 保存在前端的会话窗口中，供前端页面使用 $.ajax({ url : \"/user\", type: \"get\", data: $(\"#form-login\").serialize(), //获取表单的所有内容 dataType: \"json\", success: function (res) { if (res.status === 200){ alert(\"登录成功！\"); //前往首页 window.location.href=\"index.html\"; //将用户信息存入session域中 sessionStorage.setItem(\"user\",JSON.stringify(res.data)); }else { $(\"#error-msg\").html(res.message) } }, error: function (error) { alert(error.status + \"错误,服务器出现故障，请等待攻城狮修复！！\") } }); 3.5.4.2 保存在工程项目的session中，供整个工程使用 session对象主要存在服务器端，可以用于保存服务器的临时数据的对象，也可用于拦截器的拦截请求 public class BaseController { /** * Description : 从session中获取用户uid * @param session springboot启动时生成的session对象 **/ public final Integer getUserIdFromSession(HttpSession session){ String uidStr = session.getAttribute(\"uid\").toString(); return Integer.valueOf(uidStr); } //从session中获取用户username public final String getUsernameFromSession(HttpSession session){ return session.getAttribute(\"username\").toString(); } } 3.5.4.3 拦截器，对每个访问的页面进行拦截判断，没有登录则重定向至登录页面 在interceptor包下自定义拦截器类，实现HandleInterceptor接口，实现此接口的方法 public class LgoinInterceptor implements HandlerInterceptor { //在调用所有处理请求的方法之前被自动调用执行的方法 /** * 检测全局Session对象中是否有Uid数据，如果有放行，如果没有重定向到登陆页面 * * @param request 请求对象 * @param response 响应对象 * @param handler 处理器 * @return 如果返回值为true--\u003e 放行 如果false--\u003e 拦截 * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //获取项目工程的session HttpSession session = request.getSession(); if (session.getAttribute(\"uid\") != null) { //说明此时已登录 return true; } else {//说明未登录 //重定向至登录页面 response.sendRedirect(\"/web/login.html\"); return false; } } //ModelAndView对象返回之后被调用的方法 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } //在整个请求所有关联的资源被执行完毕最后所执行的方法 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } } 3.5.4.4 在config包下创建自定义配置类，实现WebMvcConfigurer接口，将拦截器添加到容器中 ​指定拦截规则【如果是拦截所有，静态资源也会被拦截，所以要指定白名单和黑名单】 拦截器也要放行接口的请求，不然就报错 @Configuration//加载当前的拦截器并进行注册 //处理器拦截器的注册 public class LoginInterceptorConfigurer implements WebMvcConfigurer { //将自定义的拦截器进行注册 @Override public void addInterceptors(InterceptorRegistry registry) { //自定义一个拦截器对象 HandlerInterceptor interceptor = new LgoinInterceptor(); //配置白名单 List\u003cString\u003e patterns = new ArrayList\u003c\u003e(); patterns.add(\"/bootstrap3/**\"); patterns.add(\"/css/**\"); patterns.add(\"/images/**\"); patterns.add(\"/js/**\"); patterns.add(\"/web/register.html\"); patterns.add(\"/web/login.html\"); patterns.add(\"/web/index.html\"); patterns.add(\"/web/product.html\"); patterns.add(\"/users/**\"); patterns.add(\"/kaptcha/**\"); patterns.add(\"/address/**\"); patterns.add(\"/cart/**\"); patterns.add(\"/district/**\"); patterns.add(\"/product/**\"); //向注册器对象添加拦截器 registry.addInterceptor(interceptor) .addPathPatterns(\"/**\")//要拦截的Url是什么 .excludePathPatterns(patterns); } } ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:6:4","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.6 修改密码 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:7:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.6.1 后端-持久层 1.编写sql语句 SELECT * FROM t_user WHERE uid = #{uid} UPDATE t_user SET password=#{password}, modified_time=#{modifiedTime}, modified_user=#{modifiedUser} WHERE uid = #{uid} 2.定义mapper接口的抽象方法 /** * 根据用户的id查询用户数据 * @param uid 用户Uid * @return 返回用户数据或者null */ User findByUid(Integer uid); /** * 根据用户Uid修改密码 * @param uid 用户Uid * @param password 用户输入的新密码 * @param modifiedUser 表示修改的执行者 * @param modifiedTime 表示修改的时间 * @return */ Integer updatePasswordByUid(Integer uid, String password, String modifiedUser, Date modifiedTime); 3.编写Mapper接口映射 \u003c!--User findByUid(Integer uid);--\u003e \u003cselect id=\"findByUid\" resultType=\"com.zxl.store.entity.User\"\u003e SELECT * FROM t_user WHERE uid = #{uid} \u003c/select\u003e \u003c!-- Integer updatePasswordByUid(Integer uid, String password, String modifiedUser, Date modifiedTime);--\u003e \u003cupdate id=\"updatePasswordByUid\" \u003e UPDATE t_user SET password=#{password}, modified_time=#{modifiedTime}, modified_user=#{modifiedUser} WHERE uid = #{uid} \u003c/update\u003e 4.测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:7:1","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.6.2 后端-业务层 1.异常处理，创建一个表示密码不匹配的异常，比如原密码不对 2.定义Userservice的抽象方法 3.编写实现类实现接口方法的业务处理逻辑 1.密码不匹配错误 public class PasswordNotMatchException extends ServiceException {} 2.IUserService的抽象方法 /** * 更改用户密码 * @param uid 用户id * @param username 用户名 * @param oldPassword 用户的旧密码 * @param newPasswrod 用户的新密码 */ void changePasswrod(Integer uid,String username,String oldPassword,String newPasswrod); 3.IUserServiceImpl 实体类的方法 @Override public void changePasswrod(Integer uid, String username, String oldPassword, String newPasswrod) { //先查询用户数据是否为空或者逻辑删除 User res = userMapper.findByUid(uid); if(res==null||res.getIsDelete()==1){ throw new UserNotFoundException(\"用户数据不存在\"); } //数据库密码和旧密码对比 String dataPassword = res.getPassword(); String md5Password = getMD5Password(oldPassword, res.getSalt()); if(!dataPassword.equals(md5Password)){ throw new PasswordNotMatchException(\"密码不匹配\"); } //插入新密码插入数据库，更新操作人和操作时间 String newPass = getMD5Password(newPasswrod, res.getSalt()); Integer row = userMapper.updatePasswordByUid(uid, newPass, username, new Date()); if(row!=1){ throw new InsertException(\"更新数据时产生未知异常\"); } } ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:7:2","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.6.3 后端-控制层 1.在全局异常处理机制中添加对业务层异常的处理 2.设计请求 请求路径 /user/change_password 请求参数 @RequestParam(“oldPassword”) String oldPassword, @RequestParam(“newPassword”) String newPassword, HttpSession session 请求类型 post 响应类型 JsonResult\u003c Void\u003e 3.处理请求 //用户更改密码 @RequestMapping(value = \"/change_password\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e changePassword(@RequestParam(\"oldPassword\") String oldPassword, @RequestParam(\"newPassword\") String newPassword, HttpSession session){ //获取Uid Integer uid = getUserIdFromSession(session); String username = getUsernameFromSession(session); userService.changePasswrod(uid,username,oldPassword,newPassword); //在用户修改密码之后清除session中保存的密码 session.setAttribute(\"uid\",null); return new JsonResult\u003c\u003e(OK,\"修改密码成功\"); } ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:7:3","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.6.4 前端页面 1.在用户修改完密码之后，重新定向为index.html 2.\u0008在后端控制层清楚掉uid值，使用户重新登陆 \u003cscript type=\"text/javascript\"\u003e $(document).ready(function () { $(\"#btn-change-password\").click(function () { if ($(\"#oldPwd\").val() == \"\" || $(\"#newPwd\").val() == \"\" || $(\"#rePwd\").val() == \"\"){ $(\"#error-msg\").text(\"请填写完信息后再提交！\"); return false; } //验证密码是否符合规则 let passCheck = /^\\w{5,12}$/; let password = $(\"#newPwd\").val(); if (!passCheck.test(password)){ $(\"#error-msg\").text(\"新密码必须是5-12位的字母和数字\"); return false; }else { $(\"#error-msg\").empty() } //验证确认密码和密码是否相同 let rePass = $(\"#rePwd\").val(); if (rePass !== password){ $(\"#error-msg\").text(\"密码不一致\"); return false; }else { $(\"#error-msg\").empty() } $(\"#btn-change-password\").click(function() { $.ajax({ url: \"/user/change_password\", type: \"POST\", data: $(\"#form-change-password\").serialize(), dataType: \"json\", success: function(json) { if (json.state === 200){ alert(\"密码已更改成功，请重新登录\") //跳转至首页，让用户重新登录 location.href = \"login.html\" }else { $(\"#error-msg\").html(json.message) } }, error: function (xhr) { alert(\"您的登录信息已经过期，请重新登录！HTTP响应码：\" + xhr.status); location.href = \"login.html\"; } }); }); }); }); \u003c/script\u003e ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:7:4","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.7 个人资料 3.7.1 后端持久层 1.编写Sql 需要更新phone、email、gender、modified_user ,modified_time这五个字段 //更新的sql语句 update t_user set phone = #{phone}, email = #{email}, gender = #{gender}, modified_user = #{modifiedUser}, modified_time = #{modifiedTime} where uid = #{uid} 2.定义Mapper接口抽象方法 /** * 根据用户的id查询用户数据 * * @param uid 用户Uid * @return 返回用户数据或者null */ User findByUid(Integer uid); /** * 更新用户信息 * @param user 用户数据 * @return 返回影响的行数 */ Integer updateInfoByUid(User user); 3.编写Mapper接口的映射文件 \u003c!--User findByUid(Integer uid);--\u003e \u003cselect id=\"findByUid\" resultType=\"com.zxl.store.entity.User\"\u003e SELECT * FROM t_user WHERE uid = #{uid} \u003c/select\u003e \u003cupdate id=\"updateInfoByUid\"\u003e UPDATE t_user SET \u003cif test=\"phone!=null\"\u003ephone = #{phone},\u003c/if\u003e \u003cif test=\"email!=null\"\u003eemail = #{email},\u003c/if\u003e \u003cif test=\"gender!=null\"\u003egender = #{gender},\u003c/if\u003e modified_time = #{modifiedTime}, modified_user = #{modifiedUser} WHERE uid = #{uid} \u003c/update\u003e 4.单元测试 3.7.2 后端-业务层 1.定义异常（无） 2.定义IUserService接口的抽象方法 3.实现抽象方法，编辑业务逻辑 1.定义异常 （无） 2.定义IUserService接口的抽象方法 /** * 根据用户的id查询用户的数据 * @param uid 用户id * @return 返回查询到的用户 或者 null */ User getByUid(Integer uid); /** * 更新用户的数据操作 * @param uid 用户的id * @param username 用户名 * @param user 用户对象数据 */ void changeInfo(Integer uid,String username,User user); 3.实现抽象方法，编写业务逻辑 @Override public User getByUid(Integer uid) { User res = userMapper.findByUid(uid); if(res==null||res.getIsDelete()==1){ throw new UserNotFoundException(\"用户数据不存在\"); } User usr = new User(); //防止重要内容泄漏 usr.setUsername(res.getUsername()); usr.setPhone(res.getPhone()); usr.setEmail(res.getEmail()); usr.setGender(res.getGender()); return usr; } /*User对象中的phone/email/gender 手动将uid/username/封装*/ @Override public void changeInfo(Integer uid, String username, User user) { User res = userMapper.findByUid(uid); if(res==null||res.getIsDelete()==1){ throw new UserNotFoundException(\"用户数据不存在\"); } user.setUid(uid); user.setUsername(username); user.setModifiedUser(username); user.setModifiedTime(new Date()); Integer row = userMapper.updateInfoByUid(user); if(row!=1){ throw new InsertException(\"更新时数据产生未知异常\"); } } 4.单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:8:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.7.3 后端-控制层 1.无异常，不需要处理 2.设计请求 请求路径 /user/change_info 请求参数 User user,HttpSession session 请求类型 post 响应类型 JsonResult 3.处理请求 //修改用户信息 @RequestMapping(value = \"/change_info\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e changeInfo(User user,HttpSession session){ //User数据只有四部分 用户电话邮箱性别 System.out.println(user.getUsername()+user.getEmail()+ user.getPhone()+user.getGender()); //Service内部已经重新写入 userService.changeInfo(getUserIdFromSession(session),getUsernameFromSession(session),user); return new JsonResult\u003c\u003e(OK,\"修改信息成功\"); } //获取用户信息 @RequestMapping(value = \"/get_by_uid\",method = RequestMethod.GET) public JsonResult\u003cUser\u003e getByUid(HttpSession session){ Integer uid = getUserIdFromSession(session); User user = userService.getByUid(uid); //将用户名、id、电话、邮箱、性别进行回传 User newUser = new User(); newUser.setUsername(user.getUsername()); newUser.setUid(user.getUid()); newUser.setGender(user.getGender()); newUser.setPhone(user.getPhone()); newUser.setEmail(user.getEmail()); newUser.setAvatar(user.getAvatar()); return new JsonResult\u003c\u003e(OK,newUser); } ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:8:1","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.7.4 前端页面 1.第一个ajax请求在用户信息页面加载完成后自动发送，并根据返回值通过js的id选择器 ​ 找到对应的元素并修改其属性值 2.第二个ajax请求在用户点击修改按钮之后先提示是否修改，再根据其选择进行处理， ​ 同理根据结果利用js的id选择器找到对应的元素并修改其属性值 \u003cscript type=\"text/javascript\"\u003e $(document).ready(function() { $.ajax({ url: \"/user/get_by_uid\", type: \"GET\", dataType: \"json\", success: function(json) { if (json.state == 200) { console.log(\"username=\" + json.data.username); console.log(\"phone=\" + json.data.phone); console.log(\"email=\" + json.data.email); console.log(\"gender=\" + json.data.gender); $(\"#username\").val(json.data.username); $(\"#phone\").val(json.data.phone); $(\"#email\").val(json.data.email); let radio = json.data.gender == 0 ? $(\"#gender-female\") : $(\"#gender-male\"); radio.prop(\"checked\", \"checked\"); } else { alert(\"获取用户信息失败！\" + json.message); } } }); //给用户更改信息绑定点击事件 $(\"#btn-change-info\").click(function () { //根据用户选择状态决定是否发生ajax请求 if (confirm(\"确定要修改吗？\")){ let phone = $(\"#phone\").val(); let email = $(\"#email\").val(); if (phone == \"\" || email == \"\"){ $(\"#error-msg\").html(\"请先填写需要修改的信息！\"); return false; } let checkPhone = /^[1][3,4,5,7,8][0-9]{9}$/; if (!checkPhone.test(phone)){ $(\"#error-msg\").html(\"手机号不符合要求！\"); return false; } //验证邮箱是否符合规则 let checkEmail = /^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/; if (!checkEmail.test(email)){ $(\"#error-msg\").html(\"邮箱不符合要求！\"); return false; } $.ajax({ url : \"/user/change_info\", type: \"post\", data: $(\"#form-change-info\").serialize(),//获取表单的所有内容 dataType: \"json\", success: function (res) { if (res.status === 200){ alert(\"修改成功！\") //网页刷新 location.reload(); }else { $(\"#error-msg\").html(res.message); } }, error: function (error) { alert(\"服务器出现故障，请等待攻城狮修复！！\") } }); } }) }); \u003c/script\u003e ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:8:2","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.8 头像上传 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:9:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.8.1 后端-持久层 1.编写sql 对应的avatar字段保存头像地址 UPDATE t_user SET avatar=#{avatar}, modified_user=#{modifiedUser}, modified_time=#{modifiedTime} WHERE uid = #{uid} 2.定义Mapper接口的抽象方法 /** * 根据用户的Uid修改头像 * @param uid 用户Uid * @param avatar 头像数据 * @param modifiedUser 表示修改的执行者 * @param modifiedTime 表示修改的时间 * @return */ Integer updateAvatarByUid(@Param(\"uid\") Integer uid, @Param(\"avatar\") String avatar, @Param(\"modifiedUser\") String modifiedUser, @Param(\"modifiedTime\") Date modifiedTime); 3.编写Mapper接口的映射文件 \u003cupdate id=\"updateAvatarByUid\"\u003e UPDATE t_user SET avatar=#{avatar}, modified_user=#{modifiedUser}, modified_time=#{modifiedTime} WHERE uid = #{uid} \u003c/update\u003e 4.单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:9:1","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.8.2 后端-业务层 1.异常规划 例如用户数据不存在，服务器宕机等 2.定义service层接口抽象方法 3.实现类重写抽象方法，编写业务处理逻辑 2.定义Service层接口抽象方法 /** * 更新用户的头像操作 * @param uid 用户id * @param avatar 用户头像路径 * @param username 修改的执行者 */ void changeAvatar(Integer uid,String avatar,String username); 3.实现类重写抽象方法，编写业务层逻辑 /**/ @Override public void changeAvatar(Integer uid, String avatar, String username) { //查询当前的用户数据是否存在 User res = userMapper.findByUid(uid); if(res==null||res.getIsDelete()==1){ throw new UserNotFoundException(\"用户数据不存在\"); } Integer row = userMapper.updateAvatarByUid(uid, avatar, username, new Date()); if(row!=1){ throw new InsertException(\"更新时数据产生未知异常\"); } } 4 .单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:9:2","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.8.3 后端-控制层 1.处理控制层和业务层异常，将控制层异常加入全局异常处理@ExceptionHandler的值中 考虑到控制层接口前端数据也有可能出现异常，因此控制层也要进行异常控制 创建一个FileUploadException继承RunTimeException，其余异常继承此异常 ①文件为空异常 ②文件大小超出限制异常 ③文件状态异常 ④文件类型不符异常 ⑤文件读取IO异常 2.设计请求 请求路径：/change_avatar 请求参数：MultipartFile file，Httpsession session 请求类型：post 响应类型：JsonResult\u003c Void\u003e 3.处理请求 ①创建一个Controller专门处理文件的上传和下载 ②将文件的下载地址保存到数据库 /** * @author zxl * @description * @date 2022/10/30 */ @RestController @RequestMapping(\"/file\") public class FileController extends BaseController{ @Autowired private IUserService userService; /*设置上传文件的最大值*/ public static final int AVATAR_MAX_SIZE=10 * 1024 * 1024; /*限制上传文件的类型*/ public static final List\u003cString\u003e AVATAR_TYPES = new ArrayList\u003c\u003e(); static { AVATAR_TYPES.add(\"image/jpeg\"); AVATAR_TYPES.add(\"image/jpg\"); AVATAR_TYPES.add(\"image/png\"); AVATAR_TYPES.add(\"image/bmp\"); AVATAR_TYPES.add(\"image/gif\"); } /** * MultipartFile接口时SpringMVC提供的一个接口，这个接口为我们包装了 * 获取文件数据(任何类型的文件File都可以),Springboot整合了SpringMVC * 只需要在处理请求的方法参数列表上声明一个参数为MultipartFile即可 * @param session * @param file * @return */ @PostMapping public JsonResult\u003cString\u003e changeAvatar(HttpSession session, @RequestParam(\"file\") MultipartFile file){ //判断文件是否为null if(file.isEmpty()){ throw new FileEmptyException(\"文件为空\"); } //判断文件大小 if(file.getSize()\u003eAVATAR_MAX_SIZE){ throw new FileSizeException(\"文件大小超出限制\"); } // 判断上传的文件类型是否超出限制 String contentType = file.getContentType(); // boolean contains(Object o)：当前列表若包含某元素，返回结果为true；若不包含该元素，返回结果为false if (!AVATAR_TYPES.contains(contentType)) { // 是：抛出异常 throw new FileTypeException(\"不支持使用该类型的文件作为头像，允许的文件类型：\" + AVATAR_TYPES); } //获取当前文件的绝对路径 //String parent = session.getServletContext().getRealPath(\"upload\"); String parent = \"/Users/zhaoxinlei/workspace/StoreRebuild/store/src/main/resources/static/avatar\"; System.out.println(parent); //保存头像文件的文件夹 File dir = new File(parent); if(!dir.exists()){ dir.mkdirs(); } //保存头像文件的文件名 String suffix =\"\"; String originalFilename = file.getOriginalFilename(); int beginIndex = originalFilename.lastIndexOf(\".\"); if(beginIndex\u003e0){ suffix = originalFilename.substring(beginIndex); } String filename = UUID.randomUUID().toString() + suffix; // 创建文件对象，表示保存的头像文件 File dest = new File(dir,filename); //执行保存文件操作 try{ file.transferTo(dest); }catch (IllegalStateException e){ //抛出异常 throw new FileStateException(\"文件状态异常，可能文件已被移动或者删除\"); }catch (IOException e){ //抛出异常 throw new FileUploadIOException(\"上传文件时读写错误,请稍后重新尝试\"); } //从Session中获取Uid和username Integer uid = getUserIdFromSession(session); String username = getUsernameFromSession(session); //将头像写入数据库 userService.changeAvatar(uid,filename,username); //返回成功头像路径 String avatar = \"../avatar/\"+filename; System.out.println(filename); System.out.println(avatar); return new JsonResult\u003c\u003e(OK,avatar); } } ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:9:3","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.8.4. 前端页面 \u003cscript type=\"text/javascript\"\u003e $(document).ready(function () { //网页加载完成之前自动发送ajax请求 $.ajax({ url: \"/user/get_by_uid\", type: \"get\", dataType: \"json\", success:function (res) { //判断用户是首次注册还是老用户 if (res.data.avatar !== null \u0026\u0026res.data.avatar !== \"\" ){ //设置用户头像 $(\"#img-avatar\").attr(\"src\",\"../avatar/\"+res.data.avatar) }else{ //设置为默认头像 $(\"#img-avatar\").attr(\"src\",\"../images/index/user.jpg\") } }, error:function (err) { alert(err.message()) } }) $(\"#btn-change-avatar\").click(function() { $.ajax({ url: \"/file\", type: \"POST\", data: new FormData($(\"#form-change-avatar\")[0]), dataType: \"JSON\", processData: false, // processData处理数据 contentType: false, // contentType发送数据的格式 success: function(json) { if (json.state == 200) { $(\"#img-avatar\").prop(\"src\", json.message); console.log($(\"#img-avatar\").prop(\"src\")); } else { alert(\"修改失败！\" + json.message); } }, error: function(xhr) { alert(\"您的登录信息已经过期，请重新登录！HTTP响应码：\" + xhr.status); location.href = \"login.html\"; } }); }); }); \u003c/script\u003e ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:9:4","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"}]