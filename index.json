[{"categories":["C++","网络通信"],"content":" socket编程有三种 1.流式套接字(SOCKET_STREAM) 2.数据报式套接字(SOCKET_DGRAM) 3,原始套接字(SOCKET_RAW) 前两者较常使用，基于TCP使用的是SOCKET_STREAM(流式套接字) 服务端 1.socket():创建流式socket int socket(int, int, int); 头文件： #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e 函数原型： int socket(int domain, int type, int protocol) domain: 协议类型，一般为AF_INET type: socket类型(SOCKET_STREAM,SOCKET_DGRAM,SOCKET_RAW) protocol:用来指定socket所使用的传输协议编号，通常设为0即可 2.bind():指定用于通信的IP地址和port端口 bind() 头文件： #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e 函数原型： int bind(int sockfd, struct sockaddr *my_addr, int addrlen) sockfd: socket描述符 my_addr:是一个指向包含有本机ip地址和端口号等信息的sockaddr类型的指针 addrlen:常被设为sizeof(struct sockaddr) 3.listen():把socket设为监听对象 3 listen() 头文件： #include \u003csys/socket.h\u003e 函数原型： int listen(int sockfd, int backlog); sockfd:socket()系统调用返回的socket描述符 backlog:指定在请求队列中的最大请求数，进入的连接请求将在队列中等待accept()它们。 4.accept():接受客户端发来的连接请求 4 accept() 头文件： #include \u003csys/types.h\u003e #inlcude \u003csys/socket.h\u003e 函数原型： int accept(int sockfd, void *addr, int addrlen) sockfd:是被监听的socket描述符 addr:通常是一个指向sockaddr_in变量的指针，该变量用来存放提出连接请求服务的主机的信息 addrlen:sizeof(struct sockaddr_in) 5.recv()/send():接受或者发送 send() 头文件： #include \u003csys/socket.h\u003e 函数原型： int send(int sockfd, const void *msg, int len, int flags); sockfd:用来传输数据的socket描述符 msg:要发送数据的指针 flags: 0 recv() 头文件： #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e 函数原型: int recv(int sockfd, void *buf, int len, unsigned int flags) sockfd：接收数据的socket描述符 buf:存放数据的缓冲区 len:缓冲的长度 flags:0 6.close():关闭socket连接 客户端 1.socket():创建流式套接字 2.connect():连接服务器，发起请求 3.send()/recv():接受或者发送 4.close():关闭socket连接 释放资源 ","date":"2023-02-16","objectID":"/socket%E9%80%9A%E4%BF%A1/:0:0","tags":["socket"],"title":"Socket通信","uri":"/socket%E9%80%9A%E4%BF%A1/"},{"categories":["C++","网络通信"],"content":"备注 htons 头文件: #include \u003carpa/inet.h\u003e uint16_t htons(uint16_t hostshort);　htons的功能： 将一个无符号短整型数值转换为网络字节序，即大端模式(big-endian)　参数u_short hostshort: 16位无符号整数　返回值: TCP / IP网络字节顺序. htonl() #include \u003carpa/inet.h\u003e　uint32_t htonl(uint32_t hostlong);　简述：将主机的无符号长整形数转换成网络字节顺序。　hostlong：主机字节顺序表达的32位数。　注释： 本函数将一个32位数从主机字节顺序转换成网络字节顺序。　返回值：　htonl()返回一个网络字节顺序的值。 使用gethostname(const char *name); 返回如下结构体 struct hostent { char *h_name; /* official name of host */ char **h_aliases; /* alias list */ int h_addrtype; /* host address type */ int h_length; /* length of address */ char **h_addr_list; /* list of addresses */ } hostent-\u003eh_name 表示的是主机的规范名。例如www.baidu.com的规范名其实是www.a.shifen.com。 hostent-\u003eh_aliases 表示的是主机的别名。www.baidu.com就是baidu他自己的别名。 hostent-\u003eh_addrtype 表示的是主机ip地址的类型。只会是ipv4(AF_INET)， 这个函数处理不了ipv6 hostent-\u003eh_length 表示的是主机ip地址的长度。 hostent-\u003eh_addr_list 表示的是主机的ip地址。是网络字节序，需要通过inet_ntop函数转换。 ","date":"2023-02-16","objectID":"/socket%E9%80%9A%E4%BF%A1/:1:0","tags":["socket"],"title":"Socket通信","uri":"/socket%E9%80%9A%E4%BF%A1/"},{"categories":["exec函数族","Linux"],"content":"exec函数族介绍 1.exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件 2.exec函数组的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段，堆栈等已经被新的内容取代了，只留下进程ID等表面上的信息仍保持原样，只有调用失败了，它们才会返回-1，从原程序的调用点接着往下执行 ","date":"2023-02-07","objectID":"/exec%E5%87%BD%E6%95%B0%E6%97%8F/:0:0","tags":["C/C++"],"title":"exec函数族","uri":"/exec%E5%87%BD%E6%95%B0%E6%97%8F/"},{"categories":["exec函数族","Linux"],"content":"exec函数族 int execl(const char *pathname, const char arg, … / (char *) NULL */); int execlp(const char *file, const char arg, …/ (char *) NULL */); int execle(const char *pathname, const char arg, …/, (char *) NULL, char *const envp[] */); int execv(const char *pathname, char *const argv[]); int execvp(const char *file, char *const argv[]); int execvpe(const char *file, char *const argv[],char *const envp[]); l(list) 参数地址列表，以空指针结尾 v(vector) 存有各参数地址的指针数组的地址 p(path) 按PATH环境变量指定的目录搜索可执行文件 e(environment) 存有环境变量字符串地址的指针数组的地址 ","date":"2023-02-07","objectID":"/exec%E5%87%BD%E6%95%B0%E6%97%8F/:1:0","tags":["C/C++"],"title":"exec函数族","uri":"/exec%E5%87%BD%E6%95%B0%E6%97%8F/"},{"categories":["进程","Linux"],"content":"进程 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:0:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"查看进程 ps aux/ajx a:显示终端上所有进程，包括其他用户的进程 u:显示进程的详细信息 x:显示没有控制终端的进程 j:列出与作业息息相关的信息 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:1:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"进程相关STAT参数 D 不可中断 R 正在运行，或在队列中的进程 S 休眠状态 T 停止或被追踪 Z 僵尸进程 W 进入内存交换(kneral2.6开始无效) X 死掉的进程 \u003c 高优先级 N 低优先级 s 包含子进程 + 位于前台的进程组 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:2:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"进程相关命令 top 可以再使用top命令上加-G来指定显示信息更新的时间间隔，在top命令执行后，可以按一下按键显示的结果进行排序： M 根据内存使用量排序 P 根据CPU占有率进行排序 T 根据进程运行时间长短排序 U 根据用户名来筛选 K 输入指定的PID杀死线程 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:3:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"杀死进程 kill [-signal] pid kill -l 列出所有信号 kill -SIGKILL 进程ID kill -9 进程ID killall name 根据进程名杀死进程 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:4:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"进程号和相关函数 1.每个进程都由进程号来标识，其类型为pid_t(整型),进程号的范围为0-32767，进程号总是唯一的，但可以重复使用 2.任何进程(除了init进程)都是由另一个进程创建，该进程成为被创建进程的父进程，对于的进程号为父进程号(PPID) 3.进程组是一个或多个进程的集合，他们之间互相关联，进程组可以接受同一终端的各种信号，关联的进程有一个进程组号(PGID)，默认情况下，当前的进程号会当做当前的进程组号 4.进程号和进程组的相关函数 pid_t getpid(void); pid_t getppid(void); pid_t getpgid(void); ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:5:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"孤儿进程 1.父进程允许结束，但是子进程还在运行，这样的进程成为孤儿进程 2.每当出现一个孤儿进程的时候，内存就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。 3.因此孤儿进程并不是什么危害 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:6:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"僵尸进程 1.每个进程结束之后，，都会释放自己地址空间中的用户数据，内核区的pcb没有办法自己去释放需要父进程去释放 2.进程终止时，父进程尚未回收，子进程残留资源(pcb)存放于内核中，变成僵尸进程 3.僵尸进程不可被kill -9杀死 4.这样会导致一个问题 ，父进程不调用wait()或者waitpid()的话，那么保留的那段信息不会被释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的僵尸进程产生，，将因为没有可以使用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:7:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"进程回收 1.在每个进程退出的时候，内核释放进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息，这些信息主要指向控制块PCB的信息 2.父进程可以通过调用wait或者waitpid得到它的退出状态同时彻底清除掉这个进程。 3.wait()和waitpid()函数功能一样，区别在于，wait()函数会阻塞，waitpid()可以设置不阻塞，waitpid()可以指定等待哪个子进程结束。 4.注意 一次wait或waitpid调用只能清理一个子进程，清理多个子进程需要循环 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:8:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"退出信息相关宏函数 WIFEXITED(status) 非0 进程正常退出 WEXITSTATUS(status) 如果宏为真，获取进程退出的状态 WIFSIGNALED(status) 非0 进程异常退出 WTERMSIG(status) 如果上宏为真，获取使进程停止的信号编号 WIFSTOPPED(status) 非0 进程处于暂停 WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号 WIFCONTINUED(status) 非0 进程暂停后已经继续运行 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B/:9:0","tags":["进程"],"title":"进程","uri":"/%E8%BF%9B%E7%A8%8B/"},{"categories":["进程","Linux"],"content":"进程的创建 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/:0:0","tags":["进程"],"title":"进程创建","uri":"/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"},{"categories":["进程","Linux"],"content":"01进程创建 系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建子进程，形成进程树结构模型 #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e pid_t fork(void); 返回值: 成功:子进程中返回0,父进程中返回子进程ID 失败:返回-1; 失败原因: 1.当前系统的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN 2.系统内存不足，这时errno的值为ENOMEM ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/:1:0","tags":["进程"],"title":"进程创建","uri":"/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"},{"categories":["进程","Linux"],"content":"fork()进程创建总结 首先父进程执行到fork的时候会创建子进程，fork后会给父子进程分别返回一个pid号（父进程fork后返回的pid是子进程的pid，子进程的pid为0），此时系统会将父进程的用户区数据和内核数据区拷贝过来生成一个虚拟地址空间供子进程使用，之后，如果没有执行写操作的时候，父子进程共同指向一个虚拟地址空间，但是一旦发生内存写操作，就会生成新的内存空间将父子进程的变量分开，防止内存碰撞。 ","date":"2023-02-05","objectID":"/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/:2:0","tags":["进程"],"title":"进程创建","uri":"/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"},{"categories":["GDB","Linux"],"content":"GDB多进程调试 使用GDB调试的时候，GDB默认只能跟踪一个进程，可以再fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者跟踪子进程，默认跟踪父进程 设置调试父进程或者子进程: set follow-fork–mode [parent (默认)|child] 设置调试模式:set detach-on-fork [on|off] 默认为on,表示调试当前进程的时候，其他的进程可以运行，如果为off，调试当前进程的时候，其他进程会被GDB挂起 查看调试进程:info inferiors 切换当前调试进程: inferior id 使进程脱离GDB调试:detach inferiors id ","date":"2023-02-04","objectID":"/gdb%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95/:0:0","tags":["C/C++"],"title":"GDB多线程调试","uri":"/gdb%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":["GDB","Linux"],"content":"1.什么是GDB ","date":"2023-02-04","objectID":"/gdb/:0:0","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"GDB是由GNU软件系统社区提供的调试工具，同GCC配套组成的一套完整的开发环境，GDB是Linux和许多类Unix系统中的标准开发环境。 一般来说，GDB主要帮助你完成下面四个方面的功能: 1.启动程序，可以按照自定义的要求随心所欲的允许程序 2.可让被调试的程序在所指定的调置的断点处停住 3.可程序被停止住，可以检查此程序中所发生的事 4，可以改变程序，讲一个BUG产生的影响修正从而测试其他BUG ","date":"2023-02-04","objectID":"/gdb/:1:0","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"准备工作 通常，在为调试而编译时，我们会关掉编译器的优化选项(’-o’),并打开调试选项(’-g’)。另外，’-Wall’在尽量不影响程序行为的情况下选项打开所有的warning，也可以发现许多问题，避免一些不必要的BUG gcc -g -Wall program.c -o program ‘-g’ 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件 ","date":"2023-02-04","objectID":"/gdb/:2:0","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"命令 ","date":"2023-02-04","objectID":"/gdb/:3:0","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"启动和退出 gdb 可执行程序 quit ","date":"2023-02-04","objectID":"/gdb/:3:1","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"给程序设置参数/获取设置参数 set args 10 20 show args ","date":"2023-02-04","objectID":"/gdb/:3:2","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"GDB使用帮助 help ","date":"2023-02-04","objectID":"/gdb/:3:3","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"常看当前文件代码 list/l (从默认位置显示) list/l 行号 (从制定的行显示) list/l 函数名(从指定的函数显示) ","date":"2023-02-04","objectID":"/gdb/:3:4","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"查看非当前文件的代码 list/l 文件名:行号 list/l 文件名:函数名 ","date":"2023-02-04","objectID":"/gdb/:3:5","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"设置显示的行数 show list/listsize set list/listsize 行数 ","date":"2023-02-04","objectID":"/gdb/:3:6","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"GDB命令–断点操作 ","date":"2023-02-04","objectID":"/gdb/:4:0","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"设置断点 b/break 行号 b/break 函数名 b/break 文件名:行号 b/break 文件名:函数 ","date":"2023-02-04","objectID":"/gdb/:4:1","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"查看断点 i/info b/break ","date":"2023-02-04","objectID":"/gdb/:4:2","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"删除断点 d/del/delete 断点编号 ","date":"2023-02-04","objectID":"/gdb/:4:3","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"设置断点无效 dis/disable 断点编号 ","date":"2023-02-04","objectID":"/gdb/:4:4","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"断点生效 ena/enable 断点编号 ","date":"2023-02-04","objectID":"/gdb/:4:5","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"设置条件断点(一般用在循环的位置) b/break 10 if i==5 ","date":"2023-02-04","objectID":"/gdb/:4:6","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"GDB命令–调试命令 ","date":"2023-02-04","objectID":"/gdb/:5:0","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"允许GDB程序 start (程序停在第一行) run (遇到断点才停) ","date":"2023-02-04","objectID":"/gdb/:5:1","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"继续允许，到下一个断点停 c/continue ","date":"2023-02-04","objectID":"/gdb/:5:2","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"向下执行一行代码(不会进入函数体) n/next ","date":"2023-02-04","objectID":"/gdb/:5:3","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"变量操作 p/print 变量名 (打印变量值) ptype 变量名 (打印变量类型) ","date":"2023-02-04","objectID":"/gdb/:5:4","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"向下单步调试(遇到函数进入函数体) s/step finish(跳出函数体) ","date":"2023-02-04","objectID":"/gdb/:5:5","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"自动变量操作 display num(自动打印制定变量的值) i/info display undisplay 编号 ","date":"2023-02-04","objectID":"/gdb/:5:6","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["GDB","Linux"],"content":"其他操作 set var 变量名=变量值 until (跳出循环) ","date":"2023-02-04","objectID":"/gdb/:5:7","tags":["C/C++学习"],"title":"GDB调试","uri":"/gdb/"},{"categories":["Linux"],"content":"什么是Makefile 1.一个工程中的源码不计其数，其按照类型，功能，模块分别放在若干个目录中，Makefile文件定义了一系列的规则来制定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile文件就像个Shell脚本一样，也可以执行操作系统命令 2.Makefile带来的好处就是’自动化编译’，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率，make是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令 Makefile文件命名和规则 ","date":"2023-02-03","objectID":"/makefile/:0:0","tags":["脚本"],"title":"Makefile","uri":"/makefile/"},{"categories":["Linux"],"content":"文件命名 makefile 或者Makefile ","date":"2023-02-03","objectID":"/makefile/:1:0","tags":["脚本"],"title":"Makefile","uri":"/makefile/"},{"categories":["Linux"],"content":"Makefile规则 一个Makefile文件中可以有一个或者多个规则 目标 …:依赖 … 命令(Shell 命令) … 目标:最终要生成的文件（伪目标除外） 依赖:生成目标所需要的文件或者目标 命令:通过执行命令对依赖操作生成目标(命令前必须Tal缩进) 工作原理 1.命令在执行之前，需要先检查规则中的依赖是否存在 1.1 如果存在 则执行命令 1.2 如果不存在，向下检查其他规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该条规则的命令 2.检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间 2.1 如果依赖的时间比目标的时间晚，则需要重新生成目标 2.2 如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行 变量 1.自定义变量 变量名=变量值 var=hello 2.预定义变量 AR : 归档维护程序的名称 默认值是ar CC : C编译器的名称 默认值是cc CXX : C++编译器的名称，默认值是g++ $@ : 目标的完整名称 $\u003c : 第一个依赖文件的名称 $^ : 所有的依赖文件 3.获取变量的值 $（变量名） 模式匹配 %.o:%.c -%:通配符，匹配一个字符串 两个%匹配的是同一个字符串 %.c:%.c gcc -c %\u003c -o $@ 函数1 $(wilecard PATTERN..) 功能:获取制定目录下制定类型的文件列表 参数:PATTERN 指的是某个获多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔 返回:得到的若干个文件的文件列表，文件名之间使用空格间隔 例子:$(wildcard .c ./sub/.c) 返回值格式: a.c b.c…. 函数2 $(patsubst ,,) 功能:查找中的单词（单词以’空格’,‘Tab’或‘回车’‘换行‘分割）是否符合模式,如果匹配的话，则以替换 可以包括通配符’%’,表示任意长度的字符串，如果中也包含’%’，那么中的这个’%‘将是中的那个’%‘所代表的的字符串 返回:函数返回被替换过后的字符号串 例子:$(patsubst %.c,%.o,x.c bar.c) 返回格式:x.o bar.o ","date":"2023-02-03","objectID":"/makefile/:2:0","tags":["脚本"],"title":"Makefile","uri":"/makefile/"},{"categories":["C/C++","库"],"content":"01动态库的制作 命名规则 Linux:libxxx.so lib:前缀（固定） xxx:库的名字 自己起 .so:后缀（固定） 在Linux下是一个可执行文件 Windows:libxxx.dll 02动态库的制作: gcc得到.o文件，得到和位置无关的代码 gcc -c -fpic/-fPIC a.c b.c gcc得到动态库 gcc -shared a.o b.o -o libcalc.so 03工作原理 ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:0:0","tags":["C/C++"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["C/C++","库"],"content":"静态库: gcc进行连接时，会把静态库中的代码打包到可执行程序中 ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:1:0","tags":["C/C++"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["C/C++","库"],"content":"动态库: gcc进行连接时，动态库的代码不会被打包到可执行程序中 程序启动之后，动态库会被动态加载到内存中，通过ldd(list dynamic dependencies)命令检查动态库依赖关系 ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:2:0","tags":["C/C++"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["C/C++","库"],"content":"04如何定位共享库文件呢？ 当系统加载可执行代码时，能够知道其所依赖的库的名字，但是还需要知道绝对路径，此时就需要 系统的动态载入器获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的， 它先后搜索elf文件的 DT_RPATH段–\u003e环境变量LD_LIBRARY_PATH–\u003e/etc/ld.so.cache文件列表 –\u003e/lib/./usr/lib目录找到库文件后将其载入到内存 ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:3:0","tags":["C/C++"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["C/C++","库"],"content":"05解决动态库加载失败的问题 只需要在上述的环境变量LD_LIBRARY_PATH或者/etc/ld.so.cache文件列表 或者/lib/./usr/lib目录内，添加需要使用的动态库绝对路径即可 ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:4:0","tags":["C/C++"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["C/C++","库"],"content":"1.在PATH内添加LD_LIBRARY_PATH即可 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:[动态库的绝对路径] 但是由于配置的环境变量是临时的，终端关掉之后再打开就会失效，需要按照用户级别或者root级别配置 ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:4:1","tags":["C/C++"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["C/C++","库"],"content":"2.用户级别配置 在Home下使用vim .bashrc 在最底下添加 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:[动态库的绝对路径] 然后输入 source .bashrc或者 . .bashrc ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:4:2","tags":["C/C++"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["C/C++","库"],"content":"3.系统级别的配置 sudo vim /etc/profile 在最后一行插入export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:[动态库的绝对路径] 记得刷新profile ","date":"2023-02-02","objectID":"/%E5%8A%A8%E6%80%81%E5%BA%93/:4:3","tags":["C/C++"],"title":"动态库","uri":"/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"categories":["C/C++","库"],"content":" 01什么是库 1.库文件是计算机上的一类文件，可以简单的把库文件看成代码仓库，它提供给使用者一些可以直接拿来用的变量，函数，类 2.库是特殊的程序，编写库的程序和编写一般的程序区别不大，只是库不能单独允许 3.库文件有两种，静态库和动态库(共享库)，区别是:静态库在程序的连接阶段被复制到了程序中，动态库在连接阶段没有被复制到程序中，而是在程序运行时由系统加载到内存中供程序使用 4.库的好处:1.代码保密 2.方便部署和分发 02静态库的制作 ","date":"2023-02-02","objectID":"/%E9%9D%99%E6%80%81%E5%BA%93/:0:0","tags":["C/C++"],"title":"静态库","uri":"/%E9%9D%99%E6%80%81%E5%BA%93/"},{"categories":["C/C++","库"],"content":"命名规则； Linux；libxxx.a lib:前缀(固定) xxx:库的名字，自己起 .a :后缀（固定） Window；libxxx.lib 静态库的制作: 1.gcc获得.o文件 2.将.o文件打包。使用 ar工具（archive） ar rcs libxxx.a xxx.o xxx.o r - 将文件插入备存文件中 c - 简历备存文件 s - 索引 ","date":"2023-02-02","objectID":"/%E9%9D%99%E6%80%81%E5%BA%93/:1:0","tags":["C/C++"],"title":"静态库","uri":"/%E9%9D%99%E6%80%81%E5%BA%93/"},{"categories":["C/C++","GCC"],"content":" 什么是GCC 1.GCC原名为GUN C语言编译器 2.GCC是由GNU开发的编程语言编译器 3.GCC不仅支持C的多种方言，也可以区别不同C的标准，可以使用命令行选项控制编译器在翻译源码时应该遵守那个C标准。例如，当使用命令行‘-std=99’启动GCC时，编译器支持C99标准 4.安装命令 sudo apt install gcc g++ 5.查看版本 gcc/g++ -v/–version GCC工作流程 源代码-\u003e预处理后源代码-\u003e汇编代码-\u003e目标代码-\u003e连接并输出 .h—– .i ———–.s .cpp .c 指令 gcc编译选项 说明 -E 预处理制定的源文件，不进行编译 -s 编译制定的源文件，不进行汇编 -c 编译，汇编制定的源文件，但是不进行连接 -o [file1][file2] / [file2] -o [file1] 将文件file2编译成可执行文件file1 -I directory 制定include包含文件的搜索目录 -g 在编译的时候，生成调试信息，该程序可以被调试器调试 -D 在程序编译的时候，制定一个宏 -w 不生成任何警告 -Wal 生成警告信息 -On n的取值范围:0-3 编译器的优化选项的4个级别 -l 在程序编译的时候，使用指定的库 -L 指定编译的时候，搜索的库的路径 -fPIC/fpic 生成与位置无关的代码 -shared 生成共享目标文件，通常用在建立共享库时 -std 制定C方言:如:-std=c99 gcc和g++ ","date":"2023-02-01","objectID":"/gcc/:0:0","tags":["C/C++"],"title":"GCC基础","uri":"/gcc/"},{"categories":["C/C++","GCC"],"content":"gcc 和 g++都是GNU的一个编译器 误区1：gcc只能编译c代码，g++只能编译C++代码。两者都可以 1.1后缀为.c的，gcc会将它当成c程序，而g++当做c++程序 1.2后缀为.cpp的 两则都会认为是c++程序，c++的语法规则更加严谨一些 1.3编译阶段，g++会调用gcc，对c++代码，两者是等价的，但是因为gcc命令 不能自动和C++程序使用的库连接，所以通常用g++完成连接 ","date":"2023-02-01","objectID":"/gcc/:1:0","tags":["C/C++"],"title":"GCC基础","uri":"/gcc/"},{"categories":["C/C++","GCC"],"content":"误区2：gcc不会定义__cplusplus宏，而g++会 2.1 实际上，这个宏只是标志编译器将会把代码按照c还是c++语法解释 ","date":"2023-02-01","objectID":"/gcc/:2:0","tags":["C/C++"],"title":"GCC基础","uri":"/gcc/"},{"categories":["C/C++","GCC"],"content":"误区3：编译只能用gcc，连接只能用g++ 3.1：严格来说，这句话不算错误，但是它会混淆了概念，应该这样说：编译可以用gcc/g++，而连接可以用g++或者gcc -lstdc++ 3.2：gcc命令不能自动和C++程序使用的库连接在一起，所以通常会使用g++来完成连接。但是在编译阶段，g++会自动调用gcc，二者等价 ","date":"2023-02-01","objectID":"/gcc/:3:0","tags":["C/C++"],"title":"GCC基础","uri":"/gcc/"},{"categories":["算法"],"content":"差分数组 如果给你一个包含5000万个元素的数组，然后会有频繁区间修改操作，那什么是频繁的区间修改操作呢？比如让第1个数到第1000万个数每个数都加上1，而且这种操作时频繁的。 此时你应该怎么做？很容易想到的是，从第1个数开始遍历，一直遍历到第1000万个数，然后每个数都加上1，如果这种操作很频繁的话，那这种暴力的方法在一些实时的系统中可能就拉跨了。 因此，今天的主角就出现了——差分数组。 ","date":"2022-11-16","objectID":"/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/:0:0","tags":["差分数组"],"title":"差分数组","uri":"/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"},{"categories":["算法"],"content":"1.定义 差分数组就是与原数组同样大小的数组 原数组记为:a[] 差分数组记为:d[] 公式: 1.i=1时 d[i]=a[i] 2.i\u003e1时,d[i]=a[i]-a[i-1] 恢复公式 a[i]=d[i]+a[i-1] index 0 1 2 3 4 原数组a 1 3 7 5 2 差分d 1 2 4 -2 -3 sum.d 1 3 7 5 2 ","date":"2022-11-16","objectID":"/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/:1:0","tags":["差分数组"],"title":"差分数组","uri":"/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"},{"categories":["算法"],"content":"2.差分数组的应用:区间的快速加减 对区间[L,R]统一加上X,只需要在差分数组d[L]+X,d[R+1]-X即可 例如，对区间[1,3]加3 index 0 1 2 3 4 原数组 1 3 7 5 2 原差分d 1 2 4 -2 -3 减差分 1 5 4 -2 0 还原数组 1 6 10 8 2 ","date":"2022-11-16","objectID":"/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/:2:0","tags":["差分数组"],"title":"差分数组","uri":"/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"},{"categories":["算法"],"content":"1.前缀和 ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:0:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"1.问题 输入一个长度为n的整数数列, 接下来在输入m个询问, 每个询问都输入一对l(left),r(right) ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:1:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"2.输入格式 第一行输入长度n和询问m 第二行包含n个整数 接下来的m行，每行包含两个整数l(left)和r(right)，表示查询区间范围 ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:2:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"3.输出格式 共m行，每行表示一个结果 ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:3:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"4.数据范围 1≤l≤r≤n 1≤n,m≤100000 −1000≤数列中元素的值≤1000 ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:4:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"5.输入样例： 输入n,m : 5 3 输入n个整数 : 2 1 3 6 4 输入询问: 1 2 1 3 2 4 ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:5:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"6.输出样例: 3 6 10 以上是一道最纯粹的前缀和的问题 接下来，讨论一下什么是前缀和 2.什么是前缀和 我们先给出一个数组: 1,2,3,4,5,6,7,8,9 那么这个数组的前缀和即为: 1,3,6,10,15,21,28,36,45 前缀和就是从第1个数到当前数组的区间和 为了更好的了解前缀和 我们把上述内容放入数组中进行表示 数组a[]表示原数组: a[9]={1,2,3,4,5,6,7,8,9}; 数组res[]表示原数组的前缀和数组: res[9]={1,3,6,10,15,21,28,36,45}; 前缀和与原数组之间的代数关系 res[0] = a[0] = 1 res[1] = a[0] + a[1] = 1 + 2 res[2] = a[0] + a[1] + a[2] = 1 + 2 + 3 res[3] = a[0] + a[1] + a[2] + a[3] = 1 + 2 + 3 + 4 ............ res[8] = a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45 res[i-1] = a[0] + a[1] + ....... + a[i-1] (0\u003c=i \u003c 9) ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:6:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"前缀和的计算与输出 int a[9]={1,2,3,4,5,6,7,8,9}; int res[] = new int[a.length]; res[0] = a[0]; for(int i = 1; i \u003c n ; i++){ res[i] = a[i]+res[i-1]; } ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:7:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"前缀和的优势：以(o1)的时间复杂度得到某块区间的总和 那么如何求出某块区间的和呢? 我们用L和R表示区间的左端点和右端点 res[L]和res[R]表示左右端点 res[L]=a[0]+a[1]+a[2]+...+a[L] res[R]=a[0]+a[1]+a[2]+...+a[L]+a[L+1]+a[L+2]+...+a[R] (L\u003c=R) 我们要求的是[L,R]之间的和 即a[L]+a[L+1]+a[L+2]+...+a[R] 即res[R]-res[L-1] ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:8:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["算法"],"content":"问题的解答 #include \u003ciostream\u003e using namespace std; //定义范围 +10为防止数据溢出 const int N = 100010; int n, m; int a[N], s[N]; int main(){ //输入数组范围，查询次数 cin \u003e\u003e n \u003e\u003e m; //计算前缀和数组 for (int i = 1; i \u003c= n; i ++ ) { cin \u003e\u003e a[i], s[i] = s[i - 1] + a[i]; } //遍历查询 while (m -- ){ int l, r; cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c s[r] - s[l - 1] \u003c\u003c endl; } return 0; } ","date":"2022-11-16","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:9:0","tags":["前缀和"],"title":"前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["git使用"],"content":"1.什么是.gitignore 在一些项目中，我们不想让本地仓库的所有文件都上传到远程仓库, 比如:万恶的.DS_Store ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:1:0","tags":["git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["git使用"],"content":"2.使用规则 ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:0","tags":["git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["git使用"],"content":"2.1 注释 # this is .gitignore file. # 以下是忽略的文件 .DS_Store 上述例子中，#开头的就是注释 ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:1","tags":["git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["git使用"],"content":"2.2 忽略特定的后缀 # 忽略后缀为exe的文件 *.exe ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:2","tags":["git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["git使用"],"content":"2.3 忽略整个文件夹 如果我们想要忽略某个路径下文件夹的所有内容 我们可以在该文件夹路径的后面加入/,如下 folder/ ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:3","tags":["git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["git使用"],"content":"2.4 忽略文件和目录 例如:folder 表示忽略folder文件和folder目录 会搜索多级目录，找到所有名为folder的文件 folder ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:4","tags":["git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["git使用"],"content":"2.5 !表示取反 如果我们想要保留src/lib下的man.txt 那么我们可以写下如下内容 !man.txt ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:5","tags":["git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["git使用"],"content":"2.6 glob通配符 常用的通配符 (1) * :可以代表一切的字符串，可以是0个也可以是任意多个字符 (2) ? :匹配除了’/‘以外的任意一个字符 (3) []:匹配多个列表中的字符 例如想要清除所有.txt文件 *.txt 如果想要清除目标文档下的所有.json文件 src/*.json ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:6","tags":["git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["git使用"],"content":"2.7 双星号 斜杠后面紧跟两个连续的星号**,表示多级目录 src/**/folder ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:2:7","tags":["git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["git使用"],"content":"3 其他规则 (1) .gitignore 文件也会上传到远程仓库 (2) 如果本地仓库已被跟踪，那么即使在.gitignore中设置了忽略，也不起作用 ","date":"2022-11-14","objectID":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/:3:0","tags":["git"],"title":"关于.gitignore详解","uri":"/%E5%85%B3%E4%BA%8Egitignore%E8%AF%A6%E8%A7%A3/"},{"categories":["hugo使用"],"content":"使用hugo创建Blog ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:0:0","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.创建流程 ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:0","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.1 下载 hugo //使用homebrew下载hugo brew install hugo ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:1","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.2 快速创建 hugo new site mysite ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:2","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.3 下载主题 //在刚刚创建的mysite/themes文件下打开终端 //LoveIt为当前作者选择的主题 git clone https://github.com/dillonzq/LoveIt.git LoveIt ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:3","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.4 阅读主题demo或者文档 ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:4","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.5 快速创建写作文档 执行以下命令，在mysite/content下创建posts/my-first-post.md文档 hugo new posts/my-first-post.md 按照想要你想要编辑的方式，去改写my-first-post.md文档 在启用drafts参数的条件下开启Hugo内置的服务器。 hugo server -D ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:5","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.6 上传github 在github创建后缀为github.io的仓库 将hugo的baseUrl设置为GitHub仓库的地址 并将主题设置为当前主题 hugo --theme=LoveIt --baseUrl=\"http://zxlkgf.github.io/\" --buildDrafts 再将public文件夹上传到github即可 ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:6","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["hugo使用"],"content":"1.7 hugo基本使用 使用方法: hugo hugo [flags] hugo [command] hugo [command] [flags] 例如 command: new 为你的站点创建新的内容 server 一个高性能的web服务器 节选的 flags: -D, –buildDrafts 包括被标记为draft的文章 -E, –buildExpired 包括已过期的文章 -F, –buildFuture 包括将在未来发布的文章 例子: hugo -D 生成静态文件并包括draft为true的文章 hugo new post/new-content.md 新建一篇文章 hugo new site mysite 新建一个称为mysite的站点 hugo server –buildExpired 启动服务器并包括已过期的文章 ","date":"2022-11-13","objectID":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/:1:7","tags":["hugo"],"title":"创建Blog流程","uri":"/%E4%BD%BF%E7%94%A8hugo%E5%88%9B%E5%BB%BAblog/"},{"categories":["SpringBoot","Mybatis"],"content":"Kaptcha ","date":"2022-10-23","objectID":"/springboot%E9%A1%B9%E7%9B%AE-kaptcha/:0:0","tags":["computerStore"],"title":"SpringBoot项目-Kaptcha","uri":"/springboot%E9%A1%B9%E7%9B%AE-kaptcha/"},{"categories":["SpringBoot","Mybatis"],"content":"1.1 Kaptcha简介 Kaptcha 是一个扩展自simplecaptcha的验证码库，默认情况下，Kaptcha非常易于设置和使用，并且默认输出会产生一个很难验证的验证码。默认情况下，它生成的验证码看起来与上面的非常相似。如果您想更改输出的外观，则有几个配置选项，并且该框架是模块化的，因此您可以编写自己的变形代码。 参考资料:( kaptcha验证码使用) ","date":"2022-10-23","objectID":"/springboot%E9%A1%B9%E7%9B%AE-kaptcha/:1:0","tags":["computerStore"],"title":"SpringBoot项目-Kaptcha","uri":"/springboot%E9%A1%B9%E7%9B%AE-kaptcha/"},{"categories":["SpringBoot","Mybatis"],"content":"1.2 Kaptcha详细配置表 2 Maven依赖 \u003c!-- 验证码 --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003ekaptcha-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.1.0\u003c/version\u003e \u003c/dependency\u003e 3.创建配置类 package com.zxl.store.config; import com.google.code.kaptcha.impl.DefaultKaptcha; import com.google.code.kaptcha.util.Config; import lombok.extern.slf4j.Slf4j; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.Properties; /** * @author zxl * @version 1.0 * @description: kaptcha配置类 * @date 2022/10/30 */ @Slf4j @Configuration public class KaptchaConfig { //kaptcha @Bean public DefaultKaptcha getKaptcheCode() { DefaultKaptcha defaultKaptcha = new DefaultKaptcha(); // 创建properties Properties properties = new Properties(); //是否有边框 NO properties.setProperty(\"kaptcha.border\", \"no\"); //字体颜色 black properties.setProperty(\"kaptcha.textproducer.font.color\", \"black\"); //图片宽度 100 properties.setProperty(\"kaptcha.image.width\", \"100\"); //图片高度 36 properties.setProperty(\"kaptcha.image.height\", \"36\"); //字体大小 30px properties.setProperty(\"kaptcha.textproducer.font.size\", \"30\"); //图片样式 阴影 properties.setProperty(\"kaptcha.obscurificator.impl\", \"com.google.code.kaptcha.impl.ShadowGimpy\"); //session key = code properties.setProperty(\"kaptcha.session.key\", \"code\"); //干扰实现类 properties.setProperty(\"kaptcha.noise.impl\", \"com.google.code.kaptcha.impl.NoNoise\"); //背景渐变颜色 开始颜色 properties.setProperty(\"kaptcha.background.clear.from\", \"232,240,254\"); //背景渐变颜色 结束颜色 properties.setProperty(\"kaptcha.background.clear.to\", \"232,240,254\"); //验证码长度 properties.setProperty(\"kaptcha.textproducer.char.length\", \"4\"); //字体 properties.setProperty(\"kaptcha.textproducer.font.names\", \"彩云,宋体,楷体,微软雅黑\"); //设置参数 Config config = new Config(properties); defaultKaptcha.setConfig(config); return defaultKaptcha; } } 创建控制类 package com.zxl.store.controller; import com.google.code.kaptcha.Constants; import com.google.code.kaptcha.Producer; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import javax.imageio.ImageIO; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.awt.image.BufferedImage; /** * @author zxl * @version 1.0 * @description: kaptcha的控制层,kaptcha调用 * @date 2022/10/30 */ @Slf4j @RestController @RequestMapping(\"/kaptcha\") public class KaptchaController { @Autowired private Producer producer; @GetMapping(\"/kaptcha-image\") public void getKaptchaImage(HttpServletRequest request, HttpServletResponse response) throws Exception { //禁止server缓存 response.setDateHeader(\"Expires\", 0); //设置标准的http/1.1 no-cache headers response.setHeader(\"Cache-Control\", \"no-store, no-cache, must-revalidate\"); // 设置IE扩展 HTTP/1.1 no-cache headers (use addHeader) response.addHeader(\"Cache-Control\", \"post-check=0, pre-check=0\"); // 设置标准 HTTP/1.0 不缓存图片 response.setHeader(\"Pragma\", \"no-cache\"); // 返回一个 jpeg 图片，默认是text/html(输出文档的MIMI类型) response.setContentType(\"image/jpeg\"); // 为图片创建文本 String capText = producer.createText(); // 输出验证码 log.info(\"******************当前验证码为：{}******************\", capText); // 将验证码存于session中 request.getSession().setAttribute(Constants.KAPTCHA_SESSION_KEY, capText); // 创建带有文本的图片 BufferedImage bi = producer.createImage(capText); ServletOutputStream out = response.getOutputStream(); // 向页面输出验证码 ImageIO.write(bi, \"jpg\", out); try { // 清空缓存区 out.flush(); } finally { // 关闭输出流 out.close(); } } } ","date":"2022-10-23","objectID":"/springboot%E9%A1%B9%E7%9B%AE-kaptcha/:2:0","tags":["computerStore"],"title":"SpringBoot项目-Kaptcha","uri":"/springboot%E9%A1%B9%E7%9B%AE-kaptcha/"},{"categories":["SpringBoot","Mybatis"],"content":"AOP ","date":"2022-10-22","objectID":"/springboot%E9%A1%B9%E7%9B%AE-aop/:1:0","tags":["computerStore"],"title":"SpringBoot项目-AOP","uri":"/springboot%E9%A1%B9%E7%9B%AE-aop/"},{"categories":["SpringBoot","Mybatis"],"content":"1 Spring AOP AOP：面向切面（Aspect）编程。AOP并不是Spring框架的特性，只是Spring很好的支持了AOP。 如果需要在处理每个业务时，都执行特定的代码，则可以假设在整个数据处理流程中存在某个切面，切面中可以定义某些方法，当处理流程执行到切面时，就会自动执行切面中的方法。最终实现的效果就是：只需要定义好切面方法，配置好切面的位置（连接点），在不需要修改原有数据处理流程的代码的基础之上，就可以使得若干个流程都执行相同的代码。 ","date":"2022-10-22","objectID":"/springboot%E9%A1%B9%E7%9B%AE-aop/:1:1","tags":["computerStore"],"title":"SpringBoot项目-AOP","uri":"/springboot%E9%A1%B9%E7%9B%AE-aop/"},{"categories":["SpringBoot","Mybatis"],"content":"2 切面方法 1.切面方法的访问权限是public。 2.切面方法的返回值类型可以是void或Object，如果使用的注解是@Around时，必须使用Object作为返回值类型，并返回连接点方法的返回值；如果使用的注解是@Before或@After等其他注解时，则自行决定。 3.切面方法的名称可以自定义。 4.切面方法的参数列表中可以添加ProceedingJoinPoint接口类型的对象，该对象表示连接点，也可以理解调用切面所在位置对应的方法的对象，如果使用的注解是@Around时，必须添加该参数，反之则不是必须添加。 ","date":"2022-10-22","objectID":"/springboot%E9%A1%B9%E7%9B%AE-aop/:1:2","tags":["computerStore"],"title":"SpringBoot项目-AOP","uri":"/springboot%E9%A1%B9%E7%9B%AE-aop/"},{"categories":["SpringBoot","Mybatis"],"content":"3 统计业务方法执行时长 1.在使用Spring AOP编程时，需要先在pom.xml文件中添加两个关于AOP的依赖aspectjweaver和aspectjtools。 \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjtools\u003c/artifactId\u003e \u003c/dependency\u003e 2.在com.cy.store.aop包下创建TimerAspect切面类，在类之前添加@Aspect和@Component注解修饰。 package com.cy.store.aop; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.stereotype.Component; @Aspect @Component public class TimerAspect { } 3.在类中添加切面方法around(ProceedingJoinPoint pjp)。 public Object around(ProceedingJoinPoint pjp) throws Throwable { // 记录起始时间 long start = System.currentTimeMillis(); // 执行连接点方法，即切面所在位置对应的方法。本项目中表示执行注册或执行登录等 Object result = pjp.proceed(); // 记录结束时间 long end = System.currentTimeMillis(); // 计算耗时 System.err.println(\"耗时：\" + (end - start) + \"ms.\"); // 返回连接点方法的返回值 return result; } 4.最后需要在方法之前添加@Around注解，以配置连接点，即哪些方法需要应用该切面。 @Around(\"execution(* com.zxl.store.service.impl.*.*(..))\") 5.启动项目，在前端浏览器访问任意一个功能模块进行功能的测试。 ","date":"2022-10-22","objectID":"/springboot%E9%A1%B9%E7%9B%AE-aop/:1:3","tags":["computerStore"],"title":"SpringBoot项目-AOP","uri":"/springboot%E9%A1%B9%E7%9B%AE-aop/"},{"categories":["SpringBoot","Mybatis"],"content":"9 商品搜索 ","date":"2022-10-20","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/:1:0","tags":["computerStore"],"title":"SpringBoot项目-商品搜索","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/"},{"categories":["SpringBoot","Mybatis"],"content":"9.1 关于商品的模糊搜索 9.1.1 后端-持久层 1.编写sql SELECT id,title,sell_point,price,image FROM t_product WHERE STATUS = 1 AND title LIKE '%${title}%' ORDER BY priority DESC; 2.编写Mapper接口的抽象方法 /** * 按照输入的标题查找 * @param title * @return */ List\u003cProduct\u003e findProductByTitle(String title); 3.编写Mapper接口的映射文件 \u003c!-- List\u003cProduct\u003e findProductByTitle(String title);--\u003e \u003cselect id=\"findProductByTitle\" resultType=\"com.zxl.store.entity.Product\"\u003e SELECT id,title,sell_point,price,image FROM t_product WHERE STATUS = 1 AND title LIKE '%${title}%' ORDER BY priority DESC \u003c/select\u003e ","date":"2022-10-20","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/:1:1","tags":["computerStore"],"title":"SpringBoot项目-商品搜索","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/"},{"categories":["SpringBoot","Mybatis"],"content":"9.1.2 后端-业务层 1.处理异常 2.编写业务层抽象方法 /** * 按照标题查询 * @param title * @param pageNum * @param pageSize * @return */ PageInfo\u003cProduct\u003e findProductByTitle(String title,Integer pageNum, Integer pageSize); 3.编写业务层逻辑 @Override public PageInfo\u003cProduct\u003e findProductByTitle(String title, Integer pageNum, Integer pageSize) { //开启分页功能 PageHelper.startPage(pageNum,pageSize); //查询结果 List\u003cProduct\u003e res = productMapper.findProductByTitle(title); //返回结果 return new PageInfo\u003c\u003e(res); } ","date":"2022-10-20","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/:1:2","tags":["computerStore"],"title":"SpringBoot项目-商品搜索","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/"},{"categories":["SpringBoot","Mybatis"],"content":"9.1.3 后端-控制层 1.处理异常 2.设计请求 请求路径：/product/findWithTitle 请求参数：Integer pageNum，Integer pageSize，String title 请求类型：get 响应类型：JsonResult\u003cPageInfo\u003c Product» 3.处理请求，编写控制层方法 @RequestMapping(value = \"/{pageNum}/{pageSize}/{title}\",method = RequestMethod.GET) public JsonResult\u003cPageInfo\u003cProduct\u003e\u003e findWithTitle(@PathVariable(\"pageNum\") Integer pageNum, @PathVariable(\"pageSize\") Integer pageSize, @PathVariable(\"title\") String title){ PageInfo\u003cProduct\u003e res = productService.findProductByTitle(title, pageNum, pageSize); return new JsonResult\u003c\u003e(OK,res); } 4.前端页面 具体请参考github \u003cscript type=\"text/javascript\"\u003e //获取标题 var title = getOne(); title = title.substring(0,title.indexOf(\"\u0026\")); function getUrlParam(name) { var reg = new RegExp(\"(^|\u0026)\" + name + \"=([^\u0026]*)(\u0026|$)\"); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null; } var num = getUrlParam(\"pageNum\"); //为了查询设置的全局参数 var pageNum = 0; var pageSize = 0; var prePage = 0; var nextPage = 0; var navigatepageNums = []; //记录fid var fid = 0; //根据分页条的选择的页数进行查询 function PaginationListSelect(num,size,res) { //进行查询的关键字 let title = $(\"#search\").val() llocation.href = \"/web/search.html?title=\" + title + \"\u0026pageNum=\" + num + \"\u0026pageSize=\" + size; //填充分页条信息 addPaginationData(res); } //按照标题查询数据 function searchByTitle(pageNum,pageSize,title){ $.ajax({ url:\"/product/\" + pageNum + \"/\" + pageSize + \"/\" + title, dataType:\"json\", success:function (res) { if(res.state==200){ if(res.data.list.length!=0){ $(\"#resultTest\").html(\"\\\"\"+ title + \"\\\"\"); addData(res); }else{ $(\"#resultTest\").html(\"\\\"\"+ title + \"\\\"\"); $(\"#errmsg\").html(\"目前该商品并不在库\"); } } } }); } //填充数据 function addData(res){ //清空目标内容 $(\"#productList\").empty(); $(\"#PaginationList\").empty(); let productListStr = \"\"; //获取分页信息中商品的长度 let dataLength = res.data.list.length; //填充商品到信息页面 for (let i = 0; i \u003c dataLength; i++) { let product = res.data.list[i] productListStr = \"\u003cdiv class=\\\"col-md-3\\\"\u003e\" + \"\u003cdiv class=\\\"goods-panel\\\"\u003e\" + \"\u003cimg src=..\" + product.image + \"collect.png\" + \" class=\\\"img-responsive\\\" /\u003e\" + \"\u003cp\u003e￥\" + product.price + \".00\" + \"\u003c/p\u003e\" + \"\u003cdiv class=\\\"text-row-3\\\"\u003e\" + \"\u003ca href=product.html?pid=\" + product.id + \"\u003e\u003csmall\u003e\" + product.title + \"\u003c/small\u003e\u003c/a\u003e\u003c/div\u003e\" + \"\u003cspan style='padding-right: 10px'\u003e\" + \"\u003ca href='javascript:void(0)' onclick='addToCollect(#{id})' id='product#{num}' class='btn btn-default btn-xs add-fav'\u003e\u003cspan class='fa fa-heart-o'\u003e\u003c/span\u003e加入收藏\u003c/a\u003e\" + \"\u003c/span\u003e\" + \"\u003cspan style='padding-right: 10px'\u003e\" + \"\u003ca href='javascript:void(0)' onclick='addCollectToCart(#{id},#{price})' class=\\\"btn btn-default btn-xs add-cart\\\"\u003e\u003cspan class=\\\"fa fa-cart-arrow-down\\\"\u003e\u003c/span\u003e加入购物车\u003c/a\u003e\" + \"\u003c/span\u003e\u003c/div\u003e\u003c/div\u003e\" productListStr = productListStr.replaceAll(\"#{id}\",product.id); productListStr = productListStr.replaceAll(\"#{price}\",product.price); $(\"#productList\").append(productListStr) } //填充分页条信息 addPaginationData(res); } //填充分页条信息 function addPaginationData(res) { //重新填充分页条 //将数据返回的部分需要数据进行填充至全局参数 pageNum = res.data.pageNum //当前页 pageSize = res.data.pageSize //每页显示数 prePage = res.data.prePage //上一页 nextPage = res.data.nextPage //下一页 navigatepageNums = res.data.navigatepageNums //分页栏的数字 let firstPage = \"\u003ca id='first' href='#' onclick='PaginationListSelect(prePage,pageSize)' style='padding-right: 8px'\u003e上一页\u003c/a\u003e\" let lastPage = \"\u003ca id='end' href='javascript:void(0)' onclick='PaginationListSelect(nextPage,pageSize)' style='padding-right: 8px'\u003e下一页\u003c/a\u003e\" let PaginationListStr = \"\"; //判断是否是第一页 if (res.data.isFirstPage){ //为true表示当前是第一页 firstPage = \"\u003ca id='first' href='javascript:void(0)' \" + \"style='opacity: 0.2;padding-right: 8px;color: black'\u003e上一页\u003c/a\u003e\" PaginationListStr += firstPage; }else { //为false表示当前不是第一页 PaginationListStr += firstPage; } //填充分页的页码数 for (let i = 0; i \u003c navigatepageNums.length; i++) { //当前页的页码 let nowNum = navigatepageNums[i] if (nowNum === pageNum){ //相等表示i的次数和当前也相同，对页数显示做变化 PaginationListStr += \"\u003ca href='javascript:void(0)' \" + \"style='padding-right: 8px;color: black' disabled='disabled'\u003e\" + \"【\" + nowNum + \"","date":"2022-10-20","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/:1:3","tags":["computerStore"],"title":"SpringBoot项目-商品搜索","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2/"},{"categories":["SpringBoot","Mybatis"],"content":"分页插件学习 1.github:https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md 2.CSDN:https://blog.csdn.net/m0_48736673/article/details/124805124 ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:0:0","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"1.使用步骤 ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:1:0","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"1.在pom.xml添加如下依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.github.pagehelper\u003c/groupId\u003e \u003cartifactId\u003epagehelper-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e最新版本\u003c/version\u003e \u003c!--\u003cversion\u003e1.2.3\u003cversion\u003e--\u003e \u003c/dependency\u003e ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:1:1","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"2.在springboot中添加部分配置 在application.properties中添加配置 #pagehelper配置 pagehelper.helper-dialect=mysql pagehelper.reasonable=true pagehelper.support-methods-arguments=true pagehelper.params=count=countSql ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:1:2","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"3.注册一个PageHelper类 @Bean public PageHelper pageHelper() { PageHelper pageHelper = new PageHelper(); Properties properties = new Properties(); properties.setProperty(\"offsetAsPageNum\", \"true\"); properties.setProperty(\"rowBoundsWithCount\", \"true\"); properties.setProperty(\"reasonable\", \"true\"); properties.setProperty(\"dialect\", \"mysql\"); pageHelper.setProperties(properties); return pageHelper; } ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:1:3","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"4.业务层或者需要使用的层设置开启 @Override public PageInfo\u003cFavorite\u003e findFavorite(Integer uid, Integer pageNum, Integer pageSize) { //开启分页功能 //pageNum是当前页,pageSize是每页显示的数据量 PageHelper.startPage(pageNum,pageSize); // List\u003cFavorite\u003e favorites = favoriteMapper.findFavoritesByUidAndStatus(uid, 1); // PageInfo\u003cFavorite\u003e pageInfo = new PageInfo\u003c\u003e(favorites); return pageInfo; } ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:1:4","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"5.控制层返回查询结果即可 @RequestMapping(value = \"/findFavorites\",method = RequestMethod.GET) public JsonResult\u003cPageInfo\u003cFavorite\u003e\u003e findFavorites(HttpSession session, Integer pageNum, Integer pageSize){ Integer uid = getUserIdFromSession(session); PageInfo\u003cFavorite\u003e favorites = favoriteService.findFavorite(uid, pageNum, pageSize); return new JsonResult\u003c\u003e(OK,favorites); } ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:1:5","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"部分参数的解释 1.dialect：默认情况下会使用 PageHelper 方式进行分页， 如果想要实现自己的分页逻辑,可以实现 Dialect(com.github.pagehelper.Dialect)接口 然后配置该属性为实现类的全限定名称。 2.reasonable:分页合理化参数，默认值为false。当该参数设置为true时， pageNum\u003c=0 时会查询第一页,pageNum\u003epages（超过总数时),会查询最后一页。 默认false时，直接根据参数进行查询。 ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:2:0","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"pageInfo参数大全 //当前页 private int pageNum; //每页的数量 private int pageSize; //当前页的数量 private int size; //由于startRow和endRow不常用，这里说个具体的用法 //可以在页面中\"显示startRow到endRow 共size条数据\" //当前页面第一个元素在数据库中的行号 private int startRow; //当前页面最后一个元素在数据库中的行号 private int endRow; //总记录数 private long total; //总页数 private int pages; //结果集(每页显示的数据) private List\u003cT\u003e list; //第一页 private int firstPage; //前一页 private int prePage; //是否为第一页 private boolean isFirstPage = false; //是否为最后一页 private boolean isLastPage = false; //是否有前一页 private boolean hasPreviousPage = false; //是否有下一页 private boolean hasNextPage = false; //导航页码数 private int navigatePages; //导航页第一页 private int navigateFirstPage; //导航页第二页 private int navigateLastPage; //所有导航页号 private int[] navigatepageNums; ","date":"2022-10-19","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/:2:1","tags":["computerStore"],"title":"SpringBoot项目-分页插件","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"},{"categories":["SpringBoot","Mybatis"],"content":"8 收藏管理 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:0:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.1 创建实体类 CREATE TABLE t_favorites( fid INT PRIMARY KEY AUTO_INCREMENT COMMENT '收藏商品在数据表的id', uid INT COMMENT '归属的用户id', pid INT COMMENT '归属的商品id', image VARCHAR(255) COMMENT '商品图片保存地址', price BIGINT COMMENT '商品的价格', title VARCHAR(255) COMMENT '商品的标题', sell_point VARCHAR(255) COMMENT '商品的卖点', status INT COMMENT '商品的状态' ); ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:1:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.2 创建实体类 /** * @author zxl * @description 收藏实体类 * @date 2022/11/6 */ @Data @AllArgsConstructor @NoArgsConstructor public class Favorite extends BaseEntity { private Integer fid; private Integer uid; private Integer pid; private String image; private Long price; private String title; private String sellPoint; private Integer status; } ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:2:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.3 加入收藏 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:3:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.3.1 后端-持久层 1.编写sql //插入收藏 insert into t_favorite(除了fid)values(值) //判断是否存在该收藏 SELECT * FROM t_favorite WHERE uid = ? AND pid = ? 2.编写Mapper接口 /** * 根据pid和uid查询收藏商品是否在库 * @param uid * @param pid * @return */ Favorite findFavoriteByPidAndUid(Integer uid,Integer pid); /** * 插入收藏 * @param favorite 收藏数据 * @return */ Integer addFavorite(Favorite favorite); 3.编写映射文件 \u003cmapper namespace=\"com.zxl.store.mappers.FavoriteMapper\"\u003e \u003c!-- Integer addFavorite(Favorite favorite);--\u003e \u003cinsert id=\"addFavorite\" parameterType=\"com.zxl.store.entity.Favorite\" useGeneratedKeys=\"true\" keyProperty=\"fid\"\u003e INSERT INTO t_favorite( uid, pid, image, price, title, sell_point, status ) VALUES ( #{uid}, #{pid}, #{image}, #{price}, #{title}, #{sellPoint}, #{status} ) \u003c/insert\u003e \u003c!-- Favorite findFavoriteByPidAndUid(Integer uid,Integer pid);--\u003e \u003cselect id=\"findFavoriteByPidAndUid\" resultType=\"com.zxl.store.entity.Favorite\"\u003e SELECT * FROM t_favorite WHERE uid = #{uid} AND pid = #{pid} \u003c/select\u003e \u003c/mapper\u003e 4.单元测试 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:3:1","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.3.2 后端-业务层 1.编写异常 //收藏已经存在异常 public class FavoriteExistException extends ServiceException {} 2.编写业务层抽象方法 /** * @author zxl * @description 收藏业务层的接口 * @date 2022/11/6 */ public interface IFavoriteService { /** * 插入收藏 * @param uid * @param pid */ Integer addFavorite(Integer uid,Integer pid); } 3.编写实现逻辑 /** * @author zxl * @description 收藏接口的业务层实现类 * @date 2022/11/6 */ @Service public class IFavoriteServiceImpl implements IFavoriteService { @Autowired(required = false) private FavoriteMapper favoriteMapper; @Autowired private IProductService productService; @Override public Integer addFavorite(Integer uid, Integer pid) { //先判断是否已经存在收藏 Favorite res = favoriteMapper.findFavoriteByPidAndUid(uid, pid); //判断结果 if(res!=null){ throw new FavoriteExistException(\"该收藏品已经存在！\"); } //商品不存在的话，执行下一步 Favorite favorite = new Favorite(); //根据pid查询信息 Product p = productService.findProductById(pid); //加入数据 favorite.setUid(uid); favorite.setPid(pid); favorite.setImage(p.getImage()); favorite.setPrice(p.getPrice()); favorite.setTitle(p.getTitle()); favorite.setSellPoint(p.getSellPoint()); favorite.setStatus(p.getStatus()); //执行插入 Integer row = favoriteMapper.addFavorite(favorite); //判断插入结果 if(row!=1)throw new InsertException(\"插入收藏时出现未知错误\"); System.out.println(favorite.getFid()); return favorite.getFid(); } } 4.单元测试 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:3:2","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.3.3 后端-控制层 1.处理异常 将异常交给全局处理 2.设计请求 请求路径：/favorite/addFavorite 请求类型：HttpSession session,Integer pid 请求方式：post 响应类型：JsonResult\u003c Integer\u003e 3.处理请求编写控制类 /** * @author zxl * @description 添加收藏的控制类 * @date 2022/11/6 */ @RestController @RequestMapping(\"/favorite\") public class FavoriteController extends BaseController { @Autowired private IFavoriteService favoriteService; @RequestMapping(value = \"/addFavorite\",method = RequestMethod.POST) public JsonResult\u003cInteger\u003e addFavorite(Integer pid, HttpSession session){ //uid Integer uid = getUserIdFromSession(session); //执行插入 Integer fid = favoriteService.addFavorite(uid, pid); return new JsonResult\u003c\u003e(OK,fid); } } 4.前端页面 //绑定收藏事件 $(\"#btn-add-to-collect\").click(function () { if (confirm(\"确定要将此商品加入收藏吗？\")) { $.ajax({ url: \"/favorite/addFavorite\", type: \"post\", data: {\"pid\": pid}, dataType: \"json\", success: function (res) { if (res.state == 200) { alert(\"收藏成功！\"); } else { alert(res.message); } }, error: function (err) { alert(\"服务器出现错误，加入购物车失败！\") } }) } }); ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:3:3","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.4 显示收藏 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:4:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.4.1 后端-持久层 1.编写sql //根据用户uid和收藏商品的状态去查找 SELECT * FROM t_favorite WHERE uid = #{uid} AND status=#{status} 2.编写Mapper接口抽象方法 /** * 按照uid和status查找用户的收藏列表 * @param uid 用户的id * @param status 商品状态 * @return 返回结果集合 */ List\u003cFavorite\u003e findFavoritesByUidAndStatus(Integer uid,Integer status); 3.编写映射文件 \u003c!-- List\u003cFavorite\u003e findFavoritesByUidAndStatus(Integer uid,Integer status);--\u003e \u003cselect id=\"findFavoritesByUidAndStatus\"\u003e SELECT * FROM t_favortie WHERE uid = #{uid} AND status = 1; \u003c/select\u003e 4.单元测试 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:4:1","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.4.2 后端-业务层 1.编写异常 2.编写业务层抽象方法 /** * 查找指定条件的收藏 * @param uid 用户uid * @param pageNum 当前页码 * @param pageSize 每页数据多少 * @return */ PageInfo\u003cFavorite\u003e findFavorite(Integer uid, Integer pageNum, Integer pageSize); 3.编写实现逻辑 @Override public PageInfo\u003cFavorite\u003e findFavorite(Integer uid, Integer pageNum, Integer pageSize) { //开启分页功能 //pageNum是当前页,pageSize是每页显示的数据量 PageHelper.startPage(pageNum,pageSize); // List\u003cFavorite\u003e favorites = favoriteMapper.findFavoritesByUidAndStatus(uid, 1); // PageInfo\u003cFavorite\u003e pageInfo = new PageInfo\u003c\u003e(favorites); return pageInfo; } 4.单元测试 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:4:2","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.4.3 后端-控制层 1.处理异常 2.设计请求 请求路径：/favorite/findFavorites 请求类型：HttpSession session,Integer pageNum,Integer pageSize 请求方式：get 响应类型：JsonResult 3.处理请求 编写控制方法 //查询 @RequestMapping(value = \"/findFavorites\",method = RequestMethod.GET) public JsonResult\u003cPageInfo\u003cFavorite\u003e\u003e findFavorites(HttpSession session, Integer pageNum, Integer pageSize){ Integer uid = getUserIdFromSession(session); PageInfo\u003cFavorite\u003e favorites = favoriteService.findFavorite(uid, pageNum, pageSize); return new JsonResult\u003c\u003e(OK,favorites); } 4.前端页面 \u003cscript type=\"text/javascript\"\u003e //为了查询设置的全局参数 var pageNum = 0; var pageSize = 0; var prePage = 0; var nextPage = 0; var navigatepageNums = []; //根据分页条的选择的页数进行查询 function PaginationListSelect(num,size) { showCollectProduct(num,size) } function addDataToList(res) { //在填充数据之前必须先将这两个div标签内的所有元素情况，不然会出现叠加情况 $(\"#collectList\").empty(); $(\"#PaginationList\").empty(); let collectListStr = \"\"; //获取分页数据中的数据数量 let dataLength = res.data.list.length; //填充商品到页面 for(let i = 0;i\u003cdataLength;i++){ let favorite = res.data.list[i]; collectListStr = \"\u003cdiv class=\\\"col-md-3\\\"\u003e\" + \"\u003cdiv class=\\\"goods-panel\\\"\u003e\" + \"\u003cimg src=..\" + favorite.image + \"collect.png\" + \" class=\\\"img-responsive\\\" /\u003e\" + \"\u003cp\u003e￥\" + favorite.price + \".00\" + \"\u003c/p\u003e\" + \"\u003cdiv class=\\\"text-row-3\\\"\u003e\" + \"\u003ca href=product.html?pid=\" + favorite.pid + \"\u003e\u003csmall\u003e\" + favorite.title + \"\u003c/small\u003e\u003c/a\u003e\u003c/div\u003e\" + \"\u003cspan style='padding-right: 10px'\u003e\" + \"\u003ca href='javascript:void(0)' onclick='CancelCollect(#{fid})' class='btn btn-default btn-xs add-fav'\u003e\u003cspan class='fa fa-heart'\u003e\u003c/span\u003e取消收藏\u003c/a\u003e\" + \"\u003c/span\u003e\" + \"\u003cspan style='padding-right: 10px'\u003e\" + \"\u003ca href='javascript:void(0)' onclick='addCollectToCart(#{pid},#{price})' class=\\\"btn btn-default btn-xs add-cart\\\"\u003e\u003cspan class=\\\"fa fa-cart-arrow-down\\\"\u003e\u003c/span\u003e加入购物车\u003c/a\u003e\" + \"\u003c/span\u003e\u003c/div\u003e\u003c/div\u003e\"; collectListStr = collectListStr.replaceAll(\"#{fid}\",favorite.fid); collectListStr = collectListStr.replaceAll(\"#{pid}\",favorite.pid); collectListStr = collectListStr.replaceAll(\"#{price}\",favorite.price); $(\"#collectList\").append(collectListStr); } //重新填充分页条 // 将数据返回的部分需要数据进行填充至全局参数 pageNum = res.data.pageNum; //当前页 pageSize = res.data.pageSize; //每页显示数 prePage = res.data.prePage; //上一页 nextPage = res.data.nextPage; //下一页 navigatepageNums = res.data.navigatepageNums;//分页栏的数字 let firstPage = \"\u003ca id='first' href='#' onclick='PaginationListSelect(prePage,pageSize)' style='padding-right: 8px'\u003e上一页\u003c/a\u003e\"; let lastPage = \"\u003ca id='end' href='javascript:void(0)' onclick='PaginationListSelect(nextPage,pageSize)' style='padding-right: 8px'\u003e下一页\u003c/a\u003e\"; let PaginationListStr = \"\"; //判断是否是第一页 if (res.data.isFirstPage){ //为true表示当前是第一页 firstPage = \"\u003ca id='first' href='javascript:void(0)' \" + \"style='opacity: 0.2;padding-right: 8px;color: black'\u003e上一页\u003c/a\u003e\"; PaginationListStr += firstPage; }else { //为false表示当前不是第一页 PaginationListStr += firstPage; } //填充分页的页码数 for (let i = 0; i \u003c navigatepageNums.length; i++) { //当前页的页码 let nowNum = navigatepageNums[i]; if (nowNum === pageNum){ //相等表示i的次数和当前也相同，对页数显示做变化 PaginationListStr += \"\u003ca href='javascript:void(0)' \" + \"style='padding-right: 8px;color: black' disabled='disabled'\u003e\" + \"【\" + nowNum + \"】\" +\"\u003c/a\u003e\" }else { PaginationListStr += \"\u003ca href='javascript:void(0)' onclick='PaginationListSelect(#{nowNum},pageSize)' \" + \"style='padding-right: 8px'\u003e\" + nowNum +\"\u003c/a\u003e\" } PaginationListStr = PaginationListStr.replaceAll(\"#{nowNum}\",nowNum) } //判断是否是末页 if (!res.data.isLastPage){ //取反为false表示当前是末页 PaginationListStr += lastPage; }else { //为true表示当前是末页 lastPage = \"\u003ca id='end' href='javascript:void(0)' style='opacity: 0.2;padding-right: 8px;color: black'\u003e下一页\u003c/a\u003e\" PaginationListStr += lastPage; } //将拼接的str串插入指定id处 $(\"#PaginationList\").append(PaginationListStr); } function showCollectProduct(num,size){ $.ajax({ url: \"/favorite/findFavorites\", type: \"get\", data: \"pageNum=\" + num + \"\u0026pageSize=\" + size, dataType: \"json\", success: function (res) { if(res.data.list.length !== 0){ //代表有数据 //从showPageDataIntoHtml.js中导入的方法 addDataToList(res) }else { //代表没数据 alert(\"暂无收藏商","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:4:3","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.5 删除收藏 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:5:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.5.1 后端-持久层 1.编写sql //取消收藏 DELETE FROM t_favorite WHERE fid = #{fid} 2.编写Mapper抽象方法 /** * 删除收藏 * @param fid 收藏id * @return */ Integer deleteCollect(Integer fid); 3.编写Mapper映射 \u003c!-- Integer deleteCollect(Integer fid);--\u003e \u003cdelete id=\"deleteCollect\"\u003e DELETE FROM t_favorite WHERE fid = #{fid} \u003c/delete\u003e 4.单元测试 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:5:1","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.5.2 后端-业务层 1.编写异常 删除异常已经定义 2.编写业务层抽象方法 /** * 删除收藏 * @param fid */ void deleteCollect(Integer fid); 3.编写实现逻辑 @Override public void deleteCollect(Integer fid) { Integer row = favoriteMapper.deleteCollect(fid); if(row!=1)throw new DeleteException(\"删除收藏是出现错误\"); } 4.单元测试 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:5:2","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.5.3 后端-控制层 1.处理异常 2.设计请求 请求路径：/favorite/cancelFavorite 请求类型：Integer fid 请求方式：post 响应类型：JsonResult 3.处理请求 编写控制方法 //删除 @RequestMapping(value = \"/cancelFavorite\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e cancelFavorite (Integer fid){ favoriteService.deleteCollect(fid); return new JsonResult\u003c\u003e(OK); } 4.前端页面 //取消收藏 function CancelCollect(fid) { if(confirm(\"确定取消收藏吗？\")){ $.ajax({ url:\"/favorite/cancelFavorite\", type: \"POST\", data:{\"fid\":fid}, dataType: \"json\", success:function (res) { if(res.state == 200){ alert(\"取消收藏成功\"); location.reload(); }else{ alert(\"取消收藏失败\"); } } }); } } ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:5:3","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.6 加入购物车 已经被实现，只需要调用即可 ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:6:0","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"8.6.1 前端页面 //加入购物车功能 function addCollectToCart(pid,price){ if (confirm(\"确定要将此商品加入购物车吗？\")){ $.ajax({ url: \"/cart/addCart\", type: \"post\", data: {pid:pid,price:price,num:1}, dataType: \"json\", success: function (res) { alert(\"已成功加入购物车，在购物车等您结算哟！\") }, error : function (err) { alert(\"服务器出现错误，加入购物车失败！\") } }) } } ","date":"2022-10-18","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/:6:1","tags":["computerStore"],"title":"SpringBoot项目-收藏管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E6%94%B6%E8%97%8F%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"订单管理 ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:0:0","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"7.1 创建数据表 CREATE TABLE t_order ( oid INT AUTO_INCREMENT COMMENT '订单id', uid INT NOT NULL COMMENT '用户id', aid INT NOT NULL COMMENT '收货地址id', recv_name VARCHAR(20) NOT NULL COMMENT '收货人姓名', recv_phone VARCHAR(20) COMMENT '收货人电话', recv_province VARCHAR(15) COMMENT '收货人所在省', recv_city VARCHAR(15) COMMENT '收货人所在市', recv_area VARCHAR(15) COMMENT '收货人所在区', recv_address VARCHAR(50) COMMENT '收货详细地址', total_price BIGINT COMMENT '总价', status INT COMMENT '状态：0-未支付，1-已支付，2-已取消，3-已关闭，4-已完成', order_time DATETIME COMMENT '下单时间', pay_time DATETIME COMMENT '支付时间', created_user VARCHAR(20) COMMENT '创建人', created_time DATETIME COMMENT '创建时间', modified_user VARCHAR(20) COMMENT '修改人', modified_time DATETIME COMMENT '修改时间', PRIMARY KEY (oid) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE t_order_item ( id INT AUTO_INCREMENT COMMENT '订单中的商品记录的id', oid INT NOT NULL COMMENT '所归属的订单的id', pid INT NOT NULL COMMENT '商品的id', title VARCHAR(100) NOT NULL COMMENT '商品标题', image VARCHAR(500) COMMENT '商品图片', price BIGINT COMMENT '商品价格', num INT COMMENT '购买数量', created_user VARCHAR(20) COMMENT '创建人', created_time DATETIME COMMENT '创建时间', modified_user VARCHAR(20) COMMENT '修改人', modified_time DATETIME COMMENT '修改时间', PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:1:0","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"7.2 创建实体类 /** * @author zxl * @description t_order表对应的实体类 * @date 2022/11/6 */ @Data @AllArgsConstructor @NoArgsConstructor public class Order extends BaseEntity{ private Integer oid; private Integer uid; private Integer aid; private String recvName; private String recvPhone; private String recvProvince; private String recvCity; private String recvArea; private String recvAddress; private Long totalPrice; private Integer status; private Date orderTime; private Date payTime; } /** * @author zxl * @description t_order_item表对应的实体类 * @date 2022/11/6 */ public class OrderItem extends BaseEntity { private Integer id; private Integer oid; private Integer pid; private String title; private String image; private Long price; private Integer num; } ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:2:0","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"7.3 创建订单 ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:3:0","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"7.3.1 后端-持久层 1.编写sql //在t_order表中插入数据 INSERT INTO t_order(oid除外)VALUES(字段的值) //在t_order_item中插入数据 INSERT INTO t_order_item (id除外)VALUES(字段的值) 2.编写Mapper接口的抽象方法 /** * @author zxl * @description 订单类的Mapper接口 * @date 2022/11/6 */ public interface OrderMapper { /** * 插入order * @param order 订单数据 * @return */ Integer insertOrder(Order order); /** * 插入order_item数据 * @param orderItem * @return */ Integer insertOrderItem(OrderItem orderItem); } 3.编写Mapper接口的映射文件 \u003cmapper namespace=\"com.zxl.store.mappers.OrderMapper\"\u003e \u003c!-- Integer insertOrder(Order order);--\u003e \u003cinsert id=\"insertOrder\" useGeneratedKeys=\"true\" keyProperty=\"oid\"\u003e insert into t_order(uid,aid,recv_name,recv_phone,recv_province, recv_city,recv_area,recv_address, total_price,status,order_time,pay_time, created_user,created_time,modified_user,modified_time) values( #{uid},#{aid},#{recvName},#{recvPhone},#{recvProvince},#{recvCity}, #{recvArea},#{recvAddress},#{totalPrice},#{status},#{orderTime}, #{payTime},#{createdUser},#{createdTime},#{modifiedUser},#{modifiedTime} ) \u003c/insert\u003e \u003c!-- Integer insertOrderItem(OrderItem orderItem);--\u003e \u003cinsert id=\"insertOrderItem\"\u003e insert into t_order_item(oid,pid,title,image,price,num, created_user,created_time,modified_user,modified_time) values(#{oid},#{pid},#{title},#{image},#{price}, #{num},#{createdUser},#{createdTime},#{modifiedUser},#{modifiedTime} ) \u003c/insert\u003e \u003c/mapper\u003e 单元测试 ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:3:1","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"7.3.2 后端业务层 1.编写异常 插入失败，已经被定义 2.编写业务层抽象方法 /** * 插入订单数据 * @param aid 收货地址id * @param uid 用户id * @param totalPrice 商品总价 * @param username 操作人 */ Order insertOrder(Integer aid,Integer uid,Long totalPrice,String username); /** * 添加orderItem * @param oid * @param cid * @param num * @param username */ void insertOrderItem(Integer oid,Integer cid,Integer num,String username); 3.实现逻辑 /** * @author zxl * @description 订单的业务层接口实现类 * @date 2022/11/6 */ @Service public class IOrderServiceImpl implements IOrderService { @Autowired(required = false) private OrderMapper orderMapper; @Autowired private IAddressService addressService; @Autowired private ICartService cartService; @Autowired private IProductService productService @Override public Order insertOrder(Integer aid, Integer uid, Long totalPrice, String username) { //根据控制层传入的aid进行查询 Address address = addressService.findAddressByAid(aid); //创建一个用于向持久层传输的Order实体类对象 Order order = new Order(); //补全order对象的空白字段 order.setUid(uid); order.setAid(aid); order.setRecvName(address.getName()); order.setRecvPhone(address.getPhone()); order.setRecvProvince(address.getProvinceName()); order.setRecvCity(address.getCityName()); order.setRecvArea(address.getAreaName()); order.setRecvAddress(address.getAddress()); order.setTotalPrice(totalPrice); order.setStatus(0); //表示未支付 Date createdTime = new Date(); order.setOrderTime(createdTime); order.setPayTime(null); order.setCreatedUser(username); order.setModifiedUser(username); order.setCreatedTime(createdTime); order.setModifiedTime(createdTime); //调用持久层进行插入 int result = orderMapper.insertOrder(order); if (result == 0){ throw new InsertException(\"服务器出现错误，创建订单失败\"); } //根据oid查询指定的订单，并返回给控制层 return orderMapper.findOrderByOid(order.getOid()); } @Override public void insertOrderItem(Integer oid, Integer cid, Integer num, String username) { //根据cid查询订单获取pid Cart cart = cartService.findCartByCid(cid); //取出pid的值 Integer pid = cart.getPid(); //根据pid查询商品信息 Product product = productService.findProductById(pid); //创建一个用于向持久层传输的OrderItem实体类对象 OrderItem orderItem = new OrderItem(); //补全orderItem对象的空白字段 orderItem.setOid(oid); orderItem.setPid(pid); orderItem.setTitle(product.getTitle()); orderItem.setImage(product.getImage()); orderItem.setPrice(product.getPrice()); orderItem.setNum(num); Date createdTime = new Date(); orderItem.setCreatedUser(username); orderItem.setCreatedTime(createdTime); orderItem.setModifiedUser(username); orderItem.setModifiedTime(createdTime); //调用持久层进行插入 int result = orderMapper.insertOrderItem(orderItem); if (result == 0){ throw new InsertException(\"服务器出现错误，创建订单失败\"); } } } 4.单元测试 ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:3:2","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"7.3.3 后端控制层 1.处理异常 2.设计请求 请求路径： /order/createOrder 请求参数：Integer aid,Long totalPrice,HttpSession session ​ ②Integer oid,Integer cid,Integer pid,Integer num,HttpSession session 请求类型：post 响应类型：JsonResult\u003c Order\u003e 3.设计控制类 /** * @author zxl * @description * @date 2022/11/6 */ @RestController @RequestMapping(\"/Order\") public class OrderController extends BaseController { @Autowired private IOrderService orderService; /** * Description : 处理用户创建order订单的请求 * @date 2022/7/18 * @param aid 用户选中的地址aid * @param totalPrice 商品的总金额 * @param session 项目启动自动生成的session对象 * @return top.year21.computerstore.utils.JsonResult\u003cjava.lang.Void\u003e **/ @PostMapping(\"/createOrder\") public JsonResult\u003cOrder\u003e createOrder(Integer aid, Long totalPrice, HttpSession session){ //从session中取出用户名和uid Integer uid = getUserIdFromSession(session); String username = getUsernameFromSession(session); //调用业务层方法执行插入操作 Order order = orderService.insertOrder(aid,uid, totalPrice,username); return new JsonResult\u003c\u003e(OK,order); } } 4.前端页面 ","date":"2022-10-17","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/:3:3","tags":["computerStore"],"title":"SpringBoot项目-订单管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6 购物车 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:1:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.1 创建数据表 CREATE TABLE t_cart ( cid INT AUTO_INCREMENT COMMENT '购物车数据id', uid INT NOT NULL COMMENT '用户id', pid INT NOT NULL COMMENT '商品id', price BIGINT COMMENT '加入时商品单价', num INT COMMENT '商品数量', created_user VARCHAR(20) COMMENT '创建人', created_time DATETIME COMMENT '创建时间', modified_user VARCHAR(20) COMMENT '修改人', modified_time DATETIME COMMENT '修改时间', PRIMARY KEY (cid) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:2:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.2 创建实体类 /** * @author zxl * @description 购物车商品信息实体类 * @date 2022/11/4 */ @Data @AllArgsConstructor @NoArgsConstructor public class Cart extends BaseEntity{ // cid INT AUTO_INCREMENT COMMENT '购物车数据id', // uid INT NOT NULL COMMENT '用户id', // pid INT NOT NULL COMMENT '商品id', // price BIGINT COMMENT '加入时商品单价', // num INT COMMENT '商品数量', // created_user VARCHAR(20) COMMENT '创建人', // created_time DATETIME COMMENT '创建时间', // modified_user VARCHAR(20) COMMENT '修改人', // modified_time DATETIME COMMENT '修改时间', private Integer cid; private Integer uid; private Integer pid; private Long price; private Integer num; } ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:3:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.3 加入购物车 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:4:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.3.1 后端-持久层 1.编写sql语句 //1.向购物车插入数据 INSERT INTO t_cart (aid除外) values （值列表） //2.当当前购物车内已经存在当前商品，则直接更换当前商品数量 UPDATE t_cart SET num = ? WHERE cid = ? //3.插入和更新的操作是取决于购物车是否有该商品 //所有需要查询商品是否存在 SELECT * FROM t_cart WHERE uid = ? AND cid = ? 2.编写Mapper接口和抽象方法 /** * @author zxl * @description 购物车持久层的Mapper接口 * @date 2022/11/4 */ public interface CartMapper { /** * 插入Cart数据 * @param cart 购物车数据 * @return */ Integer addCart(Cart cart); /** * 更新Cart内容 * @param cid 购物车id * @param num 更新物品数量 * @param modifiedUser 更新人 * @param modifiedTime 更新时间 * @return */ Integer updateCartInfo(Integer cid, Integer num, String modifiedUser, Date modifiedTime); /** * 按照用户的uid和商品的pid查找某条购物车数据 * @param uid 用户的uid * @param pid 商品的id * @return 返回购物车数据 */ Cart findCartByUidAndPid(Integer uid,Integer pid); } 3.编写Mapper接口的映射文件 \u003cmapper namespace=\"com.zxl.store.mappers.CartMapper\"\u003e \u003c!-- Integer addCart(Cart cart);--\u003e \u003cinsert id=\"addCart\" useGeneratedKeys=\"true\" keyProperty=\"cid\"\u003e INSERT INTO t_cart(uid,pid,price,num,created_user,created_time,modified_user,modified_time) VALUES (#{uid},#{pid},#{price},#{num},#{createdUser},#{createdTime},#{modifiedUser},#{modifiedTime}) \u003c/insert\u003e \u003c!-- Integer updateCartInfo(Integer cid, Integer num , String modifiedUser, Date modifiedTime);--\u003e \u003cupdate id=\"updateCartInfo\"\u003e UPDATE t_cart SET num = #{num},modified_user = #{modifiedUser},modified_time = #{modifiedTime} WHERE cid = #{cid} \u003c/update\u003e \u003c!-- Cart findCartByUidAndPid(Integer uid,Integer pid);--\u003e \u003cselect id=\"findCartByUidAndPid\" resultType=\"com.zxl.store.entity.Cart\"\u003e SELECT * FROM t_cart WHERE uid = #{uid} AND pid = #{pid} \u003c/select\u003e \u003c/mapper\u003e 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:4:1","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.3.2 后端-业务层 1.规划异常 2.编写业务层接口和抽象方法 /** * 将商品加入购物车 * @param uid 用户id * @param pid 商品id * @param num 商品数量 * @param username 用户名 */ void addCart(Integer uid,Integer pid,Integer num,Integer username); 3.编写抽象方法的具体实现逻辑 /** * @author zxl * @description 购物车业务层接口的实现类 * @date 2022/11/4 */ @Service public class ICartServiceImpl implements ICartService { @Autowired(required = false) private CartMapper cartMapper; @Override public void addCart(Cart cart, String createdUser, Date createdTime, String modifiedUser, Date modifiedTime) { //查询当前商品是否在购物车存在 Integer pid = cart.getPid(); Integer uid = cart.getUid(); Cart destCart = cartMapper.findCartByUidAndPid(uid, pid); //判断查询结果 if(destCart==null){//如果不存在 //补全四个字段 cart.setCreatedUser(createdUser); cart.setModifiedUser(modifiedUser); cart.setCreatedTime(createdTime); cart.setModifiedTime(modifiedTime); //执行插入操作 Integer integer = cartMapper.addCart(cart); //判断插入结果 if(integer!=1){ throw new InsertException(\"插入购物车数据时遭遇未知异常\"); } }else{//表示该商品存在数据 //取出查询的数据数量 Integer destNum = destCart.getNum(); //取出新添加产品的数量 Integer cartNum = cart.getNum(); //计算结果 Integer num = destNum + cartNum; //设置需要更新的字段 cart.setNum(num); cart.setModifiedUser(modifiedUser); cart.setModifiedTime(modifiedTime); //执行更新操作 Integer row = cartMapper.updateCartInfo(cart); if(row != 1 ){ throw new UpdateException(\"更新购物车数据是遭遇未知异常\"); } } } } 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:4:2","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.3.3 后端控制层 1.处理异常 插入异常和更新异常均已被处理 2.设计请求 请求地址:/cart/add_cart 请求参数:Integer pid,Integer price,Integer num, HttpSession session 请求类型:post 响应类型:JsonResult 3.处理请求 编写控制方法 /** * @author zxl * @description 处理购物车请求的控制类 * @date 2022/11/5 */ @RestController @RequestMapping(\"/cart\") public class CartController extends BaseController { @Autowired private ICartService cartService; @RequestMapping(value = \"/add_cart\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e addCart(Integer pid,Integer price,Integer num, HttpSession session){ //从session获取uid和username String username = getUsernameFromSession(session); Integer uid = getUserIdFromSession(session); Date currentTime = new Date(); //设置参数 Cart cart = new Cart(); cart.setUid(uid); cart.setPid(pid); cart.setPrice(Long.valueOf(price)); cart.setNum(num); System.out.println(cart); //执行插入操作 cartService.addCart(cart,username,currentTime,username,currentTime); return new JsonResult\u003c\u003e(OK); } } 4. 前端页面 //将物品加入购物车 function addProductToCart(){ $(\"#btn-add-cart\").click(function () { if(confirm(\"确定要将此商品加入购物车吗？\")){ let price = $(\"#product-price\").text(); let num = $(\"#num\").val(); alert(price + \":\"+num); $.ajax({ url:\"/cart/add_cart\", type:\"post\", data:{ \"pid\":pid, \"price\":price, \"num\":num }, dataType: \"json\", success:function (json) { if(json.state==200){ alert(\"已经成功加入购物车\"); }else{ alert(\"加入购物车失败\"); } }, }); } }); } ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:4:3","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.4 展示购物车 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:5:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.4.1 后端-持久层 1.创建多表查询的实体类 /** * @author zxl * @description Cart表和Product表联合查询的结果映射实体类 * @date 2022/11/5 */ @Data @AllArgsConstructor @NoArgsConstructor public class CartVo { private Integer cid; private Integer pid; private Integer uid; private Long price; private Integer num; private String title; private String image; private String realPrice; } 2. 编写sql语句 由于购物车展示需要显示: 商品名称(product) 单价(product,cart) 数量(cart) 金额(product) SELECT c.cid, c.uid, c.pid, c.price, c.num, p.title, p.image, p.price AS realPrice FROM t_cart c LEFT JOIN t_product p ON c.pid=p.id WHERE c.uid = #{uid} ORDER BY c.created_time DESC 3.编写对应的Mapper接口的抽象方法 /** * 按照用户uid 查询所有的购物车记录 * @param uid 用户uid * @return 返回购物车集合 */ List\u003cCartVo\u003e findAllCartByUid(Integer uid); 4.编写Mapper接口对于的映射文件 \u003c!-- List\u003cCartVo\u003e findAllCartByUid(Integer uid);--\u003e \u003cselect id=\"findAllCartByUid\" resultType=\"com.zxl.store.vo.CartVo\"\u003e SELECT c.cid, c.uid, c.pid, c.price, c.num, p.title, p.image, p.price AS realPrice FROM t_cart c LEFT JOIN t_product p ON c.pid=p.id WHERE c.uid = #{uid} ORDER BY c.created_time DESC \u003c/select\u003e 5.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:5:1","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.4.2 后端-业务层 1.异常处理 2.编写业务层抽象方法 /** * 根据用户uid查询购物车数据 * @param uid 用户uid * @return */ List\u003cCartVo\u003e findAllCartByUid(Integer uid); 3.编写业务层方法的实现 @Override public List\u003cCartVo\u003e findAllCartByUid(Integer uid) { return cartMapper.findAllCartByUid(uid); } 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:5:2","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.4.3 后端-控制层 1.异常处理 2.设计请求 请求地址：/cart/show_carts 请求参数：HttpSession session 请求类型：get 响应类型：JsonResult\u003c List\u003c Cart» 3.处理请求，编写控制方法 @RequestMapping(value = \"/show_carts\",method = RequestMethod.GET) public JsonResult\u003cList\u003cCartVo\u003e\u003e showCarts(HttpSession session){ //获取uid Integer uid = getUserIdFromSession(session); //获取数据 List\u003cCartVo\u003e data = cartService.findAllCartByUid(uid); //返回数据 return new JsonResult\u003c\u003e(OK,data); } 4.前端页面 \u003cscript type=\"text/javascript\"\u003e function showCarts(){ $.ajax({ url: \"/cart/show_carts\", type: \"get\", dataType: \"json\", success: function (res) { if (res.data.length !== 0){ //先清空列表 $(\"#cart-list\").empty(); for (let i = 0; i \u003c res.data.length; i++) { let cart = res.data[i]; let idNum = i; let image = \"..\" + cart.image + \"collect.png\"; let totalPrice = cart.price * cart.num let str = \"\u003ctr\u003e\" +\"\u003ctd\u003e\u003cinput onclick='checkOne()' id=cid\" + idNum + \" name='cids' value=\" + cart.cid + \" type='checkbox' class='ckitem' /\u003e\u003c/td\u003e\" + \"\u003ctd\u003e\u003cimg src=\" + image + \" class='img-responsive' /\u003e\u003c/td\u003e\" + \"\u003ctd\u003e\" + cart.title + \"\u003c/td\u003e\" + \"\u003ctd\u003e¥\u003cspan id=\"+ \"goodsPrice\" + idNum +\"\u003e\"+ cart.price + \"\u003c/span\u003e\u003c/td\u003e\" + \"\u003ctd\u003e\" + \"\u003cinput id=\" + \"countRec\" + idNum + \" type='button' value='-' class='num-btn' onclick='ajaxProductCountRec(#{idNum})' /\u003e\" + \"\u003cinput id=\" + \"goodsCount\"+ idNum + \" type='text' size='2' readonly='readonly' class='num-text' value=\" + cart.num + \"\u003e\" + \"\u003cinput id=\" + \"countAdd\" + idNum + \" class='num-btn' type='button' value='+' onclick='ajaxProductCountAdd(#{idNum})' /\u003e\" + \"\u003c/td\u003e\" + \"\u003ctd\u003e\u003cspan id=\" + \"goodsCast\" + idNum + \"\u003e￥\" + totalPrice + \"\u003c/span\u003e\u003c/td\u003e\" + \"\u003ctd\u003e\" + \"\u003cinput type='button' onclick='delCartItem(#{deletedId})' class='cart-del btn btn-default btn-xs' value='删除' /\u003e\" + \"\u003c/td\u003e\" + \"\u003c/tr\u003e\" //替换数字 str = str.replaceAll(\"#{idNum}\",idNum) str = str.replaceAll(\"#{deletedId}\",cart.cid) //在表格中插入数据 $(\"#cart-list\").append(str) // 计算商品总数量和总价格 totalNum += 1; countPrice = countPrice + totalPrice; } }else{ str = \"\u003ctr\u003e\u003ctd colspan='12' style='font-weight: bold;color: red;padding: 20px;font-size: medium'\u003e\" + \"购物车暂无商品，请先去添加商品\u003c/td\u003e\u003c/tr\u003e\" $(\"#cart-list\").empty().append(str) } }, error : function (err) { alert(\"服务器出现错误，查询失败！\") } ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:5:3","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.5 删除商品 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:6:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.5.1 后端-持久层 1.编写sql DELETE FROM t_cart WHERE cid = #{cid} 2.编写Mapper接口的抽象方法 /** * 按照购物车id 删除购物车内容物 * @param cid 购物车id * @return 返回影响行数 */ Integer deleteCartByCid(Integer cid); 3.编写Mapper接口的映射文件 \u003c!-- Integer deleteCartByCid(Integer cid);--\u003e \u003cdelete id=\"deleteCartByCid\"\u003e DELETE FROM t_cart WHERE cid = #{cid} \u003c/delete\u003e 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:6:1","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.5.2 后端-业务层 1.处理异常 删除异常已经被定义 2.定义业务层抽象方法 /** * 按照cid删除购物车数据 * @param cid cid */ void deleteCartByCid(Integer cid); 3.定义抽象方法实现逻辑 @Override public void deleteCartByCid(Integer cid) { //删除 Integer row = cartMapper.deleteCartByCid(cid); //判断删除结果 if(row!=1){ throw new DeleteException(\"购物车数据删除异常!\"); } } 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:6:2","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.5.3 后端-控制层 1.处理异常 2.\u0008请求设计 请求地址：/cart/delete_cart 请求参数：Integer cid 请求类型：post 响应类型：JsonResult 3,处理请求，编写控制层方法 @RequestMapping(value = \"/delete_cart\",method = RequestMethod.GET) public JsonResult\u003cVoid\u003e showCarts(Integer cid){ cartService.deleteCartByCid(cid); return new JsonResult\u003c\u003e(OK); } 4.前端页面 //给每个删除按钮绑定点击事件 function delCartItem(cid){ if (confirm(\"确定要删除这条商品吗？\")){ $.ajax({ url: \"/cart/delete_cart\", type: \"post\", data: {\"cid\":cid}, dataType: \"json\", success:function (res) { alert(\"删除成功\") location.reload(); }, error:function (error) { alert(\"删除失败\") } }) } } ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:6:3","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.6 购物车数目增减 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:7:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.6.1 数目增减-持久层 1.编写sql //根据cid更新用户商品数量 UPDATE t_cart SET num = #{num},modified_user = #{modifiedUser}, #modified_time = #{modifiedTime} WHERE cid = #{cid} //根据cid查询用户cart信息 SELECT * FROM t_cart WHERE cid = #{cid}; 2.编写Mapper接口抽象方法 /** * 按照cid查询Cart * @param cid * @return */ Cart findCartByCid(Integer cid); /** * 按照cid增减购物车商品的数量 * @param num 数量 * @param cid 购物车id * @param modifiedUser 操作人 * @param modifiedTime 操作时间 * @return */ Integer updateCartNumByCid(Integer num,Integer cid,String modifiedUser,Date modifiedTime); 3.编写Mapper接口映射文件 \u003c!-- Cart findCartByCid(Integer cid);--\u003e \u003cselect id=\"findCartByCid\" resultType=\"com.zxl.store.entity.Cart\"\u003e SELECT * FROM t_cart WHERE cid = #{cid} \u003c/select\u003e \u003c!-- Integer updateCartNumByCid(Integer num,Integer cid,String username,Date time);--\u003e \u003cupdate id=\"updateCartNumByCid\"\u003e UPDATE t_cart SET num = #{num},modified_user = #{modifiedUser},modified_time = #{modifiedTime} WHERE cid = #{cid} \u003c/update\u003e 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:7:1","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.6.2 数目增减-业务层 1.处理异常 2.编写业务层抽象方法 /** * 更新购物车商品数量 * @param cid * @param num * @param modifiedUser */ void updateCartNumByCid(Integer cid,Integer num,String modifiedUser); 3.编写实现逻辑 @Override public void updateCartNumByCid(Integer cid, Integer num, String modifiedUser) { //查询购物车数据 Cart res = cartMapper.findCartByCid(cid); if(res==null){ throw new CartInfoNotExistsException(\"购物车数据不存在\"); } //添加 Integer row = cartMapper.updateCartNumByCid(num, cid, modifiedUser, new Date()); //判断 if(row!=1){ throw new UpdateException(\"更新购物车商品数目出现未知异常\"); } } 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:7:2","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.6.3 数目增减-控制层 1.异常处理 2. 设计请求 请求地址：/cart/update_num 请求参数：Integer cid,Integer num,HttpSession session 请求类型：post 响应类型：JsonResult\u003c void\u003e 3.处理请求，编写控制类 @RequestMapping(value = \"/update_num\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e updateNum(Integer cid,Integer num,HttpSession session){ String modifiedUser = getUsernameFromSession(session); cartService.updateCartNumByCid(cid,num,modifiedUser); return new JsonResult\u003c\u003e(OK); } 4. 前端页面 /*按加号数量增*/ function addNum(num) { var n = parseInt($(\"#goodsCount\"+num).val()); $(\"#goodsCount\"+num).val(n + 1); calcRow(num); } /*按减号数量减少*/ function reduceNum(num) { var n = parseInt($(\"#goodsCount\"+num).val()); if (n == 0) return; $(\"#goodsCount\"+num).val(n - 1); calcRow(num); } //计算单行小计价格的方法 function calcRow(num) { //取单价 parseFloat() 函数可解析一个字符串，并返回一个浮点数。 var vprice = parseFloat($(\"#goodsPrice\"+num).html()); //取数量 var vnum = parseFloat($(\"#goodsCount\"+num).val()); //小计金额 var vtotal = vprice * vnum; //赋值 $(\"#goodsCast\"+num).html(\"¥\" + vtotal); } //向服务器发送ajax请求减少用户购物车的商品数量 function ajaxProductCountRec(num){ reduceNum(num); let cid = $(\"#cid\"+num).val(); let updateNum = $(\"#goodsCount\"+num).val() $.ajax({ url : \"/cart/update_num\", type: \"post\", dataType: \"json\", data:{cid:cid,num:updateNum}, error: function () { alert(\"增加失败，请等待攻城狮修复！！\") } }) } //向服务器发送ajax请求增加用户购物车的商品数量 function ajaxProductCountAdd(num){ addNum(num) let cid = $(\"#cid\"+num).val(); let updateNum = $(\"#goodsCount\"+num).val() $.ajax({ url : \"/cart/update_num\", type: \"post\", dataType: \"json\", data:{cid:cid,num:updateNum}, error: function () { alert(\"增加失败，请等待攻城狮修复！！\") } }) } ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:7:3","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.7 显示勾选的购物车数据 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:8:0","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.7.1 后端-持久层 1.编写sql 用户在购物车列表随机勾选相关商品，在点击结算按钮之后，跳转到结算页面，在这个页面中需要展示上个页面所勾选的购物车对应数据 SELECT c.cid, c.uid, c.pid, c.price, c.num, p.title, p.image, p.price AS realPrice FROM t_cart c LEFT JOIN t_product p ON c.pid=p.id WHERE c.cid IN (?,?,?) ORDER BY c.created_time DESC ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:8:1","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"2.编写Mapper接口抽象方法 /** * 按照cids查询购物车数据 * @param cids * @return */ List\u003cCartVo\u003e findVoByCid(Integer[] cids); 3.编写映射文件 \u003c!-- List\u003cCartVo\u003e findVoByCid(Integer[] cids);--\u003e \u003cselect id=\"findVoByCid\" resultType=\"com.zxl.store.vo.CartVo\"\u003e SELECT c.cid, c.uid, c.pid, c.price, c.num, p.title, p.image, p.price AS realPrice FROM t_cart c LEFT JOIN t_product p ON c.pid=p.id WHERE c.cid IN ( \u003cforeach collection=\"array\" item=\"cid\" separator=\",\"\u003e #{cid} \u003c/foreach\u003e ) ORDER BY c.created_time DESC \u003c/select\u003e 4 单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:8:2","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.7.2 后端-业务层 1.编写异常 2.编写业务层抽象方法 /** * 按照cids查询购物车数据 * @param cids * @return */ List\u003cCartVo\u003e getVoByCid(Integer[] cids); 3.编写实现逻辑 @Override public List\u003cCartVo\u003e getVoByCid(Integer[] cids) { //查询数据 List\u003cCartVo\u003e data = cartMapper.findVoByCid(cids); //传输数据 return data; } 4.单元测试 ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:8:3","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"6.7.3 后端-控制层 1.处理异常 2.设计请求 请求地址：/cart/list 请求参数：Integer[] cids 请求类型：get 响应类型：JsonResult\u003cList\u003e 3.处理请求，编写处理方法 @RequestMapping(value = \"/list\",method = RequestMethod.GET) public JsonResult\u003cList\u003cCartVo\u003e\u003e getCartCids(Integer[] cids){ List\u003cCartVo\u003e data = cartService.getVoByCid(cids); return new JsonResult\u003c\u003e(OK,data); } 4.前端页面 1.将cart.html页面中结算按钮属性变更成type=“submit” 2.orderConfirm.html页面中添加自动加载从上个页面中传递过来的cids数据，再去请求ajax中进行填充当前页面区域中 \u003cscript type=\"text/javascript\"\u003e //展示从购物车界面选中的商品信息 function showOrderItem(){ data = location.search.substr(1);//截取地址栏url?后的第二个元素，即购物车商品的cid //记录商品总数和总价格 let totalNum = 0; let countPrice = 0; //自动发送ajax请求查询url地址上的cid信息 $.ajax({ url : \"/cart/list\", type: \"get\", data: data, dataType: \"json\", success:function(res){ if (res.state === 200){ //填充信息 $(\"#cart-list\").empty() for (let i = 0; i \u003c res.data.length; i++) { let str = \"\"; let cartVo = res.data[i] let totalPrice = cartVo.price * cartVo.num str = \"\u003ctr\u003e\" + \"\u003ctd id=cid\" + i + \" hidden='hidden'\u003e\" + cartVo.cid + \"\u003c/td\u003e\" + \"\u003ctd\u003e\u003cimg src=..\" + cartVo.image + \"collect.png\" + \" class='img-responsive' /\u003e\u003c/td\u003e\" + \"\u003ctd\u003e\" + cartVo.title + \"\u003c/td\u003e\" + \"\u003ctd\u003e¥\u003cspan\u003e\" + cartVo.price + \"\u003c/span\u003e\u003c/td\u003e\" + \"\u003ctd id=num\" + i + \" \u003e\" + cartVo.num + \"\u003c/td\u003e\" + \"\u003ctd\u003e\u003cspan\u003e\" + totalPrice + \"\u003c/span\u003e\u003c/td\u003e\" + \"\u003c/tr\u003e\" $(\"#cart-list\").append(str) //计算商品的数量和总金额 totalNum = totalNum + cartVo.num countPrice = countPrice + totalPrice; } $(\"#all-count\").empty().html(totalNum) $(\"#all-price\").empty().html(countPrice) }else{ location.href = \"500.html\" } }, error: function () { location.href = \"500.html\" } }); } $(function () { //页面加载完成执行查找 showOrderItem(); }); ","date":"2022-10-16","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/:8:4","tags":["computerStore"],"title":"SpringBoot项目-购物车管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5 商品管理 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:0:0","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.1 创建数据表 DROP TABLE IF EXISTS t_product; CREATE TABLE t_product ( id int(20) NOT NULL COMMENT '商品id', category_id int(20) DEFAULT NULL COMMENT '分类id', item_type varchar(100) DEFAULT NULL COMMENT '商品系列', title varchar(100) DEFAULT NULL COMMENT '商品标题', sell_point varchar(150) DEFAULT NULL COMMENT '商品卖点', price bigint(20) DEFAULT NULL COMMENT '商品单价', num int(10) DEFAULT NULL COMMENT '库存数量', image varchar(500) DEFAULT NULL COMMENT '图片路径', status int(1) DEFAULT '1' COMMENT '商品状态 1：上架 2：下架 3：删除', priority int(10) DEFAULT NULL COMMENT '显示优先级', created_time datetime DEFAULT NULL COMMENT '创建时间', modified_time datetime DEFAULT NULL COMMENT '最后修改时间', created_user varchar(50) DEFAULT NULL COMMENT '创建人', modified_user varchar(50) DEFAULT NULL COMMENT '最后修改人', PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; //具体录入信息参照githu ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:1:0","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.2 定义实体类 /** * @author zxl * @description 商品的实体类 * @date 2022/11/4 */ @Data @AllArgsConstructor @NoArgsConstructor public class Product extends BaseEntity{ private Integer id; private Integer categoryId ; private String itemType; private String title; private String sellPoint; private Long price; private Integer num; private String image; private Integer status; private String priority; } ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:2:0","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.3 热销商品 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:3:0","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.3.1 商品排行-持久层 1.编写sql语句 //查询热销商品的sql SELECT * FROM t_product WHERE status = 1 ORDER BY priorty DESC LIMIT 0,4 2.编写Mapper接口和抽象方法 /** * @author zxl * @description 处理商品数据的Mapper接口 * @date 2022/11/4 */ public interface ProductMapper { /** * 按照priority查找热销前五的商品数据 * @return 返回商品数据集合 */ List\u003cProduct\u003e findHotList(); } 3.编写Mapper接口的映射 \u003cmapper namespace=\"com.zxl.store.mappers.ProductMapper\"\u003e \u003c!-- List\u003cProduct\u003e findHotList();--\u003e \u003cselect id=\"findHotList\" resultType=\"com.zxl.store.entity.Product\"\u003e SELECT * FROM t_product WHERE status = 1 ORDER BY priority DESC LIMIT 0,4 \u003c/select\u003e \u003c/mapper\u003e 4.单元测试 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:3:1","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.3.2 商品排行-业务层 1.异常规划 没有异常 2.定义业务层接口和抽象方法 /** * @author zxl * @description 处理商品的业务层接口 * @date 2022/11/4 */ public interface IProductService { /** * 按照priority查找热销前五的商品数据 * @return 返回商品数据集合 */ List\u003cProduct\u003e findHotList(); } 3.编写业务层方法逻辑 /** * @author zxl * @description 处理商品的业务层实现类 * @date 2022/11/4 */ public class IProductServiceImpl implements IProductService { @Autowired(required = false) private ProductMapper productMapper; @Override public List\u003cProduct\u003e findHotList() { //查找数据 List\u003cProduct\u003e res = productMapper.findHotList(); return res; } } 4.单元测试 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:3:2","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.3.3 商品排行-控制层 1.异常处理 没有异常 2.设计请求 请求路径：/product/hot_list 请求参数：无 请求类型：get 响应类型：JsonResult\u003cList\u003c Product» 3.处理请求，编写控制层方法 /** * @author zxl * @description 处理商品相关请求的控制类 * @date 2022/11/4 */ @RestController @RequestMapping(\"/product\") public class ProductController extends BaseController { @Autowired(required = false) private IProductService productService; /** * 返回热销商品 * @return */ @RequestMapping(value = \"/host_list\",method = RequestMethod.GET) public JsonResult\u003cList\u003cProduct\u003e\u003e getHotList(){ List\u003cProduct\u003e data = productService.findHotList(); return new JsonResult\u003c\u003e(OK,data); } } 4.前端页面 function showHotList() { $(\"#hot-list\").empty(); $.ajax({ url:\"/product/hot_list\", type:\"GET\", dataType: \"json\", success: function (res) { for (let i = 0; i \u003c res.data.length; i++) { let str = \"\"; let product = res.data[i] let image = \"..\" + product.image + \"collect.png\" str = \"\u003cdiv class='col-md-12'\u003e\" + \"\u003cdiv class=\\\"col-md-7 text-row-2\\\"\u003e\" + \"\u003ca href='javascript:void(0);'onclick='jumpWithId(#{id})'\u003e\" + product.title + \"\u003c/a\u003e\" + \"\u003c/div\u003e\" + \"\u003cdiv class=\\\"col-md-2\\\"\u003e￥\" + product.price + \"\u003c/div\u003e\" + \"\u003cdiv class=\\\"col-md-3\\\"\u003e\" + \"\u003cimg src=\" + image + \" class='img-responsive' /\u003e\" + \"\u003c/div\u003e\" + \"\u003c/div\u003e\" str = str.replaceAll(\"#{id}\",product.id) $(\"#hot-list\").append(str) } }, error: function () { alert(\"查询错误，请等待攻城狮修复！！\") } }); } ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:3:3","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.4 新到商品 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:4:0","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.4.1 新到商品-持久层 1.编写sql语句 //按照上架物品的修改时间查询新商品 SELET * FROM t_product WHERE status = 1 ORDER BY modified_time DESC LIMIT 0,4 2.定义抽象方法 /** * 按照创建时间查找新到的商品 * @return 返回新商品列表 */ List\u003cProduct\u003e findNewProductList(); 3.定义mapper接口映射文件 \u003c!-- List\u003cProduct\u003e findNewProductList();--\u003e \u003cselect id=\"findNewProductList\" resultType=\"com.zxl.store.entity.Product\"\u003e SELECT * FROM t_product WHERE status = 1 ORDER BY modified_time DESC LIMIT 0,4 \u003c/select\u003e 4.单元测试 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:4:1","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.4.2 新到商品-业务层 1.定义异常 无 2.定义业务层抽象方法 /** * 按照商品状态和创建时间选取新商品集合 * @return */ List\u003cProduct\u003e findNewProductList(); 3. 编写业务层逻辑 @Override public List\u003cProduct\u003e findNewProductList() { //查找数据 List\u003cProduct\u003e res = productMapper.findNewProductList(); return res; } 4. 单元测试 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:4:2","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.4.3 新到商品-控制层 1.处理异常 无 2.定义请求 请求路径：/product/new_list 请求参数：无 请求类型：get 响应类型：JsonResult\u003cList\u003c Product» 3.处理请求，编写控制方法 /** * 返回新商品 * @return */ @RequestMapping(value = \"/new_list\",method = RequestMethod.GET) public JsonResult\u003cList\u003cProduct\u003e\u003e getNewList(){ List\u003cProduct\u003e data = productService.findNewProductList(); return new JsonResult\u003c\u003e(OK,data); } 4.前端页面 function showNewList() { $(\"#new-list\").empty(); $.ajax({ url:\"/product/new_list\", type:\"GET\", dataType: \"json\", success: function (res) { for (let i = 0; i \u003c res.data.length; i++) { let str = \"\"; let product = res.data[i] let image = \"..\" + product.image + \"collect.png\" str = \"\u003cdiv class='col-md-12'\u003e\" + \"\u003cdiv class=\\\"col-md-7 text-row-2\\\"\u003e\" + \"\u003ca href='javascript:void(0);'onclick='jumpWithId(#{id})'\u003e\" + product.title + \"\u003c/a\u003e\" + \"\u003c/div\u003e\" + \"\u003cdiv class=\\\"col-md-2\\\"\u003e￥\" + product.price + \"\u003c/div\u003e\" + \"\u003cdiv class=\\\"col-md-3\\\"\u003e\" + \"\u003cimg src=\" + image + \" class='img-responsive' /\u003e\" + \"\u003c/div\u003e\" + \"\u003c/div\u003e\" str = str.replaceAll(\"#{id}\",product.id) $(\"#new-list\").append(str) } }, error: function () { alert(\"查询错误，请等待攻城狮修复！！\") } }); } ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:4:3","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.5 显示商品 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:5:0","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.5.1 显示商品-持久层 1.编写sql //查找按照商品id查找商品 SELECT id,title,price,image FROM t_product WHERE id = #{id} 2.编写Mapper接口的抽象方法 /** * 按照商品的id查找商品 * @param pid * @return */ Product findProductById(Integer id); 3.编写Mapper接口的映射文件 \u003c!-- Product findProductById(Integer id);--\u003e \u003cselect id=\"findProductById\" resultType=\"com.zxl.store.entity.Product\"\u003e SELECT * FROM t_product WHERE status = 1 AND id = #{id} \u003c/select\u003e 4.单元测试 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:5:1","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.5.2 显示商品-业务层 1.异常处理 商品为找到异常 商品状态异常(为未上架或者已经删除的商品) /** * @author zxl * @description 商品未找到异常 * @date 2022/11/4 */ public class ProductNotFoundException extends ServiceException {} /** * @author zxl * @description 商品状态异常 * @date 2022/11/4 */ public class ProductStatusException extends ServiceException {} 2.编写业务层接口的抽象方法 /** * 根据商品id查找商品 * @param id 商品id * @return 返回商品信息 */ Product findProductById(Integer id); 3.编写业务层具体逻辑 @Override public Product findProductById(Integer id) { //根据id查询商品信息 Product res = productMapper.findProductById(id); //判断商品存在或者商品状态是否为上架 if(res==null){ throw new ProductNotFoundException(\"查询商品不存在\"); } if(res.getStatus()!=1){ throw new ProductStatusException(\"查询商品尚未上架\"); } //传输商品信息 return res; } 4.单元测试 ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:5:2","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"5.5.3 显示商品-控制层 1.异常处理 将上述两个异常加入BaseConrtroller 2.设计请求 请求路径：/product/{id} 请求参数：Integet id 请求类型：get 响应类型：JsonResult\u003c Product\u003e 3.处理请求，设计控制层方法 @RequestMapping(value = \"/{id}\") public JsonResult\u003cProduct\u003e findProductById(@PathVariable(\"id\")Integer id){ //按照获得的id查询商品 Product data = productService.findProductById(id); return new JsonResult\u003c\u003e(OK,data); } 4.前端页面 //index.html function jumpWithId(id) { let jumpUrl = \"product.html?id=\"+id; location.href=jumpUrl; } //function //返回一个参数 function getOne(){ var result; //返回字符串从url的?处开始 var url = decodeURI(window.location.search); //如果等于-1，代表没有找到，即网页连接没有携带任何参数 if (url.indexOf(\"?\") != -1){ //返回一个新的字符串，从url连接=符号处索引+1的位置开始返回 result = url.substr(url.indexOf(\"=\")+1); } return result; } //product.html //接收上一个页面传来的连接 var pid = getOne(); function showInThisProductHtml(){ //判断是否携带参数 if (location.search.substring(1).indexOf(\"id\") === -1){ location.href = \"500.html\" return false; } //在页面加载完成时自动发送此ajax请求并填充表单 $.ajax({ url: \"/product/\" + pid, type: \"get\", dataType: \"json\", success:function (res) { let product = res.data; //将普通的数据填充至页面 $(\"#product-title\").text(product.title) $(\"#product-sell-point\").append(product.sellPoint) $(\"#product-price\").text(product.price) $(\"#stock\").text(product.num) //将数据库查询的图片进行替换 let image = \"..\" + product.image //遍历填充图片数据 for (let i = 1; i \u003c= 5; i++) { $(\"#product-image-\" + i + \"-big\").attr(\"src\",image + i + \"_big.png\") $(\"#product-image-\" + i).attr(\"src\",image + i + \".jpg\") } } }) } ","date":"2022-10-15","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/:5:3","tags":["computerStore"],"title":"SpringBoot项目-商品管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.地址管理 收货地址的功能模块:列表展示，修改，删除，设置默认，新增收货地址 开发的顺序:新增收货地址-\u003e列表展示-\u003e设置默认收货地址-\u003e修改删除 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:1:0","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.1 创建数据表 创建数据表 CREATE TABLE t_address ( aid INT AUTO_INCREMENT COMMENT '收货地址id', uid INT COMMENT '归属的用户id', NAME VARCHAR(20) COMMENT '收货人姓名', province_name VARCHAR(15) COMMENT '省-名称', province_code CHAR(6) COMMENT '省-行政代号', city_name VARCHAR(15) COMMENT '市-名称', city_code CHAR(6) COMMENT '市-行政代号', area_name VARCHAR(15) COMMENT '区-名称', area_code CHAR(6) COMMENT '区-行政代号', zip CHAR(6) COMMENT '邮政编码', address VARCHAR(50) COMMENT '详细地址', phone VARCHAR(20) COMMENT '手机', tel VARCHAR(20) COMMENT '固话', tag VARCHAR(6) COMMENT '标签', is_default INT COMMENT '是否默认：0-不默认，1-默认', created_user VARCHAR(20) COMMENT '创建人', created_time DATETIME COMMENT '创建时间', modified_user VARCHAR(20) COMMENT '修改人', modified_time DATETIME COMMENT '修改时间', PRIMARY KEY (aid) ) ENGINE=INNODB DEFAULT CHARSET=utf8; ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:1:1","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.2 创建实体类 地址类 @Data @AllArgsConstructor @NoArgsConstructor public class Address extends BaseEntity{ /* * aid INT AUTO_INCREMENT COMMENT '收货地址id', uid INT COMMENT '归属的用户id', name VARCHAR(20) COMMENT '收货人姓名', province_name VARCHAR(15) COMMENT '省-名称', province_code CHAR(6) COMMENT '省-行政代号', city_name VARCHAR(15) COMMENT '市-名称', city_code CHAR(6) COMMENT '市-行政代号', area_name VARCHAR(15) COMMENT '区-名称', area_code CHAR(6) COMMENT '区-行政代号', zip CHAR(6) COMMENT '邮政编码', address VARCHAR(50) COMMENT '详细地址', phone VARCHAR(20) COMMENT '手机', tel VARCHAR(20) COMMENT '固话', tag VARCHAR(6) COMMENT '标签', is_default INT COMMENT '是否默认：0-不默认，1-默认', created_user VARCHAR(20) COMMENT '创建人', created_time DATETIME COMMENT '创建时间', modified_user VARCHAR(20) COMMENT '修改人', modified_time DATETIME COMMENT '修改时间', */ private Integer aid; private Integer uid; private String name; private String provinceName; private String provinceCode; private String cityName; private String cityCode; private String areaName; private String areaCode; private String zip; private String address; private String phone; private String tel; private String tag; private Integer isDefault; } ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:1:2","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.3 新增地址 4.3.1 后端-持久层 1.编写sql语句 //插入语句 insert into t_address(除了aid外字段)value(字段值) //查看收货地址数量(一个用户最大只能20条) select count(*) from t_address where uid = ? 2.定义Mapper接口和抽象方法 /** * @author zxl * @version 1.0.0 * @date 2022/11/02 * @desciption Address所对应的Mapper接口 */ public interface AddressMapper { /** * 插入用户的收货地址数据 * @param address 收货地址 * @return {@link Integer} 受影响的行数 */ Integer addAddress(Address address); /** * 根据用户id统计用户收货地址数量 * @param uid 用户uid * @return {@link Integer} 返回当前用户的收货地址总数 */ Integer userAddressCount(Integer uid); } 3.实现Mapper接口的映射 \u003cmapper namespace=\"com.zxl.store.mappers.AddressMapper\"\u003e \u003c!--addAddress 插入用户的地址--\u003e \u003cinsert id=\"addAddress\" useGeneratedKeys=\"true\" keyProperty=\"aid\"\u003e INSERT INTO t_address ( uid,name, province_name, province_code, city_name, city_code, area_name, area_code, zip, address, phone, tel, tag, is_default, created_user, created_time, modified_user, modified_time ) VALUES ( #{uid}, #{name}, #{provinceName}, #{provinceCode}, #{cityName}, #{cityCode}, #{areaName}, #{areaCode}, #{zip}, #{address}, #{phone}, #{tel}, #{tag}, #{isDefault}, #{createdUser}, #{createdTime}, #{modifiedUser}, #{modifiedTime} ) \u003c/insert\u003e \u003c!--userAddressCount 根据用户uid查询用户地址数量--\u003e \u003cselect id=\"userAddressCount\"\u003e SELECT COUNT(*) FROM t_address WHERE uid = #{uid} \u003c/select\u003e \u003c/mapper\u003e 4.单元测试Mapper接口 4.3.2 后端-业务层 如果用户插入的地址是第一条时，将其设为默认的收货地址 1. 规划异常 用户地址超出数量异常 /** * @author zxl * @description 用户地址数目超出异常 * @date 2022/11/2 */ public class AddressCountLimitException extends ServiceException {} 2.接口和抽象方法 /** * @author zxl * @description 收货地址业务层接口 * @date 2022/11/2 */ public interface IAddressService { /** * 添加用户地址 * @param uid 用户uid * @param username 用户名 * @param address 地址 */ void addAddress(Integer uid, String username, Address address); } 3.实现抽象方法 /** * @author zxl * @description 收货地址业务层的实现类 * @date 2022/11/2 */ @Service public class IAddressServiceImpl implements IAddressService { @Autowired private AddressMapper addressMapper; @Value(\"${user.address.max-count}\") private Integer maxCount; @Override public void addAddress(Integer uid, String username, Address address) { //先判断用户地址的条数 Integer count = addressMapper.userAddressCount(uid); //判断是否超过20条记录 if(count\u003e=maxCount){ throw new AddressCountLimitException(\"用户地址已经到达上限，请删除部分地址\"); } //判断当前地址是否为0 if(count==0){ address.setIsDefault(1); } //补全四项日志 Date currentTime = new Date(); address.setCreatedUser(username); address.setCreatedTime(currentTime); address.setModifiedUser(username); address.setModifiedTime(currentTime); //插入 Integer row = addressMapper.addAddress(address); //判断插入结果 if(row!=1){ throw new InsertException(\"插入时产生未知异常\"); } } } 4.单元测试 4.3.3 后端控制层 1.处理异常 将异常添加到全局异常处理 2.设计请求 请求路径：/address 请求参数：Address address,HttpSession session 请求类型：post 响应类型：JsonResult\u003c Void\u003e 3.处理请求，创建相应controller /** * @author zxl * @description 地址操作的控制层 * @date 2022/11/2 */ @RestController @RequestMapping(\"/address\") public class AddressController extends BaseController{ @Autowired private IAddressService addressService; /** * 处理用户添加地址的操作 * @param address 添加的地址 * @param session 项目自动生成的Session * @return {@link JsonResult}\u003c{@link Void}\u003e */ @PostMapping public JsonResult\u003cVoid\u003e addAddress(Address address, HttpSession session){ //从Session中获取Uid和Username Integer uid = getUserIdFromSession(session); String username = getUsernameFromSession(session); //添加 addressService.addAddress(uid,username,address); return new JsonResult\u003c\u003e(OK); } } 4.前端页面 \u003cscript type=\"text/javascript\"\u003e $(document).ready(function () { $(\"#btn-add-new-address\").click(function() { //判断手机号和收货人是否为空 let name = $(\"#name\").val(); let phone = $(\"#phone\").val(); let zip = $(\"#zip\").val(); let tag = $(\"#tag\").val(); if (phone == \"\" || name == \"\"){ $(\"#error-msg\").html(\"请先填写需要添加的信息！\"); return false; } //验证手机号是否符合要求 let checkPhone = /(^1\\d{10}$)|(^[0-9]\\d{7}$)/; if (!checkPhone.test(phone)){ $(\"#error-msg\").html(\"手机号不符合要求！\"); return false; } //验证邮箱是否为空或者超出最大长度6 if(zip.length\u003e=6){ $(\"#error-msg\").html(\"邮箱的最大长度6\"); return false; } //验证地址类型不可以超过6 if(tag.length\u003e=6){ $(\"","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:1:3","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.4 获取省市区列表 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:2:0","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.4.1 创建数据表 //parent属性代表的是父区域的代码号，省的父代码号是+86 //code代表的是本身的代码号 //name就是code所代表的本身的名称 CREATE TABLE t_dict_district ( id int(11) NOT NULL AUTO_INCREMENT, parent varchar(6) DEFAULT NULL, code varchar(6) DEFAULT NULL, name varchar(16) DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; //部分省市区数据太大 //请参考代码 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:2:1","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.4.2 创建实体类 创建District实体类 ** * @author zxl * @description 省市区的实体类 * @date 2022/11/3 */ @Data @AllArgsConstructor @NoArgsConstructor public class District extends BaseEntity { private Integer id; private String parent; private String code; private String name; } ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:2:2","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.4.3 后端-持久层 1.编写sql语句 //1.查询语句，根据父代号查询 (ASC 升序) SELECT * FROM t_dict_district WHERE parent = ? ORDER BY code ASC //2.根据code查询对应省市区名字 SELECT name FROM t_dict_district WHERE code = ? 2.定义Mapper接口和抽象方法 public interface DistrictMapper { /** * 根据用户的父代号查询区域信息 * @param parent 父代号 * @return 某个父区域下的所有区域列表 */ List\u003cDistrict\u003e findDistrictByParent(String parent); /** * 根据code查询区域名称 * @param code 区域代号 * @return 返回区域名称 */ String findNameByCode(String code); } 3.编写映射文件 \u003cmapper namespace=\"com.zxl.store.mappers.DistrictMapper\"\u003e \u003c!-- List\u003cDistrict\u003e findDistrictByParent(String parent);--\u003e \u003cselect id=\"findDistrictByParent\" resultType=\"com.zxl.store.entity.District\"\u003e SELECT * FROM t_dict_district WHERE parent = #{parent} ORDER BY code ASC \u003c/select\u003e \u003c!-- String findNameByCode(String code);--\u003e \u003cselect id=\"findNameByParent\" resultType=\"java.lang.String\"\u003e SELECT name FROM t_dict_district WHERE code = #{code} \u003c/select\u003e \u003c/mapper\u003e 4.单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:2:3","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.4.4 后端-业务层 1.规划异常 暂无异常可以规划 2.定义Service接口和抽象方法 /** * @author zxl * @description District业务层的接口类 * @date 2022/11/3 */ public interface IDistrictService { /** * 根据父代号查询区域信息(省市区) * @param parent 父代号 * @return 返回多个查询结果 */ List\u003cDistrict\u003e getDistrictByParent(String parent); /** * 按照code查询当前省市区名称 * @param code code * @return 返回省市区名称 */ String getNameByCode(String code); } 3.编写具体的实现方法和处理逻辑 /** * @author zxl * @description 处理省市区业务层接口的实现类 * @date 2022/11/3 */ @Service public class IDistrictServiceImpl implements IDistrictService { @Autowired(required = false) private DistrictMapper districtMapper; //根据父代号查询省市区的信息 @Override public List\u003cDistrict\u003e getDistrictByParent(String parent) { List\u003cDistrict\u003e districtByParent = districtMapper.findDistrictByParent(parent); //无效数据设为null for (District district : districtByParent) { district.setId(null); district.setParent(null); } return districtByParent; } //根据code查询省市区的名称 @Override public String getNameByCode(String code) { return districtMapper.findNameByCode(code); } } 4.单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:2:4","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.4.5 后端-控制层 1.异常处理 没有异常，不需要处理 2.设计请求 请求路径：/district/parent 请求参数：String parent 请求类型：get 响应类型：JsonResult\u003cList\u003c District» 3.处理请求，创建一个控制类 /** * @author zxl * @description 处理省市区相关业务的控制层 * @date 2022/11/3 */ @RestController @RequestMapping(\"/district\") public class DistrictController extends BaseController{ @Autowired(required = false) private IDistrictService districtService; @RequestMapping(value = \"/parent\",method = RequestMethod.GET) public JsonResult\u003cList\u003cDistrict\u003e\u003e getDistrictByParent(String parent){ //查询数据 List\u003cDistrict\u003e Data = districtService.getDistrictByParent(parent); //返回数据 return new JsonResult\u003c\u003e(OK,Data); } } 4. 前端页面 \u003cscript type=\"text/javascript\"\u003e $(document).ready(function () { //页面加载完成时，先把三个省市区的提示设置好 let provinceFirst = '\u003coption value=\"0\"\u003e--- 请选择省 ---\u003c/option\u003e'; let cityFirst = '\u003coption value=\"0\"\u003e--- 请选择市 ---\u003c/option\u003e'; let areaFirst = '\u003coption value=\"0\"\u003e--- 请选择区 ---\u003c/option\u003e'; //插入提示框 $(\"#province-list\").empty(); $(\"#city-list\").empty(); $(\"#area-list\").empty(); $(\"#province-list\").append(provinceFirst); $(\"#city-list\").append(cityFirst); $(\"#area-list\").append(areaFirst); //记录省的点击查询次数 let provinceClick = 0; $(\"#province-list\").click(function () { provinceClick++; console.log(provinceClick); //如果provinceClick为1代表首次点击 if(provinceClick==1){ let str = \"\"; $.ajax({ url:\"/district/parent\", type:\"get\", data:\"parent=86\", dataType:\"json\", success:function (json) { //如果返回消息成功，将数据填充回列表 if(json.state==200){ for(i = 0;i\u003cjson.data.length;i++){ //每个district对象 let district = json.data[i]; str = '\u003coption value=\"' + district.code + '\"\u003e' + district.name + '\u003c/option\u003e'; $(\"#province-list\").append(str); } } }, error:function () { alert(\"查询省市区列表错误，请联系管理员修复！\"); } }); } }); //监听省份的选择 为城市的选择做出变化 $(\"#province-list\").change(function () { //清空select下的所有option元素 $(\"#city-list\").empty(); $(\"#area-list\").empty(); //追加默认值 $(\"#city-list\").append(cityFirst); $(\"#area-list\").append(areaFirst); //获取省份选择的是什么 let provinceChoice = $(\"#province-list\").val(); //等于0 则不做请求 if(provinceChoice==\"0\")return false; let str = \"\"; $.ajax({ url:\"/district/parent\", type:\"get\", data:\"parent=\"+provinceChoice, dataType:\"json\", success:function (json) { if(json.state==200){ for( i = 0;i\u003cjson.data.length;i++){ //每个district对象 let district = json.data[i]; str = '\u003coption value=\"' + district.code + '\"\u003e' + district.name + '\u003c/option\u003e'; $(\"#city-list\").append(str); } } }, error:function () { alert(\"查询省市区列表错误，请联系管理员修复！\"); } }); }); //监听城市选择 为区县的选择做出变化 $(\"#city-list\").change(function () { //获取当前选择的城市是什么 let cityChoice = $(\"#city-list\").val(); //清空select下的option元素 $(\"#area-list\").empty(); //重新设置默认值 $(\"#area-list\").append(areaFirst); //判断默认值是什么 //如果是0则不发送ajax请求 if(cityChoice==\"0\")return false; //发送请求 $.ajax({ url:\"/district/parent\", type:\"get\", data:\"parent=\"+cityChoice, dataType:\"json\", success:function (json) { if(json.state==200){ for( i = 0;i\u003cjson.data.length;i++){ //每个district对象 let district = json.data[i]; str = '\u003coption value=\"' + district.code + '\"\u003e' + district.name + '\u003c/option\u003e'; $(\"#area-list\").append(str); } } }, error:function () { alert(\"查询省市区列表错误，请联系管理员修复！\"); } }); }); //添加地址 $(\"#btn-add-new-address\").click(function() { //判断手机号和收货人是否为空 let name = $(\"#name\").val(); let phone = $(\"#phone\").val(); let zip = $(\"#zip\").val(); let tag = $(\"#tag\").val(); //由于不知道的原因导致省市区的名称无法提交，所以进行这一步 let provinceName = $(\"#province-list\").find(\"option:selected\").text(); $(\"#provinceName\").val(provinceName); let cityName = $(\"#city-list\").find(\"option:selected\").text(); $(\"#cityName\").val(cityName); let areaName = $(\"#area-list\").find(\"option:selected\").text(); $(\"#areaName\").val(areaName); if (phone == \"\" || name == \"\"){ $(\"#error-msg\").html(\"请先填写需要添加的信息！\"); return false; } //验证手机号是否符合要求 let checkPhone = /(^1\\d{10}$)|(^[0-9]\\d{7}$)/; if (!checkPhone.test(phone)){ $(\"#error-msg\").html(\"手机号不符合要求！\"); return false; } //验证邮箱是否为空或者超出最大长度6 if(zip.length\u003e=6){ $(\"#error-msg\").html(\"邮箱的最大长度6\"); return false; } //验证地址类型不可以超过6 if(tag.length\u003e=6){ $(\"#error-msg\").html(\"地址类型的最大长度6\"); return false; } $.aja","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:2:5","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.5 获取用户地址 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:3:0","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.5.1 后端-持久层 1.编写sql语句 //获取用户收货地址 SELECT * FROM t_address WHERE uid = ? ORDER BY is_default DESC , created_time DESC 2.定义抽象方法 只需要在AddressMapper接口中定义新的抽象方法即可 /** * 根据用户的uid查询用户的收货地址集合 * @param uid 用户uid * @return 返回收货地址数据 */ List\u003cAddress\u003e findByUid(Integer uid); 3.编写映射文件 \u003c!-- List\u003cAddress\u003e findByUid(Integer uid);--\u003e \u003cselect id=\"findByUid\" resultType=\"com.zxl.store.entity.Address\"\u003e SELECT * FROM t_address WHERE uid = #{uid} ORDER BY is_default DESC ,created_time DESC \u003c/select\u003e 4.创建Mapper的单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:3:1","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.5.2 后端-业务层 1.异常控制 2.定义业务层抽象方法 /** * 根据用户的uid获取用户的收货地址信息集 * @param uid 用户的uid * @return 返回用户的地址集合 */ List\u003cAddress\u003e getAddressByUid(Integer uid); 3.编写具体的业务处理逻辑 /** * 按照用户uid查询用户的收货地址集合 * @param uid 用户的uid * @return 返回用户的收货地址的集合 */ @Override public List\u003cAddress\u003e getAddressByUid(Integer uid) { //获取结果 List\u003cAddress\u003e res = addressMapper.findByUid(uid); //由于网页端只需要地址类型，收件人姓名，详细地址，联系电话，所以对信息进行部分过滤 for (Address address : res) { address.setUid(null); address.setProvinceCode(null); address.setCityCode(null); address.setAreaCode(null); address.setTel(null); address.setCreatedTime(null); address.setCreatedUser(null); address.setModifiedTime(null); address.setModifiedUser(null); address.setIsDefault(null); } return res; } 4.编写业务层单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:3:2","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.5.3 后端-控制层 1.异常处理 2.设计请求 请求地址:/address 请求参数:HttpSession session 请求类型:GET 相应类型:JsonResult\u003cList\u003e 3.处理请求，编写控制层 /** * 处理网页端自动显示用户收货地址的请求 * @param session 项目自动生成的session * @return 返回JsonResult\u003cList\u003cAddress\u003e\u003e */ @GetMapping public JsonResult\u003cList\u003cAddress\u003e\u003e queryAllAddress(HttpSession session){ List\u003cAddress\u003e res = addressService.getAddressByUid(getUserIdFromSession(session)); return new JsonResult\u003c\u003e(OK,res); } 4.前端页面 //页面初始化加载用户收货地址信息 $(document).ready(function () { $(\"#address-list\").empty(); $.ajax({ url:\"/address\", type:\"GET\", dataType:\"json\", success:function (json) { if(json.data.length!=0){ let list = json.data; for (let i = 0; i \u003c list.length; i++) { let address = list[i]; let str = \" \"; str = \"\u003ctr\u003e\" +\"\u003ctd\u003e\"+address.tag+\"\u003c/td\u003e\" +\"\u003ctd\u003e\"+address.name+\"\u003c/td\u003e\" +\"\u003ctd\u003e\" +address.provinceName + address.cityName + address.areaName + address.address +\"\u003c/td\u003e\" +\"\u003ctd\u003e\"+address.phone+\"\u003c/td\u003e\" + \"\u003ca href='javascript:void(0);' onclick='updateAddress(#{editAid})' class='btn btn-xs btn-info'\u003e\" + \"\u003cspan class='fa fa-edit'\u003e\u003c/span\u003e修改\" + \"\u003c/a\u003e\" + \"\u003c/td\u003e\" + \"\u003ctd\u003e\" + \"\u003ca href='javascript:void(0);' onclick='deleteAddress(#{deleteAid},#{isDefault})' class='btn btn-xs add-del btn-info'\u003e\" + \"\u003cspan class='fa fa-trash-o'\u003e\u003c/span\u003e删除\" + \"\u003c/a\u003e\" + \"\u003c/td\u003e\" + \"\u003ctd\u003e\" + \"\u003ca href='javascript:void(0);' onclick='setDefault(#{defaultAid})' class='btn btn-xs add-def btn-default'\u003e设为默认\u003c/a\u003e\" + \"\u003c/td\u003e\" + \"\u003c/tr\u003e\" //使用正则表达式替换获取该地址的aid值，#{aid}只是一个占位符的含义，没其他含义 str = str.replace(\"#{editAid}\",address.aid) str = str.replace(\"#{deleteAid}\",address.aid) str = str.replace(\"#{defaultAid}\",address.aid) str = str.replace(\"#{isDefault}\",address.isDefault) $(\"#address-list\").append(str) } $(\".add-def:eq(0)\").hide(); }else{ let text = \"\u003ctr\u003e\u003ctd colspan='12' style='font-weight: bold;color: red;padding: 20px;font-size: medium'\u003e\" + \"暂无收货地址，请先添加收货地址\" + \"\u003c/td\u003e\u003c/tr\u003e\" $(\"#address-list\").append(text) } }, error: function (error) { alert(error.message) } }); ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:3:3","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.6 设置默认地址 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:4:0","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.6.1 后端-持久层 1.编写sql语句 //检测当前用户想设置的地址是否存在 SELECT * FROM t_address WHERE aid = ? //将所有的地址都设为非默认地址 UPDATE t_address SET is_default = 0 WHERE uid = ? //更新选中地址的默认值 UPDATE t_address SET is_default = 1,modified_user = ?,modified_time=? WHERE aid = ? 2.定义Mapper接口抽象方法 /** * 根据用户收货地址aid查询收货地址 * @param aid 收货地址id * @return 返回地址 */ Address findByAid(Integer aid); /** * 根据用户uid将所有地址设为非默认地址 * @param uid 用户uid * @return 返回影响行数 */ Integer updateNoneDefault(Integer uid); /** * 按照aid将该条收货地址设为默认地址 * @param aid 用户收货地址aid * @param modifiedUser 执行操作的操作人 * @param modifiedTime 执行操作的操作时间 * @return 返回影响行数 */ Integer updateDefault(Integer aid, String modifiedUser, Date modifiedTime); 3.编写Mapper接口的映射文件 \u003c!-- Address findByAid(Integer aid);--\u003e \u003cselect id=\"findByAid\" resultType=\"com.zxl.store.entity.Address\"\u003e SELECT * FROM t_user WHERE aid = #{aid} \u003c/select\u003e \u003c!-- Integer updateNoneDefault(Integer uid);--\u003e \u003cupdate id=\"updateNoneDefault\"\u003e UPDATE t_address SET is_default = 0 WHERE uid = #{uid} \u003c/update\u003e \u003c!-- Integer updateDefault(Integer aid, String modifiedUser, Date modifiedTime);--\u003e \u003cupdate id=\"updateDefault\"\u003e UPDATE t_address SET is_default = 1,modified_user = #{modifiedUser},modified_time=#{modifiedTime} WHERE aid = #{aid} \u003c/update\u003e 4.编写Mapper接口的单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:4:1","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.6.2 后端-业务层 1.异常处理 更新时异常（已经存在，无需创建） 数据不存在异常 /** * @author zxl * @description 用户地址未找到异常 * @date 2022/11/3 */ public class AddressNotFoundException extends ServiceException {} 2.定义Service层抽象方法 /** *　修改用户选中地址为默认收货地址 * @param uid 用户uid * @param aid 收货地址id * @param username 操作人 * @return void */ void setDefault(Integer uid,Integer aid,String username); 3.编写方法的具体逻辑 @Override public void setDefault(Integer uid, Integer aid, String username) { Address res = addressMapper.findByAid(aid); if(res==null){ throw new AddressNotFoundException(\"用户收货地址不存在\"); } //先将所有的地址设为非默认地址 Integer row = addressMapper.updateNoneDefault(uid); if(row\u003c1){ throw new UpdateException(\"将所有地址设置为非默认地址时出现异常\"); } //按照aid将收货地址设置为默认地址 Integer updateRow = addressMapper.updateDefault(aid, username, new Date()); if(updateRow!=0){ throw new UpdateException(\"设置默认地址时出现异常\"); } } 4.单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:4:2","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.6.3 后端-控制层 1.异常处理 将异常加入到全局处理 2.请求设计 请求路径：/address/set_default/{aid} 请求参数：@PathVariable(“aid”)Integer aid,HttpSession session 请求类型：post 响应类型：JsonResult\u003c void\u003e 3.处理请求，编写控制层 /** * 处理设置默认地址的请求 * @param aid 被设置为默认的收货地址id * @param session 项目启动时生成的session * @return 返回void */ @RequestMapping(value = \"/set_default/{aid}\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e setDefault(@PathVariable(\"aid\")Integer aid,HttpSession session){ //获取uid，username Integer uid = getUserIdFromSession(session); String username = getUsernameFromSession(session); //设置默认 addressService.setDefault(uid,aid,username); return new JsonResult\u003c\u003e(OK); } 4. 前端页面 //为设置默认按钮绑定事件 function setDefault(aid) { if(confirm(\"确定要这条收货地址设为默认地址吗？\")){ $.ajax({ url: \"/address/set_default/\"+aid, type: \"POST\", dataType: \"JSON\", success: function(json) { if (json.state == 200) { alert(\"设置成功\"); location.reload(); } else { alert(\"设置默认收货地址失败！\" + json.message); } }, error: function(json) { alert(\"您的登录信息已经过期，请重新登录！HTTP响应码：\" + json.status); location.href = \"login.html\"; } }); } } ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:4:3","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.7 删除地址 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:5:0","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.7.1 后端-持久层 1.编写sql语句 //根据aid删除用户收货地址的sql DELETE FROM t_address WHERE aid = #{aid} 2.定义Mapper接口抽象方法 /** * 按照aid删除用户的收货地址 * @param aid 用户的收货地址id * @return 返回影响行数 */ Integer DeleteAddressByAid(Integer aid); 3.编写Mapper接口的映射文件 \u003c!-- Integer DeleteAddressByAid(Integer aid);--\u003e \u003cdelete id=\"DeleteAddressByAid\"\u003e DELETE * FROM t_address WHERE aid = #{aid} \u003c/delete\u003e 4.单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:5:1","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.7.2 后端-业务层 1.异常控制 删除时异常 /** * @author zxl * @description 数据库删除时异常 * @date 2022/11/4 */ public class DeleteException extends ServiceException {} 2.定义抽象方法 /** * 按照收货地址id删除收货地址 * @param aid 收货地址id */ void deleteAddressByAid(Integer aid, Integer uid, String username); 3.编写实现逻辑 @Override public void deleteAddressByAid(Integer aid,Integer uid,String username) { //需要先判断用户有多少条地址 Integer count = addressMapper.userAddressCount(uid); //判断用户收货地址是否存在 Address byAid = addressMapper.findByAid(aid); if(byAid==null)throw new AddressNotFoundException(\"用户收货地址不存在\"); //如果地址多条 而且当前要删除的地址为默认地址 if(count\u003e1\u0026\u0026byAid.getIsDefault()==1){ //先删除当前地址 //按照用户aid删除 Integer row = addressMapper.DeleteAddressByAid(aid); //判断是否出现异常 if(row!=1)throw new DeleteException(\"删除用户收货地址时出现未知异常\"); //查询所有的地址，由于查询是按照创造时间排序的 List\u003cAddress\u003e byUid = addressMapper.findByUid(uid); //设置默认地址 addressMapper.updateDefault(aid,username,new Date()); return; } //如果只有一条，就不用判断是否需要再次设置默认地址 //按照用户aid删除 Integer row = addressMapper.DeleteAddressByAid(aid); //判断是否出现异常 if(row!=1)throw new DeleteException(\"删除用户收货地址时出现未知异常\"); } 4.单元测试 ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:5:2","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"4.7.3 后端-控制层 1.异常处理 将异常加入全局处理 2.设计请求 请求路径：/address/delete_address/{aid} 请求参数：@PathVariable(“aid”)Integer aid,HttpSession session 请求类型：post 响应类型：JsonResult\u003c void\u003e 3.处理请求，编写控制方法 /** * 处理删除地址的请求 * @param aid 需要删除的收货地址的id * @return 返回OK */ @RequestMapping(value = \"/delete_address/{aid}\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e deleteAddressByAid(@PathVariable(\"aid\")Integer aid,HttpSession session){ //获取uid Integer uid = getUserIdFromSession(session); //获取username String username = getUsernameFromSession(session); //执行删除 addressService.deleteAddressByAid(aid,uid,username); //执行成功返回数据 return new JsonResult\u003c\u003e(OK); } 4.前端页面 //为删除按钮定义事件 function deleteAddress(aid) { if(confirm(\"确定要删除这条收货地址吗?\")){ $.ajax({ url: \"/address/delete_address/\"+aid, type: \"POST\", dataType: \"JSON\", success: function(json) { if (json.state == 200) { location.reload(); } else { alert(\"删除收货地址失败！\" + json.message); } }, error: function(xhr) { alert(\"您的登录信息已经过期，请重新登录！HTTP响应码：\" + xhr.status); location.href = \"login.html\"; } }); } } ","date":"2022-10-14","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/:5:3","tags":["computerStore"],"title":"SpringBoot项目-地址管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"2环境搭建 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:0:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"2.1基本环境: 1.JDK1.8 2.Maven 3.6.1 3.Mysql 8.0.28 4.IDEA 2019.2.4 3.用户管理 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:1:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.1 创建数据库 CREATE DATABASE IF NOT EXISTS `computer_store` CHARACTER SET 'utf8'; ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:2:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.2 创建数据表 CREATE TABLE t_user ( uid INT AUTO_INCREMENT COMMENT '用户id', username VARCHAR(20) NOT NULL UNIQUE COMMENT '用户名', password CHAR(32) NOT NULL COMMENT '密码', salt CHAR(36) COMMENT '盐值', phone VARCHAR(20) COMMENT '电话号码', email VARCHAR(30) COMMENT '电子邮箱', gender INT COMMENT '性别:0-女，1-男', avatar VARCHAR(50) COMMENT '头像', is_delete INT COMMENT '是否删除：0-未删除，1-已删除', created_user VARCHAR(20) COMMENT '日志-创建人', created_time DATETIME COMMENT '日志-创建时间', modified_user VARCHAR(20) COMMENT '日志-最后修改执行人', modified_time DATETIME COMMENT '日志-最后修改时间', PRIMARY KEY (uid) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 考虑到每个表中都有固定的四个字段,可以使用一个java基类表示 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:3:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.3 创建实体类 //用于与用户四个字段所形成映射关系的基类 public class BaseEntity implements Serializable { private String createdUser;//日志创建人 private Date createdTime;//日志创建时间 private String modifiedUser;//日志最后修改人 private Date modifiedTime;//日志最后修改时间 } //对应数据表的User实体类 public class User extends BaseEntity implements Serializable { private Integer uid;//用户id private String username;//用户名 private String password;//密码 private String salt;//盐值 private String phone;//电话号码 private String email;//电子邮箱 private Integer gender;//性别:0-女，1-男 private String avatar;//头像 private Integer isDelete;//是否删除：0-未删除，1-已删除 } ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:4:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.4 注册 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:5:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.4.1 后端持久层(使用mybatis) 1 编写sql语句 #增加用户的sql语句 INSERT INTO t_user(username,password,)VALUES (？，？) #查询用户是否存在（username在数据库由UNIQUE修饰） SELECT * FROM t_user WHERE username = ? 2 定义mapper接口和抽象方法 由于项目可能有多个mapper接口，所以在项目目录下创建一个mappers包，用于管理所有mapper接口 并在SpringBoot启动类上添加MapperScan注解扫描mapper包或直接在接口说使用@Mapper注解 /*用户模块持久层接口*/ //@Mapper public interface UserMapper { /** * 插入用户数据 * @param user 用户数据 * @return 返回影响行数 */ Integer insert(User user); /** * 根据用户名查询用户数据（数据库中用户名唯一） * @param username 用户名 * @return 返回用户或者null */ User findByUsername(String username); } 3 编写映射文件 项目可能有多个Mapper映射文件，所以需要在项目的resource下创建一个mappers包便于管理。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!--namespace属性:指定当前映射文件和哪个接口映射--\u003e \u003cmapper namespace=\"com.zxl.store.mappers.UserMapper\"\u003e \u003c!--Integer insert(User user);--\u003e \u003c!-- useGeneratedKeys 开启某(主键)个字段的值递增 keyProperty 表示将表中的xxx字段作为主键 --\u003e \u003cinsert id=\"insert\" useGeneratedKeys=\"true\" keyProperty=\"uid\"\u003e INSERT INTO t_user( username,password, salt,phone, email,gender, avatar,is_delete, created_user, created_time, modified_user, modified_time )VALUES ( #{username},#{password}, #{salt},#{phone}, #{email},#{gender}, #{avatar},#{isDelete}, #{createdUser}, #{createdTime}, #{modifiedUser}, #{modifiedTime} ) \u003c/insert\u003e \u003c!--User findByUsername(String username);--\u003e \u003c!-- ResultType 表示查询的结果类型 ResultMap 当表的字段和类的对象属性字段名称不一致时，来自定义结果的映射规则 --\u003e \u003cselect id=\"findByUsername\" resultType=\"com.zxl.store.pojo.User\"\u003e SELECT * FROM t_user WHERE username = #{username} \u003c/select\u003e \u003c/mapper\u003e #针对t_user与User类的名称不对应问题， #可以在application.properties下针对mybatis开启 mybatis.configuration.map-underscore-to-camel-case=true 4 将mapper映射文件的位置在yml配置文件中进行对应的设置 将mapper的映射文件路径添加在application.properties配置文件中进行配置 mybatis.mapper-locations=classpath:mappers/*.xml 在application.properties中配置数据库连接，否则无法连接数据库 (此处以使用mysql为例子设置，具体数据库请参考自己使用的数据库） pring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.username=root spring.datasource.password=123 spring.datasource.url=jdbc:mysql://localhost:3306/store 5 单元测试 进行单元测试，建议尽可能完成所有测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:5:1","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.4.2 后端-业务层 业务层的包下主要有ex、impl、interface，其中ex放置各种异常处理类，impl中放置interface的实现类 1.规划异常处理机制 考虑到在后端处理业务的过程中，会出现各种异常情况，如执行过程中数据库宕机、用户名重复等。 虽然java在异常处理机制已经很完善，以上的情况都是抛出RuntimeException异常，对定位异常不够明确。 因此在业务层的制定中，需要考虑对异常的定义处理。 在业务层制定一个继承RuntimeException异常的异常类ServiceException，再让具体的异常继承这个异常。 /*业务层异常的基类*/ public class ServiceException extends RuntimeException { public ServiceException() { super(); } public ServiceException(String message) { super(message); } public ServiceException(String message, Throwable cause) { super(message, cause); } public ServiceException(Throwable cause) { super(cause); } protected ServiceException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) { super(message, cause, enableSuppression, writableStackTrace); } } 根据业务层不同的 来详细定义具体异常的类型，统一的继承ServiceException异常基类 //用户未找到异常 public class UserNotFoundException extends ServiceException {} //用户名重复异常 public class UsernameDuplicateException extends ServiceException {} //插入时未知异常 public class InsertException extends ServiceException{} //验证码不匹配异常 public class ValidCodeNotMatchException extends ServiceException {} 2 定义业务层接口和抽象方法 public interface IUserService { /** * 处理用户注册 * @param user 用户信息 */ void userRegister(User user); } 3 定义业务层接口的实现类 补全五个字段: is_Delete:便于逻辑删除 create_user:注册记录创建人 create_time:注册日期 modified_user:增删改操作人 modified_time:增删改时间 便于后期数据库管理 @Service public class IUserServiceImpl implements IUserService { @Autowired private UserMapper userMapper; //处理用户注册 @Override public void userRegister(User user) { //首先判断用户名是否在数据库中重复使用 User res = userMapper.findUserByUsername(user.getUsername()); //重复的情况下抛出异常 if(res!=null){ throw new UsernameDuplicateException(\"用户名已被注册\"); } //加密处理:md5算法 //串+password+串---\u003emd5，连续加载3次 //盐值+password+盐值 ---\u003e盐值随机字符串 //记录旧密码 String oldPass = user.getPassword(); //使用UUID获取salt String salt = UUID.randomUUID().toString().toUpperCase(); //进行加密操作 String newPass = getMD5Password(oldPass,salt); //对User进行补全 user.setSalt(salt); user.setPassword(newPass); //修改逻辑删除判定 user.setIsDelete(0); //补全四个操作字段 Date currentTime = new Date(); user.setCreatedTime(currentTime); user.setCreatedUser(user.getUsername()); user.setModifiedTime(currentTime); user.setModifiedUser(user.getUsername()); //调用插入方法 插入用户数据 Integer row = userMapper.addUser(user); //判断插入结果 if(row!=1){ throw new InsertException(\"处理用户注册过程出现未知异常\"); } } /*md5加密*/ private String getMD5Password(String password,String salt){ //加密算法 //加密之后的密匙 for (int i = 0; i \u003c 3 ; i++) { password = DigestUtils.md5DigestAsHex((salt + password + salt).getBytes()).toUpperCase(); } return password; } } 4 业务层进行单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:5:2","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.4.3 后端-控制层 1 设置返回响应信息给前端的基类 /** * @author zxl * @description 相应数据给前端 * @date 2022/10/30 */ @Data public class JsonResult\u003cE\u003e { //响应状态码 200-成功 4000-用户名重复 5000-数据库或服务器异常 private int status; //响应信息 private String message; //响应数据 private E data; public JsonResult() { } public JsonResult(int status) { this.status = status; } public JsonResult(Throwable e) { this.message = e.getMessage(); } public JsonResult(int status, E data) { this.status = status; this.data = data; } } 2 设计请求 请求路径：/user/reg 请求参数：User user,HttpSession session,String code 请求类型：post 响应结果：JsonResult\u003c Void\u003e 3 设计控制层 设计一个BaseController处理全局所有自定义的异常 /*控制层的基类*/ public class BaseController { /*操作成功状态码*/ public static final int OK = 200; /** * 1.当出现了value内的异常之一，就会将下方的方法作为新的控制器方法进行执行 * 因此该方法的返回值也同时是返回给前端的页面 * 2.此外还自动将异常对象传递到此方法的参数列表中，这里使用Throwable e来接收 **/ @ExceptionHandler(ServiceException.class) //统一处理抛出的异常 public JsonResult\u003cVoid\u003e handleException(Throwable e){ JsonResult\u003cVoid\u003e result = new JsonResult\u003c\u003e(e); if (e instanceof UsernameDuplicateException){ result.setStatus(4000); //表示用户名重复 result.setMessage(e.getMessage()); }else if (e instanceof UserNotFoundException){ result.setStatus(4001); //表示用户数据不存在 result.setMessage(e.getMessage()); }else if (e instanceof InsertException){ result.setStatus(5000); //数据库或服务器有问题 result.setMessage(e.getMessage()); } //返回异常处理结果 return result; } } 创建一个UserController处理注册请求 UserController继承了BaseController也就间接拥有了BaseController的属性和方法 @RestController @RequestMapping(\"users\") public class UserController extends BaseController{ @Autowired private IUserService iUserService; //注册用户 @RequestMapping(value = \"reg\",method = RequestMethod.POST) //@ResponseBody//表示此方法的响应结果以json格式进行数据的响应给到前端 public JsonResult\u003cVoid\u003e reg(User user){ iUserService.reg(user); return new JsonResult\u003c\u003e(OK,\"注册成功\"); } } 前端页面 前端页面只需要将表单通过ajax异步向后端服务器发送即可(目标文件:register.html) 只需要通过JavaScript给用户注册按钮绑定事件即可 当前功能: 1.注册信息空缺检测 2.用户名是否合规检测 3.添加验证码 4.验证输入密码是否一致 5.表单提交 \u003cscript type=\"text/javascript\"\u003e $(document).ready(function () { //验证信息和发送ajax注册用户请求 //给用户注册绑定点击事件 $(\"#btn-reg\").click(function () { let name = $(\"#username\").val(); let pwd = $(\"#password\").val(); let rePwd = $(\"#rePwd\").val(); let codeStr = $(\"#code\").val(); //去掉验证码前后空格 codeStr = $.trim(codeStr); if (name == \"\" || pwd == \"\" || rePwd == \"\" || codeStr == \"\") { $(\"#error-msg\").text(\"请先填写需要注册的信息！\"); return false; } //验证用户名是否符合规则 let nameCheck = /^\\w{5,12}$/; let username = $(\"#username\").val(); if (!(nameCheck.test(username))) { $(\"#error-msg\").text(\"用户名必须是5-12位的字母和数字\"); return false; } else { $(\"#error-msg\").empty() } //验证密码是否符合规则 let passCheck = /^\\w{5,12}$/; let password = $(\"#password\").val(); if (!passCheck.test(password)) { $(\"#error-msg\").text(\"密码必须是5-12位的字母和数字\"); return false; } else { $(\"#error-msg\").empty() } //验证确认密码和密码是否相同 let rePass = $(\"#rePwd\").val(); if (rePass !== password) { $(\"#error-msg\").text(\"密码不一致\"); return false; } else { $(\"#error-msg\").empty() } $.ajax({ url: \"/user\", type: \"post\", data: $(\"#form-reg\").serialize(), //获取表单的所有内容 dataType: \"json\", success: function (res) { if (res.status === 200) { alert(\"注册成功！\") location.href = \"login.html\" } else { $(\"#error-msg\").html(res.message) } }, error: function (error) { alert(error.status + \"错误,服务器出现故障，请等待攻城狮修复！！\") } }); }); //显示或隐藏密码的方法 function showPasswordOrNot(eleId,imgId){ let pwd = document.getElementById(eleId) let img = document.getElementById(imgId) if (pwd.type == \"password\"){ pwd.type = \"text\"; img.src = \"../images/img/close.jpeg\" }else { pwd.type = \"password\"; img.src = \"../images/img/open.jpeg\" } } //给图片验证码绑定点击事件，刷新验证码 function reFlashImg(imgId) { let kaptcha = document.getElementById(imgId) kaptcha.src = \"/kaptcha/kaptcha-image?time=\"+ new Date(); } }); \u003c/script\u003e ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:5:3","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.5 用户登录 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:6:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.5.1 后端-持久层 持久层可以利用上面写好的sql语句判断用户是否存在 1.sql语句可以使用上面的 2.Mapper接口用上面的 3.\u0008Mapper接口的映射文件可以使用上面的 4.单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:6:1","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.5.2 后端-业务层 1.规划异常 创建两个异常类继承ServiceException基类 // 表示用户名不存在的异常 public class UserNotFoundException extends ServiceException {} //表示密码错误的异常 public class PasswordNotMatchException extends ServiceException {} 2.编写接口抽象方法 /** * 用户登陆操作 * @param user 用户信息 * @return 返回用户 */ User userLogin(User user); 3.实现类内具体的业务处理流程 //处理用户登陆 @Override public User userLogin(User user) { //用户名 String username = user.getUsername(); //密码 String password = user.getPassword(); //查询用户是否在数据库中 User res = userMapper.findUserByUsername(username); //判断结果为空或者逻辑删除 if(res==null||(res.getIsDelete()==1)){ throw new UserNotFoundException(\"用户数据不存在\"); } //密码校验 String salt = user.getSalt(); String databasePass = res.getPassword(); //获取加密密码 String md5Password = getMD5Password(password, salt); // if(!(md5Password.equals(databasePass))){ throw new PasswordNotMatchException(\"密码错误\"); } //密码正确返回查询结果 //将查询结果中的uid、username、avatar封装到新的user对象中 User ret = new User(); user.setUid(res.getUid()); user.setUsername(res.getUsername()); user.setAvatar(res.getAvatar()); return ret; } 进行单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:6:2","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.5.3 后端-控制层 1.在全局的BaseController中添加异常处理 2.设计请求 请求路径：/user/login 请求参数：User user, HttpSession session,String code 请求类型：get 响应结果：JsonResult\u003c User\u003e 3. 处理请求 //用户登陆 @GetMapping public JsonResult\u003cUser\u003e userLogin(User user,HttpSession session,String code){ //从session取出验证码 String validCode = (String) session.getAttribute(Constants.KAPTCHA_SESSION_KEY); //判断验证码是否正确 if (!validCode.equals(code)) { throw new ValidCodeNotMatchException(\"验证码错误,请重试！\"); } //执行登陆操作 User LoginUser = userService.userLogin(user); //将用户名和uid保存到session中 session.setAttribute(\"uid\",LoginUser.getUid()); session.setAttribute(\"username\", LoginUser.getUsername()); //返回数据 return new JsonResult\u003c\u003e(OK,LoginUser); } 4.单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:6:3","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.5.4 前端页面 登录成功以及登录成功后需要做的事情： 需要在登录成功后跳转至首页 window.location.href = “xxx.html” 这个直接跳转到指定页面 保存用户信息到session域中 3.5.4.1 保存在前端的会话窗口中，供前端页面使用 $.ajax({ url : \"/user\", type: \"get\", data: $(\"#form-login\").serialize(), //获取表单的所有内容 dataType: \"json\", success: function (res) { if (res.status === 200){ alert(\"登录成功！\"); //前往首页 window.location.href=\"index.html\"; //将用户信息存入session域中 sessionStorage.setItem(\"user\",JSON.stringify(res.data)); }else { $(\"#error-msg\").html(res.message) } }, error: function (error) { alert(error.status + \"错误,服务器出现故障，请等待攻城狮修复！！\") } }); 3.5.4.2 保存在工程项目的session中，供整个工程使用 session对象主要存在服务器端，可以用于保存服务器的临时数据的对象，也可用于拦截器的拦截请求 public class BaseController { /** * Description : 从session中获取用户uid * @param session springboot启动时生成的session对象 **/ public final Integer getUserIdFromSession(HttpSession session){ String uidStr = session.getAttribute(\"uid\").toString(); return Integer.valueOf(uidStr); } //从session中获取用户username public final String getUsernameFromSession(HttpSession session){ return session.getAttribute(\"username\").toString(); } } 3.5.4.3 拦截器，对每个访问的页面进行拦截判断，没有登录则重定向至登录页面 在interceptor包下自定义拦截器类，实现HandleInterceptor接口，实现此接口的方法 public class LgoinInterceptor implements HandlerInterceptor { //在调用所有处理请求的方法之前被自动调用执行的方法 /** * 检测全局Session对象中是否有Uid数据，如果有放行，如果没有重定向到登陆页面 * * @param request 请求对象 * @param response 响应对象 * @param handler 处理器 * @return 如果返回值为true--\u003e 放行 如果false--\u003e 拦截 * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //获取项目工程的session HttpSession session = request.getSession(); if (session.getAttribute(\"uid\") != null) { //说明此时已登录 return true; } else {//说明未登录 //重定向至登录页面 response.sendRedirect(\"/web/login.html\"); return false; } } //ModelAndView对象返回之后被调用的方法 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } //在整个请求所有关联的资源被执行完毕最后所执行的方法 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } } 3.5.4.4 在config包下创建自定义配置类，实现WebMvcConfigurer接口，将拦截器添加到容器中 ​指定拦截规则【如果是拦截所有，静态资源也会被拦截，所以要指定白名单和黑名单】 拦截器也要放行接口的请求，不然就报错 @Configuration//加载当前的拦截器并进行注册 //处理器拦截器的注册 public class LoginInterceptorConfigurer implements WebMvcConfigurer { //将自定义的拦截器进行注册 @Override public void addInterceptors(InterceptorRegistry registry) { //自定义一个拦截器对象 HandlerInterceptor interceptor = new LgoinInterceptor(); //配置白名单 List\u003cString\u003e patterns = new ArrayList\u003c\u003e(); patterns.add(\"/bootstrap3/**\"); patterns.add(\"/css/**\"); patterns.add(\"/images/**\"); patterns.add(\"/js/**\"); patterns.add(\"/web/register.html\"); patterns.add(\"/web/login.html\"); patterns.add(\"/web/index.html\"); patterns.add(\"/web/product.html\"); patterns.add(\"/users/**\"); patterns.add(\"/kaptcha/**\"); patterns.add(\"/address/**\"); patterns.add(\"/cart/**\"); patterns.add(\"/district/**\"); patterns.add(\"/product/**\"); //向注册器对象添加拦截器 registry.addInterceptor(interceptor) .addPathPatterns(\"/**\")//要拦截的Url是什么 .excludePathPatterns(patterns); } } ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:6:4","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.6 修改密码 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:7:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.6.1 后端-持久层 1.编写sql语句 SELECT * FROM t_user WHERE uid = #{uid} UPDATE t_user SET password=#{password}, modified_time=#{modifiedTime}, modified_user=#{modifiedUser} WHERE uid = #{uid} 2.定义mapper接口的抽象方法 /** * 根据用户的id查询用户数据 * @param uid 用户Uid * @return 返回用户数据或者null */ User findByUid(Integer uid); /** * 根据用户Uid修改密码 * @param uid 用户Uid * @param password 用户输入的新密码 * @param modifiedUser 表示修改的执行者 * @param modifiedTime 表示修改的时间 * @return */ Integer updatePasswordByUid(Integer uid, String password, String modifiedUser, Date modifiedTime); 3.编写Mapper接口映射 \u003c!--User findByUid(Integer uid);--\u003e \u003cselect id=\"findByUid\" resultType=\"com.zxl.store.entity.User\"\u003e SELECT * FROM t_user WHERE uid = #{uid} \u003c/select\u003e \u003c!-- Integer updatePasswordByUid(Integer uid, String password, String modifiedUser, Date modifiedTime);--\u003e \u003cupdate id=\"updatePasswordByUid\" \u003e UPDATE t_user SET password=#{password}, modified_time=#{modifiedTime}, modified_user=#{modifiedUser} WHERE uid = #{uid} \u003c/update\u003e 4.测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:7:1","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.6.2 后端-业务层 1.异常处理，创建一个表示密码不匹配的异常，比如原密码不对 2.定义Userservice的抽象方法 3.编写实现类实现接口方法的业务处理逻辑 1.密码不匹配错误 public class PasswordNotMatchException extends ServiceException {} 2.IUserService的抽象方法 /** * 更改用户密码 * @param uid 用户id * @param username 用户名 * @param oldPassword 用户的旧密码 * @param newPasswrod 用户的新密码 */ void changePasswrod(Integer uid,String username,String oldPassword,String newPasswrod); 3.IUserServiceImpl 实体类的方法 @Override public void changePasswrod(Integer uid, String username, String oldPassword, String newPasswrod) { //先查询用户数据是否为空或者逻辑删除 User res = userMapper.findByUid(uid); if(res==null||res.getIsDelete()==1){ throw new UserNotFoundException(\"用户数据不存在\"); } //数据库密码和旧密码对比 String dataPassword = res.getPassword(); String md5Password = getMD5Password(oldPassword, res.getSalt()); if(!dataPassword.equals(md5Password)){ throw new PasswordNotMatchException(\"密码不匹配\"); } //插入新密码插入数据库，更新操作人和操作时间 String newPass = getMD5Password(newPasswrod, res.getSalt()); Integer row = userMapper.updatePasswordByUid(uid, newPass, username, new Date()); if(row!=1){ throw new InsertException(\"更新数据时产生未知异常\"); } } ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:7:2","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.6.3 后端-控制层 1.在全局异常处理机制中添加对业务层异常的处理 2.设计请求 请求路径 /user/change_password 请求参数 @RequestParam(“oldPassword”) String oldPassword, @RequestParam(“newPassword”) String newPassword, HttpSession session 请求类型 post 响应类型 JsonResult\u003c Void\u003e 3.处理请求 //用户更改密码 @RequestMapping(value = \"/change_password\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e changePassword(@RequestParam(\"oldPassword\") String oldPassword, @RequestParam(\"newPassword\") String newPassword, HttpSession session){ //获取Uid Integer uid = getUserIdFromSession(session); String username = getUsernameFromSession(session); userService.changePasswrod(uid,username,oldPassword,newPassword); //在用户修改密码之后清除session中保存的密码 session.setAttribute(\"uid\",null); return new JsonResult\u003c\u003e(OK,\"修改密码成功\"); } ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:7:3","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.6.4 前端页面 1.在用户修改完密码之后，重新定向为index.html 2.\u0008在后端控制层清楚掉uid值，使用户重新登陆 \u003cscript type=\"text/javascript\"\u003e $(document).ready(function () { $(\"#btn-change-password\").click(function () { if ($(\"#oldPwd\").val() == \"\" || $(\"#newPwd\").val() == \"\" || $(\"#rePwd\").val() == \"\"){ $(\"#error-msg\").text(\"请填写完信息后再提交！\"); return false; } //验证密码是否符合规则 let passCheck = /^\\w{5,12}$/; let password = $(\"#newPwd\").val(); if (!passCheck.test(password)){ $(\"#error-msg\").text(\"新密码必须是5-12位的字母和数字\"); return false; }else { $(\"#error-msg\").empty() } //验证确认密码和密码是否相同 let rePass = $(\"#rePwd\").val(); if (rePass !== password){ $(\"#error-msg\").text(\"密码不一致\"); return false; }else { $(\"#error-msg\").empty() } $(\"#btn-change-password\").click(function() { $.ajax({ url: \"/user/change_password\", type: \"POST\", data: $(\"#form-change-password\").serialize(), dataType: \"json\", success: function(json) { if (json.state === 200){ alert(\"密码已更改成功，请重新登录\") //跳转至首页，让用户重新登录 location.href = \"login.html\" }else { $(\"#error-msg\").html(json.message) } }, error: function (xhr) { alert(\"您的登录信息已经过期，请重新登录！HTTP响应码：\" + xhr.status); location.href = \"login.html\"; } }); }); }); }); \u003c/script\u003e ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:7:4","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.7 个人资料 3.7.1 后端持久层 1.编写Sql 需要更新phone、email、gender、modified_user ,modified_time这五个字段 //更新的sql语句 update t_user set phone = #{phone}, email = #{email}, gender = #{gender}, modified_user = #{modifiedUser}, modified_time = #{modifiedTime} where uid = #{uid} 2.定义Mapper接口抽象方法 /** * 根据用户的id查询用户数据 * * @param uid 用户Uid * @return 返回用户数据或者null */ User findByUid(Integer uid); /** * 更新用户信息 * @param user 用户数据 * @return 返回影响的行数 */ Integer updateInfoByUid(User user); 3.编写Mapper接口的映射文件 \u003c!--User findByUid(Integer uid);--\u003e \u003cselect id=\"findByUid\" resultType=\"com.zxl.store.entity.User\"\u003e SELECT * FROM t_user WHERE uid = #{uid} \u003c/select\u003e \u003cupdate id=\"updateInfoByUid\"\u003e UPDATE t_user SET \u003cif test=\"phone!=null\"\u003ephone = #{phone},\u003c/if\u003e \u003cif test=\"email!=null\"\u003eemail = #{email},\u003c/if\u003e \u003cif test=\"gender!=null\"\u003egender = #{gender},\u003c/if\u003e modified_time = #{modifiedTime}, modified_user = #{modifiedUser} WHERE uid = #{uid} \u003c/update\u003e 4.单元测试 3.7.2 后端-业务层 1.定义异常（无） 2.定义IUserService接口的抽象方法 3.实现抽象方法，编辑业务逻辑 1.定义异常 （无） 2.定义IUserService接口的抽象方法 /** * 根据用户的id查询用户的数据 * @param uid 用户id * @return 返回查询到的用户 或者 null */ User getByUid(Integer uid); /** * 更新用户的数据操作 * @param uid 用户的id * @param username 用户名 * @param user 用户对象数据 */ void changeInfo(Integer uid,String username,User user); 3.实现抽象方法，编写业务逻辑 @Override public User getByUid(Integer uid) { User res = userMapper.findByUid(uid); if(res==null||res.getIsDelete()==1){ throw new UserNotFoundException(\"用户数据不存在\"); } User usr = new User(); //防止重要内容泄漏 usr.setUsername(res.getUsername()); usr.setPhone(res.getPhone()); usr.setEmail(res.getEmail()); usr.setGender(res.getGender()); return usr; } /*User对象中的phone/email/gender 手动将uid/username/封装*/ @Override public void changeInfo(Integer uid, String username, User user) { User res = userMapper.findByUid(uid); if(res==null||res.getIsDelete()==1){ throw new UserNotFoundException(\"用户数据不存在\"); } user.setUid(uid); user.setUsername(username); user.setModifiedUser(username); user.setModifiedTime(new Date()); Integer row = userMapper.updateInfoByUid(user); if(row!=1){ throw new InsertException(\"更新时数据产生未知异常\"); } } 4.单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:8:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.7.3 后端-控制层 1.无异常，不需要处理 2.设计请求 请求路径 /user/change_info 请求参数 User user,HttpSession session 请求类型 post 响应类型 JsonResult 3.处理请求 //修改用户信息 @RequestMapping(value = \"/change_info\",method = RequestMethod.POST) public JsonResult\u003cVoid\u003e changeInfo(User user,HttpSession session){ //User数据只有四部分 用户电话邮箱性别 System.out.println(user.getUsername()+user.getEmail()+ user.getPhone()+user.getGender()); //Service内部已经重新写入 userService.changeInfo(getUserIdFromSession(session),getUsernameFromSession(session),user); return new JsonResult\u003c\u003e(OK,\"修改信息成功\"); } //获取用户信息 @RequestMapping(value = \"/get_by_uid\",method = RequestMethod.GET) public JsonResult\u003cUser\u003e getByUid(HttpSession session){ Integer uid = getUserIdFromSession(session); User user = userService.getByUid(uid); //将用户名、id、电话、邮箱、性别进行回传 User newUser = new User(); newUser.setUsername(user.getUsername()); newUser.setUid(user.getUid()); newUser.setGender(user.getGender()); newUser.setPhone(user.getPhone()); newUser.setEmail(user.getEmail()); newUser.setAvatar(user.getAvatar()); return new JsonResult\u003c\u003e(OK,newUser); } ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:8:1","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.7.4 前端页面 1.第一个ajax请求在用户信息页面加载完成后自动发送，并根据返回值通过js的id选择器 ​ 找到对应的元素并修改其属性值 2.第二个ajax请求在用户点击修改按钮之后先提示是否修改，再根据其选择进行处理， ​ 同理根据结果利用js的id选择器找到对应的元素并修改其属性值 \u003cscript type=\"text/javascript\"\u003e $(document).ready(function() { $.ajax({ url: \"/user/get_by_uid\", type: \"GET\", dataType: \"json\", success: function(json) { if (json.state == 200) { console.log(\"username=\" + json.data.username); console.log(\"phone=\" + json.data.phone); console.log(\"email=\" + json.data.email); console.log(\"gender=\" + json.data.gender); $(\"#username\").val(json.data.username); $(\"#phone\").val(json.data.phone); $(\"#email\").val(json.data.email); let radio = json.data.gender == 0 ? $(\"#gender-female\") : $(\"#gender-male\"); radio.prop(\"checked\", \"checked\"); } else { alert(\"获取用户信息失败！\" + json.message); } } }); //给用户更改信息绑定点击事件 $(\"#btn-change-info\").click(function () { //根据用户选择状态决定是否发生ajax请求 if (confirm(\"确定要修改吗？\")){ let phone = $(\"#phone\").val(); let email = $(\"#email\").val(); if (phone == \"\" || email == \"\"){ $(\"#error-msg\").html(\"请先填写需要修改的信息！\"); return false; } let checkPhone = /^[1][3,4,5,7,8][0-9]{9}$/; if (!checkPhone.test(phone)){ $(\"#error-msg\").html(\"手机号不符合要求！\"); return false; } //验证邮箱是否符合规则 let checkEmail = /^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/; if (!checkEmail.test(email)){ $(\"#error-msg\").html(\"邮箱不符合要求！\"); return false; } $.ajax({ url : \"/user/change_info\", type: \"post\", data: $(\"#form-change-info\").serialize(),//获取表单的所有内容 dataType: \"json\", success: function (res) { if (res.status === 200){ alert(\"修改成功！\") //网页刷新 location.reload(); }else { $(\"#error-msg\").html(res.message); } }, error: function (error) { alert(\"服务器出现故障，请等待攻城狮修复！！\") } }); } }) }); \u003c/script\u003e ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:8:2","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.8 头像上传 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:9:0","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.8.1 后端-持久层 1.编写sql 对应的avatar字段保存头像地址 UPDATE t_user SET avatar=#{avatar}, modified_user=#{modifiedUser}, modified_time=#{modifiedTime} WHERE uid = #{uid} 2.定义Mapper接口的抽象方法 /** * 根据用户的Uid修改头像 * @param uid 用户Uid * @param avatar 头像数据 * @param modifiedUser 表示修改的执行者 * @param modifiedTime 表示修改的时间 * @return */ Integer updateAvatarByUid(@Param(\"uid\") Integer uid, @Param(\"avatar\") String avatar, @Param(\"modifiedUser\") String modifiedUser, @Param(\"modifiedTime\") Date modifiedTime); 3.编写Mapper接口的映射文件 \u003cupdate id=\"updateAvatarByUid\"\u003e UPDATE t_user SET avatar=#{avatar}, modified_user=#{modifiedUser}, modified_time=#{modifiedTime} WHERE uid = #{uid} \u003c/update\u003e 4.单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:9:1","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.8.2 后端-业务层 1.异常规划 例如用户数据不存在，服务器宕机等 2.定义service层接口抽象方法 3.实现类重写抽象方法，编写业务处理逻辑 2.定义Service层接口抽象方法 /** * 更新用户的头像操作 * @param uid 用户id * @param avatar 用户头像路径 * @param username 修改的执行者 */ void changeAvatar(Integer uid,String avatar,String username); 3.实现类重写抽象方法，编写业务层逻辑 /**/ @Override public void changeAvatar(Integer uid, String avatar, String username) { //查询当前的用户数据是否存在 User res = userMapper.findByUid(uid); if(res==null||res.getIsDelete()==1){ throw new UserNotFoundException(\"用户数据不存在\"); } Integer row = userMapper.updateAvatarByUid(uid, avatar, username, new Date()); if(row!=1){ throw new InsertException(\"更新时数据产生未知异常\"); } } 4 .单元测试 ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:9:2","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.8.3 后端-控制层 1.处理控制层和业务层异常，将控制层异常加入全局异常处理@ExceptionHandler的值中 考虑到控制层接口前端数据也有可能出现异常，因此控制层也要进行异常控制 创建一个FileUploadException继承RunTimeException，其余异常继承此异常 ①文件为空异常 ②文件大小超出限制异常 ③文件状态异常 ④文件类型不符异常 ⑤文件读取IO异常 2.设计请求 请求路径：/change_avatar 请求参数：MultipartFile file，Httpsession session 请求类型：post 响应类型：JsonResult\u003c Void\u003e 3.处理请求 ①创建一个Controller专门处理文件的上传和下载 ②将文件的下载地址保存到数据库 /** * @author zxl * @description * @date 2022/10/30 */ @RestController @RequestMapping(\"/file\") public class FileController extends BaseController{ @Autowired private IUserService userService; /*设置上传文件的最大值*/ public static final int AVATAR_MAX_SIZE=10 * 1024 * 1024; /*限制上传文件的类型*/ public static final List\u003cString\u003e AVATAR_TYPES = new ArrayList\u003c\u003e(); static { AVATAR_TYPES.add(\"image/jpeg\"); AVATAR_TYPES.add(\"image/jpg\"); AVATAR_TYPES.add(\"image/png\"); AVATAR_TYPES.add(\"image/bmp\"); AVATAR_TYPES.add(\"image/gif\"); } /** * MultipartFile接口时SpringMVC提供的一个接口，这个接口为我们包装了 * 获取文件数据(任何类型的文件File都可以),Springboot整合了SpringMVC * 只需要在处理请求的方法参数列表上声明一个参数为MultipartFile即可 * @param session * @param file * @return */ @PostMapping public JsonResult\u003cString\u003e changeAvatar(HttpSession session, @RequestParam(\"file\") MultipartFile file){ //判断文件是否为null if(file.isEmpty()){ throw new FileEmptyException(\"文件为空\"); } //判断文件大小 if(file.getSize()\u003eAVATAR_MAX_SIZE){ throw new FileSizeException(\"文件大小超出限制\"); } // 判断上传的文件类型是否超出限制 String contentType = file.getContentType(); // boolean contains(Object o)：当前列表若包含某元素，返回结果为true；若不包含该元素，返回结果为false if (!AVATAR_TYPES.contains(contentType)) { // 是：抛出异常 throw new FileTypeException(\"不支持使用该类型的文件作为头像，允许的文件类型：\" + AVATAR_TYPES); } //获取当前文件的绝对路径 //String parent = session.getServletContext().getRealPath(\"upload\"); String parent = \"/Users/zhaoxinlei/workspace/StoreRebuild/store/src/main/resources/static/avatar\"; System.out.println(parent); //保存头像文件的文件夹 File dir = new File(parent); if(!dir.exists()){ dir.mkdirs(); } //保存头像文件的文件名 String suffix =\"\"; String originalFilename = file.getOriginalFilename(); int beginIndex = originalFilename.lastIndexOf(\".\"); if(beginIndex\u003e0){ suffix = originalFilename.substring(beginIndex); } String filename = UUID.randomUUID().toString() + suffix; // 创建文件对象，表示保存的头像文件 File dest = new File(dir,filename); //执行保存文件操作 try{ file.transferTo(dest); }catch (IllegalStateException e){ //抛出异常 throw new FileStateException(\"文件状态异常，可能文件已被移动或者删除\"); }catch (IOException e){ //抛出异常 throw new FileUploadIOException(\"上传文件时读写错误,请稍后重新尝试\"); } //从Session中获取Uid和username Integer uid = getUserIdFromSession(session); String username = getUsernameFromSession(session); //将头像写入数据库 userService.changeAvatar(uid,filename,username); //返回成功头像路径 String avatar = \"../avatar/\"+filename; System.out.println(filename); System.out.println(avatar); return new JsonResult\u003c\u003e(OK,avatar); } } ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:9:3","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["SpringBoot","Mybatis"],"content":"3.8.4. 前端页面 \u003cscript type=\"text/javascript\"\u003e $(document).ready(function () { //网页加载完成之前自动发送ajax请求 $.ajax({ url: \"/user/get_by_uid\", type: \"get\", dataType: \"json\", success:function (res) { //判断用户是首次注册还是老用户 if (res.data.avatar !== null \u0026\u0026res.data.avatar !== \"\" ){ //设置用户头像 $(\"#img-avatar\").attr(\"src\",\"../avatar/\"+res.data.avatar) }else{ //设置为默认头像 $(\"#img-avatar\").attr(\"src\",\"../images/index/user.jpg\") } }, error:function (err) { alert(err.message()) } }) $(\"#btn-change-avatar\").click(function() { $.ajax({ url: \"/file\", type: \"POST\", data: new FormData($(\"#form-change-avatar\")[0]), dataType: \"JSON\", processData: false, // processData处理数据 contentType: false, // contentType发送数据的格式 success: function(json) { if (json.state == 200) { $(\"#img-avatar\").prop(\"src\", json.message); console.log($(\"#img-avatar\").prop(\"src\")); } else { alert(\"修改失败！\" + json.message); } }, error: function(xhr) { alert(\"您的登录信息已经过期，请重新登录！HTTP响应码：\" + xhr.status); location.href = \"login.html\"; } }); }); }); \u003c/script\u003e ","date":"2022-10-13","objectID":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:9:4","tags":["computerStore"],"title":"SpringBoot项目-用户管理","uri":"/springboot%E9%A1%B9%E7%9B%AE-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"}]