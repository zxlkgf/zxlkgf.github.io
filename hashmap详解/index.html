<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>HashMap详解 - Cyo&#39;s Website</title><meta name="Description" content="Cyo&#39;s website"><meta property="og:title" content="HashMap详解" />
<meta property="og:description" content="1. HashMap源码详解 基于JDK1.8 1.1HashMap简介 HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://zxlkgf.github.io/hashmap%E8%AF%A6%E8%A7%A3/" /><meta property="og:image" content="http://zxlkgf.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-19T19:15:49+09:00" />
<meta property="article:modified_time" content="2022-11-19T19:15:49+09:00" /><meta property="og:site_name" content="Cyo&#39;s website" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://zxlkgf.github.io/logo.png"/>

<meta name="twitter:title" content="HashMap详解"/>
<meta name="twitter:description" content="1. HashMap源码详解 基于JDK1.8 1.1HashMap简介 HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程"/>
<meta name="application-name" content="Cyo&#39;s website">
<meta name="apple-mobile-web-app-title" content="Cyo&#39;s website"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://zxlkgf.github.io/hashmap%E8%AF%A6%E8%A7%A3/" /><link rel="prev" href="http://zxlkgf.github.io/%E9%9B%86%E5%90%88%E7%B1%BB/" /><link rel="next" href="http://zxlkgf.github.io/hashmap-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "HashMap详解",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/zxlkgf.github.io\/hashmap%E8%AF%A6%E8%A7%A3\/"
        },"genre": "posts","keywords": "HashMap","wordcount":  11539 ,
        "url": "http:\/\/zxlkgf.github.io\/hashmap%E8%AF%A6%E8%A7%A3\/","datePublished": "2022-11-19T19:15:49+09:00","dateModified": "2022-11-19T19:15:49+09:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "Cyo"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Cyo&#39;s Website"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/headeravatar.jpeg"
        data-srcset="/headeravatar.jpeg, /headeravatar.jpeg 1.5x, /headeravatar.jpeg 2x"
        data-sizes="auto"
        alt="/headeravatar.jpeg"
        title="/headeravatar.jpeg" /><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="请输入想要查找的标题" id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Cyo&#39;s Website"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/headeravatar.jpeg"
        data-srcset="/headeravatar.jpeg, /headeravatar.jpeg 1.5x, /headeravatar.jpeg 2x"
        data-sizes="auto"
        alt="/headeravatar.jpeg"
        title="/headeravatar.jpeg" /><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="请输入想要查找的标题" id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">HashMap详解</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/zxlkgf" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Cyo</a></span>&nbsp;<span class="post-category">included in <a href="/categories/%E9%9D%A2%E8%AF%95/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>面试</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-11-19">2022-11-19</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;11539 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;24 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="true">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#11hashmap简介">1.1HashMap简介</a></li>
  </ul>

  <ul>
    <li><a href="#21-jdk18之前">2.1 JDK1.8之前</a></li>
    <li><a href="#22-jdk18之后">2.2 JDK1.8之后</a></li>
    <li><a href="#23-hashmap类内成员">2.3 HashMap类内成员</a></li>
    <li><a href="#24-构造方法">2.4 构造方法</a></li>
    <li><a href="#25-node节点源码">2.5 Node节点源码</a></li>
    <li><a href="#26-treenode节点源码">2.6 TreeNode节点源码</a></li>
    <li><a href="#3内部方法">3.内部方法</a>
      <ul>
        <li><a href="#31-tablesizefor">3.1 tableSizeFor()</a></li>
        <li><a href="#32-putmapentries">3.2 putMapEntries()</a></li>
        <li><a href="#33-put方法流程">3.3 put()方法流程</a></li>
        <li><a href="#34-nodekv-resize">3.4 Node&lt;K,V&gt;[] resize()</a></li>
        <li><a href="#35-get方法">3.5 get()方法</a></li>
        <li><a href="#36-remove方法">3.6 remove()方法</a></li>
      </ul>
    </li>
    <li><a href="#4treenode源码">4.TreeNode源码</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="1-hashmap源码详解">1. HashMap源码详解</h1>
<p>基于JDK1.8</p>
<hr>
<h2 id="11hashmap简介">1.1HashMap简介</h2>
<p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的，且不能保证元素的存储顺序。查询和修改的速度很快，能到到O(1)的平均复杂度。</p>
<pre tabindex="0"><code class="language-context" data-lang="context">HashMap可以存储null的key和value
null作为key键只能有一个
null作为value值可以有多个
</code></pre><hr>
<h1 id="2-底层数据结构分析">2 底层数据结构分析</h1>
<h2 id="21-jdk18之前">2.1 JDK1.8之前</h2>
<pre tabindex="0"><code class="language-context" data-lang="context">HashMap底层时数组加单向链表，结合在一起使用也就是散列链表。
将key的hash值进行取模运算获取index就是即将存放的元素的位置，然后到对应的链表进行
put和get操作。
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 源码分析1：hash(key)
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样 = 扰动函数 = 使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算
</span></span></span><span class="line"><span class="cl"><span class="cm"> * JDK 1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="c1">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">final</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="n">Object</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置了哈希种子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hashSeed</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">0</span> <span class="o">!=</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="k">instanceof</span> <span class="n">String</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Hashing</span><span class="o">.</span><span class="na">stringHash32</span><span class="o">((</span><span class="n">String</span><span class="o">)</span> <span class="n">k</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Hash种子参与到了key的Hash值计算当中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">h</span> <span class="o">^=</span> <span class="n">k</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// This function ensures that hashCodes that differ only by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// constant multiples at each bit position have a bounded
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// number of collisions (approximately 8 at default load factor).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">h</span> <span class="o">^=</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">20</span><span class="o">)</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">12</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">h</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">7</span><span class="o">)</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">4</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><hr>
<h2 id="22-jdk18之后">2.2 JDK1.8之后</h2>
<pre tabindex="0"><code>HashMap在解决哈希冲突时有了较大的变化,当链表长度大于阈值(默认为8)(将链表转换成红黑树
前会判断,如果当前数组的长度小于 64,那么会选择先进行数组扩容,而不是转换为红黑树)时,将链
表转化为红黑树,以减少搜索时间。
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. 取hashCode值： h = key.hashCode() 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">h</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// key.hashCode()：返回散列值也就是hashcode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ^ ：按位异或
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">())</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">16</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// a. 当key = null时，hash值 = 0，所以HashMap的key 可为null      
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// b. 当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后 对哈希码进行扰动处理： 按位 异或（^） 哈希码自身右移16位后的二进制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><hr>
<h2 id="23-hashmap类内成员">2.3 HashMap类内成员</h2>
<p>首先先来明确几个HashMap的概念：</p>
<ul>
<li>HashMap里面数组结构的每一个存储元素的位置被称为桶</li>
<li>桶中存放的数据被称为bin（bin这个概念会在HashMap源码中大量出现）</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;,</span> <span class="n">Cloneable</span><span class="o">,</span> <span class="n">Serializable</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 序列号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="n">362498820763181265L</span><span class="err">；</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 默认的初始容量是16
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">4</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 最大容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">30</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 负载因子，当数组的存储比例达到了0.75，数组就会进行两倍扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">float</span> <span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">=</span> <span class="n">0</span><span class="o">.</span><span class="na">75f</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//链表转成树的阈值，链表中的元素个数大于8，变为红黑树和MIN_TREEIFY_CAPACITY一起决定的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="n">8</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//树转换成链表的阈值 树中的元素小于6，转换为链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">UNTREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="n">6</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//最小转成树的容量，当数组长度达到64转换为红黑树-和TREEIFY_THRESHOLD一起决定的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MIN_TREEIFY_CAPACITY</span> <span class="o">=</span> <span class="n">64</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 存储元素的数组，数组长度总是2的幂次倍
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">k</span><span class="o">,</span><span class="n">v</span><span class="o">&gt;[]</span> <span class="n">table</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 存放具体元素的集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">transient</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">map</span><span class="o">.</span><span class="na">entry</span><span class="o">&lt;</span><span class="n">k</span><span class="o">,</span><span class="n">v</span><span class="o">&gt;&gt;</span> <span class="n">entrySet</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 存放元素的个数，表示当前HashMap包含的键值对数量。注意这个不等于数组的长度。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">transient</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 每次扩容和更改map结构的计数器，表示当前HashMap修改次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">transient</span> <span class="kt">int</span> <span class="n">modCount</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//扩容的阈值，当实际大小为(16 * 0.75 = 12) 阈值时开始扩容 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">threshold</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 加载因子（负载因子）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">final</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>TREEIFY_THRESHOLD: 一个bin是否需要被转化成红黑树的阈值，当bin内元素超过TREEIFY_THRESHOLD 的值的时候，该bin将会被转化为红黑树，以提高查询效率。</p>
<p>UNTREEIFY_THRESHOLD:一个bin是否需要从红黑树转化为链表的阈值，当bin内元素小于UNTREEIFY_THRESHOLD,则该bin将会被转化为链表</p>
<p>MIN_TREEIFY_CAPACITY:最小转化树的容量，即当数组长度达到64转化为红黑树</p>
<p>(MIN_TREEIFY_CAPACITY不太理解)</p>
<hr>
<h2 id="24-构造方法">2.4 构造方法</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">//默认无参构造方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="nf">HashMap</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//将默认的负载因子赋值给成员变量loadFactor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">;</span> <span class="c1">// all   other fields defaulted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 包含另一个“Map”的构造函数，包含另一个Map的映射，如果被映射的Map是一个null会抛出空指针异常。负载因子是默认的
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 直接传入存储了要添加进HashMap的key-value对的map，来构造HashMap
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//将默认的负载因子赋值给成员变量loadFactor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//调用PutMapEntries()来完成HashMap的初始化赋值过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">putMapEntries</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span><span class="c1">//下面会分析到这个方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 指定“容量大小”的构造函数，直接使用默认负载因子0.75
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">,</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* 构造一个空的HashMap并指定初始容量和负载因子。
</span></span></span><span class="line"><span class="cl"><span class="cm">* 要注意HashMap源码里面并没有专门的一个属性来存储数组的容量，而是通过threshold来简介限制数组容量的
</span></span></span><span class="line"><span class="cl"><span class="cm">* 通过将自定义初始化数组容量传入tableSizeFor()方法，计算得出initialCapacity容量大小应该对应的阈值threshold大小
</span></span></span><span class="line"><span class="cl"><span class="cm">* 这样当数组内元素数大于threshold，就会触发扩容操作，间接限定了数组容量大小
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//如果初始容量小于0，抛出非法参数异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Illegal initial capacity: &#34;</span> <span class="o">+</span> <span class="n">initialCapacity</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//如果初始容量大于最大的容量也就是2^30,那么就按照最大的初始容量赋值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//如果负载因子小于0或者是NaN（float NaN = 0.0f / 0.0f;）也会抛出非法参数异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="n">0</span> <span class="o">||</span> <span class="n">Float</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Illegal load factor: &#34;</span> <span class="o">+</span> <span class="n">loadFactor</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置重载因子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">loadFactor</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用tableSizeFor方法计算出不小于initialCapacity的最小的2的幂的结果，并赋给成员变量threshold
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 注意，这里赋给threshold并不是扩容阈值，只是临时赋值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//此时HashMap还没有创建数组，当插入数据的时候会判断该HashMap是否已经初始化，那个时候就会执行resize()方法进行一次扩容,就会重新计算一正确的扩容阈值赋值给threshold
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><hr>
<h2 id="25-node节点源码">2.5 Node节点源码</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Basic hash bin node, used for most entries.  (See below for
</span></span></span><span class="line"><span class="cl"><span class="cm"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="c1">//继承了Map.Entry&lt;K,V&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span><span class="c1">//常量:key的hash值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="o">;</span><span class="c1">//键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">V</span> <span class="n">value</span><span class="o">;</span><span class="c1">//值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span><span class="c1">//下一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//有参构造方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">final</span> <span class="n">K</span> <span class="nf">getKey</span><span class="o">()</span>        <span class="o">{</span> <span class="k">return</span> <span class="n">key</span><span class="o">;</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">final</span> <span class="n">V</span> <span class="nf">getValue</span><span class="o">()</span>      <span class="o">{</span> <span class="k">return</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">final</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">key</span> <span class="o">+</span> <span class="s">&#34;=&#34;</span> <span class="o">+</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//重写hashCode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">^</span> <span class="n">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">final</span> <span class="n">V</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">V</span> <span class="n">newValue</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">value</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//重写equals方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,?&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,?&gt;)</span><span class="n">o</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(</span><span class="n">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">())</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="n">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">()))</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">//创建Node节点的方法
</span></span></span><span class="line"><span class="cl"><span class="c1">// Create a regular (non-tree) node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">newNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;&gt;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// For conversion from TreeNodes to plain nodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">replacementNode</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;&gt;(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">value</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><hr>
<h2 id="26-treenode节点源码">2.6 TreeNode节点源码</h2>
<p>TreeNode是用来实现红黑树的树节点。</p>
<p>红黑树是一个二叉搜索树，他在每个节点增加了一个存储位去记录节点颜色(黑，红)。</p>
<p>红黑树有以下四个性质</p>
<p>1.节点是红色或者黑色</p>
<p>2.根结点一定是黑色</p>
<p>3.所有叶子都是黑色(指的是空节点)(叶子节点的空节点为黑色)</p>
<p>4.每个红色节点的两个子节点都是黑色(从叶子到根的所有路径上不能有两个红色节点)</p>
<p>5.所有根节点到叶子(空节点)节点的路径中，包含的黑色节点数相同</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">LinkedHashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">parent</span><span class="o">;</span>  <span class="c1">// red-black tree links
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">left</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">right</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">;</span>    <span class="c1">// needed to unlink next upon deletion
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">boolean</span> <span class="n">red</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">val</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">super</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Returns root of tree containing this node.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">root</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="k">this</span><span class="o">,</span> <span class="n">p</span><span class="o">;;)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">内部方法省略
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><hr>
<h2 id="3内部方法">3.内部方法</h2>
<hr>
<h3 id="31-tablesizefor">3.1 tableSizeFor()</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 计算大于等于参数的第一个2的幂次方
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 例如，1返回1，3返回4，6返回8
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">tableSizeFor</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//容量减1，为了防止原本就是2的幂次方，而导致最后求得的结果为2的幂次方的2倍
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//算法部分，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">4</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">8</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">16</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">1</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">:</span> <span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span></code></pre></div><hr>
<p>其中:</p>
<p>n |=n&raquo;&gt;1 即  n = n | n &raquo;&gt; 1;     &raquo;&gt;为无符号右移</p>
<hr>
<p>tableSizeFor()函数:</p>
<p>对任意十进制数转换为2的整数幂，结果是这个数本身的最高有效位的前一位变成1，最高有效位以及其后的位都变为0。</p>
<p>通过上面理论基础，我们可以得出该算法的核心思想是，先将最高有效位以及其后的位都变为1，最后再+1，就进位到前一位变成1，其后所有的满2变0。所以关键是如何将最高有效位后面都变为1。</p>
<hr>
<h3 id="32-putmapentries">3.2 putMapEntries()</h3>
<p>下面我们再来看看在传入Map参数的构造方法中调用的putMapEntries()方法。这个方法调用了HashMap的resize()扩容方法和putVal()存入数据方法。</p>
<p>putMapEntries函数会被HashMap的拷贝构造函数public HashMap(Map&lt;? extends K, ? extends V&gt; m)或者Map接口的putAll函数（被HashMap给实现了）调用到。该函数使用的是默认修饰符（default），也就是只有包访问权限，只能被本类或者该包下的类访问到，所以一般情况下用户无法调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该方法的作用：将传入的子Map中的全部元素逐个添加到HashMap中
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param evict 最初构造此Map时为false，否则为true（中继到afterNodeInsertion方法）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">final</span> <span class="kt">void</span> <span class="nf">putMapEntries</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//获取子Map内数据大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 判断table是否已经初始化  如果table=null一般就是构造函数来调用的putMapEntries，或者构造后还没放过任何元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">table</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// pre-size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 如果未初始化，则计算HashMap的最小需要的容量（即容量刚好不大于扩容阈值）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 这里Map的大小s就被当作HashMap的扩容阈值，然后用传入Map的大小除以负载因子就能得到对应的HashMap的容量大小（当前m的大小 / 负载因子 = HashMap容量）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 先不考虑容量必须为2的幂，那么下面括号里会算出来一个容量，使得size刚好不大于阈值。但这样会算出小数来，但作为容量就必须向上取整，所以这里要加1。此时ft可以临时看作HashMap容量大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">((</span><span class="kt">float</span><span class="o">)</span><span class="n">s</span> <span class="o">/</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">.</span><span class="na">0F</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//比较最大容量与ft，取小值； 到这里t暂时表示HashMap的容量大小。如果是将ft浮点型赋值给t整形，因为前面加了1.0f,这里也就实现了向上取整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">ft</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">                     <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">ft</span> <span class="o">:</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 只有在算出来的容量t &gt; 当前暂存的容量(容量可能会暂放到阈值上的,刚使用构造函数构造出来的HashMap并且没有存入元素时，容量大小就会被暂时存在threshold中)时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 才会用t计算出新容量，暂时存放到阈值上,在后面触发resize()扩容的时候会对threshold重新计算正确的阈值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//如果当前Map已经初始化,且这个map中的元素个数大于扩容的阀值就得扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//这种情况属于预先扩大容量，再put元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">resize</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//遍历map,将map中的key和value都添加到HashMap中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">K</span> <span class="n">key</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">V</span> <span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 调用HashMap的put方法的具体实现方法putVal来对数据进行存放。该方法的具体细节在后面会进行讲解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// putVal可能也会触发resize
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">evict</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><hr>
<h3 id="33-put方法流程">3.3 put()方法流程</h3>
<p>HashMap只提供了put用于添加元素，putval也是使用的默认修饰符，因此只能被本类或者该包下的类访问到，所以putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p>
<p>putVal()添加元素的分析如下:</p>
<p>1.如果当前元素为空，直接插入元素</p>
<p>2.如果当前元素非空，就要和插入的key比较，如果key相同就直接覆盖</p>
<p>3.如果当前元素非空，如果key不同，就要将数据插入链表末端</p>
<p>4.如果当前元素非空，如果key不同，判断p是否是一个树节点，如果是就调用((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"> <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Implements Map.put and related methods.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 实现了map的put和相关方法
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param hash  key的hash值（key的hash高16位+高16位与低16位的异或运算）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param key 键
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param value 值  
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param onlyIfAbsent onlyIfAbsent为true的时候不要修改已经存在的值，如果onlyIfAbsent为false，当插入的元素已经在HashMap中已经拥有了与其key值和hash值相同的元素，仍然需要把新插入的value值覆盖到旧value上。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param evict evict如果为false表示构造函数调用
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 返回旧的value值（在数组桶或链表或红黑树中找到存在与插入元素key值和hash值相等的元素，就返回这个旧元素的value值），如果没有发现相同key和hash的元素则返回null
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span><span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="c1">//用来临时存放数组table的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span>    <span class="c1">//用来临时存放数组tab中的bin的内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>    <span class="c1">//n存放Hashmap大小，i表示插入数据的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//如果table为空或者table的长度为0 调用resize()为其扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//i = (n - 1) &amp; hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//p = tab[i = (n - 1) &amp; hash] 将计算出的数组索引对应的数据赋值给节点p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//判断p是否为null，即当前桶没有哈希冲突，则直接把键值对插入空间位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="o">{</span><span class="c1">//说明p不为空，表示这个位置已经有值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">K</span> <span class="n">k</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//p.hash == hash 判断当前bin内内容的hash是否与插入key的hash相等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//((k = p.key) == key 比较两个key的地址是否相等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//(key != null &amp;&amp; key.equals(k))执行到这里说明key的地址不同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//判断key不为空，并且判断两个key内容是否相等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//两个数据key相同，则将旧数据交给e保存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//hash值不等，或者key值不等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//判断p是不是红黑树节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//如果是则调用树的putTreeVal放入树中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">e</span> <span class="o">=</span> <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//key地址不同内容不同，p不为树节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//需要插入链表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//在链表的末尾插入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="o">;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//e = p.next 将p的下一个数据赋值给
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//e = p.next) == null)判断是否到达链表的末尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">//创建一个新的Node节点插入尾部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">//如果当前链表的长度超过8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="c1">// -1 for 1st
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">//转换为红黑树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//继续判断p的下一个节点的数据是否与插入数据的hash相等或者值相等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//如果相等就退出插入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//继续循环链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">            表示在桶中找到key值、hash值与插入元素相等的结点
</span></span></span><span class="line"><span class="cl"><span class="cm">            也就是说通过上面的操作找到了重复的键，所以这里就是把该键的值变为新的值，
</span></span></span><span class="line"><span class="cl"><span class="cm">            并返回旧值，这里完成了put方法的修改功能
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// existing mapping for key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//记录旧的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//onlyIfAbsent为false或者旧值为null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span> <span class="o">||</span> <span class="n">oldValue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//用新值替换旧值:e.value 表示旧值  value表示新值 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 替换旧值时会调用的方法（默认实现为空）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 返回旧值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 结构性修改，记录HashMap被修改的次数，主要用于多线程并发时候
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//++size当前HashMap存放的键值对进行更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//如果大于当前的threshold阈值，则对齐进行扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">resize</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 插入成功时会调用的方法（默认实现为空）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">     <span class="c1">// 没有找到原有相同key和hash的元素，则直接返回Null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><hr>
<h4 id="331-内部实现为空的方法">3.3.1 内部实现为空的方法</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Callbacks to allow LinkedHashMap post-actions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">afterNodeAccess</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">afterNodeInsertion</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">afterNodeRemoval</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>
</span></span></code></pre></div><p>在putVal()方法中替换旧值和插入成功的时候都调用了上面其中的两个方法，这三个方法是HashMap类中的方法，但是我们查看源码后会发现这三个方法都是空的方法。其实这三个方法是为继承HashMap的LinkedHashMap类服务的。</p>
<p>LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用 LinkedHashMap</p>
<hr>
<h4 id="332-treeifybin方法">3.3.2 treeifyBin()方法</h4>
<p>将所有的节点转换成树形节点，并且将链接的链表线索化，即为每个二叉树的节点添加前驱和后继节点，形成线索，构造出双链表结构。再调用treeify()方法构造红黑树结构关系。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 将数组指定位置的链表转为红黑树
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param tab 数组
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param hash 将这个hash值所在的索引上的链表转为红黑
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">final</span> <span class="kt">void</span> <span class="nf">treeifyBin</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// n存储当前table的长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// index hash计算得到的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">index</span><span class="o">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// e存储index索引位置的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//如果table为空｜｜或者table的大小小于最小树化阈值就调用resize方法，扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">MIN_TREEIFY_CAPACITY</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">resize</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//(n-1)&amp;hash 获取index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//e = table[index = (n-1) &amp; hash] 获取数组index处的节点，并判断节点是否为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//定义存储树的头节点hd 树的尾节点tl
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">hd</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">tl</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//从e节点开始转换树节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">do</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//新建存储e节点转化为树节点的p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">replacementTreeNode</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果树头节点tl为空，将p赋值给tl
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">tl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">hd</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//否则 将p的前置节点设为tl
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//tl的后置节点设为p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">p</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">tl</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">tl</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//将p赋值给tl
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">tl</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span><span class="c1">//循环条件e=e.next不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//让桶中的第一个元素即数组中的元素指向新建的红黑树的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">((</span><span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">hd</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">hd</span><span class="o">.</span><span class="na">treeify</span><span class="o">(</span><span class="n">tab</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// For treeifyBin
</span></span></span><span class="line"><span class="cl"><span class="c1">// 将Node节点转化为树节点的方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">replacementTreeNode</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">&lt;&gt;(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">value</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><hr>
<h3 id="34-nodekv-resize">3.4 Node&lt;K,V&gt;[] resize()</h3>
<p>下面看一下 resize 方法，面试时最经常问的hashmap扩容机制就在这个地方，注意newCap = oldCap &laquo; 1这句，扩容就在这，扩大两倍。</p>
<p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* Initializes or doubles table size.  If null, allocates in
</span></span></span><span class="line"><span class="cl"><span class="cm">* accord with initial capacity target held in field threshold.
</span></span></span><span class="line"><span class="cl"><span class="cm">* Otherwise, because we are using power-of-two expansion, the
</span></span></span><span class="line"><span class="cl"><span class="cm">* elements from each bin must either stay at same index, or move
</span></span></span><span class="line"><span class="cl"><span class="cm">* with a power of two offset in the new table.
</span></span></span><span class="line"><span class="cl"><span class="cm">*
</span></span></span><span class="line"><span class="cl"><span class="cm">* @return the table
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="nf">resize</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//oldTab存储当前table的临时变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">oldTab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//判断table是否进行初始化 如果为null返回0，否则返回table的长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">oldCap</span> <span class="o">=</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">oldTab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//旧的阈值 如果oldTab为null或者0 oldThr则为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//否则为12(16*0.75)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">oldThr</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">newCap</span><span class="o">,</span> <span class="n">newThr</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//第一次数组容量肯定是0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//判断旧数组容量&gt;0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//如果数组容量超过最大容量，就直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">threshold</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">oldTab</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//没有超过最大容量,新容量为旧容量的两倍
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">newCap</span> <span class="o">=</span> <span class="n">oldCap</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                 <span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//阈值也扩大为两倍
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">newThr</span> <span class="o">=</span> <span class="n">oldThr</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">;</span> <span class="c1">// double threshold
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//如果原容量不大于0 表示原table为null，就判断旧阈值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//如果原table为null，代表其只是调用了构造方法，没有真正初始化table，只有插入数据才会扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">oldThr</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// initial capacity was placed in threshold
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 将原阈值作为容量赋值给newCap当做newCap的值。由之前的源码分析可知，此时原阈值存储的大小就是调用构造函数时指定的容量大小，所以直接将原阈值赋值给新容量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">oldThr</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果原容量不大于0，并且原阈值也不大于0。这种情况说明调用的是无参构造方法，还没有真正初始化HashMap，只有put()数据的时候才会触发扩容操作进而进行初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">else</span> <span class="o">{</span>               <span class="c1">// zero initial threshold signifies using defaults
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 则以默认容量作为newCap的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">;</span><span class="c1">//16
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 以初始容量*默认负载因子的结果作为newThr值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">*</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 经过上面的处理过程，如果newThr值为0，说明上面是进入到了原容量不大于0，旧阈值大于0的判断分支。需要单独给newThr进行赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">newThr</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">       <span class="c1">// 临时阈值 = 新容量 * 负载因子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">newCap</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">       <span class="c1">// 设置新的阈值 保证新容量小于最大总量   阈值要小于最大容量，否则阈值就设置为int最大值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span> <span class="n">ft</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">MAXIMUM_CAPACITY</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">                  <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">ft</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将新的阈值newThr赋值给threshold，为新初始化的HashMap来使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">threshold</span> <span class="o">=</span> <span class="n">newThr</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">&#34;rawtypes&#34;</span><span class="o">,</span><span class="s">&#34;unchecked&#34;</span><span class="o">})</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//创建新的表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">newTab</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="n">Node</span><span class="o">[</span><span class="n">newCap</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//将新创建的表赋值给当前类成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">table</span> <span class="o">=</span> <span class="n">newTab</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//如果旧表不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//将旧表的元素移动到新表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果原来的HashMap中有值，则遍历oldTab，取出每一个键值对，存入到新table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oldCap</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 创建一个临时变量e用来指向oldTab中的第j个键值对
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 将oldTab[j]赋值给e并且判断原来table数组中第j个位置是否不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 如果不为空，则将oldTab[j]置为null，释放内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 如果e.next = null，说明该位置的数组桶上没有连着额外的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                     <span class="c1">// 此时以e.hash&amp;(newCap-1)的结果作为e在newTab中的位置，将e直接放置在新数组的新位置即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">newTab</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">-</span> <span class="n">1</span><span class="o">)]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 否则说明e的后面连接着链表或者红黑树，判断e的类型是TreeNode还是Node,即链表和红黑树判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">//调用相关方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">e</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">newTab</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">oldCap</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 当前节不是红黑树，不是null，并且还有下一个元素。那么此时为链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">else</span> <span class="o">{</span> <span class="c1">// preserve order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">                        这里定义了五个Node变量，其中lo和hi是，lower和higher的缩写，也就是高位和低位,
</span></span></span><span class="line"><span class="cl"><span class="cm">                        因为我们知道HashMap扩容时，容量会扩到原容量的2倍，
</span></span></span><span class="line"><span class="cl"><span class="cm">                        也就是放在链表中的Node的位置可能保持不变或位置变成 原位置+oldCap,在原位置基础上又加了一个数，位置变高了，
</span></span></span><span class="line"><span class="cl"><span class="cm">                        这里的高低位就是这个意思，低位指向的是保持原位置不变的节点，高位指向的是需要更新位置的节点
</span></span></span><span class="line"><span class="cl"><span class="cm">                    */</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// Head指向的是链表的头节点，Tail指向的是链表的尾节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">loHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">hiHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 指向当前遍历到的节点的下一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">//遍历链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">do</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">//原索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">                            如果e.hash &amp; oldCap == 0，注意这里是oldCap，而不是oldCap-1。
</span></span></span><span class="line"><span class="cl"><span class="cm">                            我们知道oldCap是2的次幂，也就是1、2、4、8、16...转化为二进制之后，
</span></span></span><span class="line"><span class="cl"><span class="cm">                            都是最高位为1，其它位为0。所以oldCap &amp; e.hash 也是只有e.hash值在oldCap二进制不为0的位对应的位也不为0时，
</span></span></span><span class="line"><span class="cl"><span class="cm">                            才会得到一个不为0的结果。举个例子，我们知道10010 和00010 与1111的&amp;运算结果都是 0010  ，
</span></span></span><span class="line"><span class="cl"><span class="cm">                            但是110010和010010与10000的运算结果是不一样的，所以HashMap就是利用这一点，
</span></span></span><span class="line"><span class="cl"><span class="cm">                            来判断当前在链表中的数据，在扩容时位置是保持不变还是位置移动oldCap。
</span></span></span><span class="line"><span class="cl"><span class="cm">                        */</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">// 如果结果为0，即位置保持不变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">oldCap</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                            <span class="c1">// 如果是第一次遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                                <span class="c1">// 让loHead = e，设置头节点 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="n">loHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                                <span class="c1">// 否则,让loTail的next = e
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                            <span class="c1">// 最后让loTail = e 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="n">loTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">}</span>
</span></span><span class="line"><span class="cl">                        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">                            其实if 和else 中做的事情是一样的，本质上就是将不需要更新位置的节点加入到loHead为头节点的低位链表中，将需要更新位置的节点加入到hiHead为头结点的高位链表中。
</span></span></span><span class="line"><span class="cl"><span class="cm">                            我们看到有loHead和loTail两个Node,loHead为头节点，然后loTail是尾节点，在遍历的时候用来维护loHead，即每次循环，
</span></span></span><span class="line"><span class="cl"><span class="cm">                            更新loHead的next。我们来举个例子，比如原来的链表是A-&gt;B-&gt;C-&gt;D-&gt;E。
</span></span></span><span class="line"><span class="cl"><span class="cm">                            我们这里把-&gt;假设成next关系，这五个Node中，只有C的hash &amp; oldCap != 0 ,
</span></span></span><span class="line"><span class="cl"><span class="cm">                            然后这个代码执行过程就是:
</span></span></span><span class="line"><span class="cl"><span class="cm">                            第一次循环： 先拿到A，把A赋给loHead,然后loTail也是A
</span></span></span><span class="line"><span class="cl"><span class="cm">                            第二次循环： 此时e的为B，而且loTail != null,也就是进入上面的else分支，把loTail.next =                     
</span></span></span><span class="line"><span class="cl"><span class="cm">                                        B，此时loTail中即A-&gt;B,同样反应在loHead中也是A-&gt;B,然后把loTail = B
</span></span></span><span class="line"><span class="cl"><span class="cm">                            第三次循环： 此时e = C，由于C不满足 (e.hash &amp; oldCap) == 0,进入到了我们下面的else分支，其 
</span></span></span><span class="line"><span class="cl"><span class="cm">                                        实做的事情和当前分支的意思一样，只不过维护的是hiHead和hiTail。
</span></span></span><span class="line"><span class="cl"><span class="cm">                            第四次循环： 此时e的为D，loTail != null,进入上面的else分支，把loTail.next =                     
</span></span></span><span class="line"><span class="cl"><span class="cm">                                        D，此时loTail中即B-&gt;D,同样反应在loHead中也是A-&gt;B-&gt;D,然后把loTail = D
</span></span></span><span class="line"><span class="cl"><span class="cm">                        */</span>
</span></span><span class="line"><span class="cl">                        <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                            <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                               <span class="n">hiHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                                <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                            <span class="n">hiTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">}</span>
</span></span><span class="line"><span class="cl">                   <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 遍历结束，即把table[j]中所有的Node处理完
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 如果loTail不为空，也保证了loHead不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                     <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">// 此时把loTail的next置空，将低位链表构造完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">// 把loHead放在newTab数组的第j个位置上，也就是这些节点保持在数组中的原位置不变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">newTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                     <span class="o">}</span>
</span></span><span class="line"><span class="cl">                     <span class="c1">// 同理，只不过hiHead中节点放的位置是j+oldCap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                     <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">// hiHead链表中的节点都是需要更新位置的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">newTab</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">oldCap</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                     <span class="o">}</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//返回新的表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">newTab</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><hr>
<h3 id="35-get方法">3.5 get()方法</h3>
<p>get方法调用内部默认方法getNode获取值，查询到返回值，查询不到返回null</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>以下为getNode方法源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">* 按照传入的hash码和key值查询节点，并且返回节点
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">getNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="c1">//存储数组的临时变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">,</span> <span class="n">e</span><span class="o">;</span> <span class="c1">// first存储数组index的第一个Node节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span> <span class="n">K</span> <span class="n">k</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//(tab = table) != null 当前table不能为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//(n = tab.length) &gt; 0 table的长度必须大于0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//(first = tab[(n - 1) &amp; hash]) != null 查找index位置的第一个节点不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="o">(</span><span class="n">first</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//first.hash == hash 如果第一个节点的hash与查找的hash值相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//(k = first.key) == key first的键和查找的键地址相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//(key != null &amp;&amp; key.equals(k)) 键值不为空，并且first的键内容和key内容相等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="c1">// always check first node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">first</span><span class="o">;</span><span class="c1">//返回第一个值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//没有找到目标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//如果(e = first.next) != null first含有下一个节点并不为空，将其赋值给e
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//如果第一个节点是红黑树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//调用getTreeNode方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">return</span> <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">first</span><span class="o">).</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//否则
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//遍历查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">do</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//查不到 返回null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><hr>
<h3 id="36-remove方法">3.6 remove()方法</h3>
<p>remove()方法有两个</p>
<p>1.remove方法输入目标key值，存在就删除，并返回目标的值，不存在就返回null</p>
<p>2.remove方法输入目标key值，存在就删除，并返回true，不存在就返回false</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">V</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">        <span class="kc">null</span> <span class="o">:</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nd">@Override</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>remove方法调用了hashmap内的默认方法removeNode()</p>
<p>以下是removeNode()的源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">    移除某个节点，根据下面四个条件进行移除
</span></span></span><span class="line"><span class="cl"><span class="cm">    hash - key 的hash值 
</span></span></span><span class="line"><span class="cl"><span class="cm">    key - key
</span></span></span><span class="line"><span class="cl"><span class="cm">    matchValue - 如果为true，则仅在值相等时删除；如果是false，则值不管相不相等，只要key和hash值一致就移除该节点。
</span></span></span><span class="line"><span class="cl"><span class="cm">    movable - 如果为false，则在删除时不移动其他节点
</span></span></span><span class="line"><span class="cl"><span class="cm">    return - 返回被移除节点，未找到则返回null
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">removeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                           <span class="kt">boolean</span> <span class="n">matchValue</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">movable</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span><span class="c1">//当前table数组的临时存储变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span> <span class="c1">//table[index]的第一个节点/遍历的前节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">index</span><span class="o">;</span><span class="c1">//n:数组长度，index:数组的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//(tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 判断数组非空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//(p = tab[index = (n - 1) &amp; hash]) != null 查询要删除的节点位于数组中的下标，并将下标的第一位交给临时变量p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//node被移除的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//e指向第一个节点p的下一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">K</span> <span class="n">k</span><span class="o">;</span> <span class="n">V</span> <span class="n">v</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//如果第一个节点p就是目标节点，就将node指向p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
</span></span><span class="line"><span class="cl">            <span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//否则
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//如果p的下一个节点不为空，将其赋值给e
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//判断第一个节点p是否是数节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//调用getTreeNode方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">node</span> <span class="o">=</span> <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//如果不是树节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//循环查找需要删除的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">do</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">//如果查找到就将node指向e 并退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">                         <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">node</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                        <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">}</span>
</span></span><span class="line"><span class="cl">                    <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//找到目标节点了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//matchValue为true，则仅在值相等时删除。如果是false，则值不管相不相等，只要key和hash值一致就移除该节点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="n">matchValue</span> <span class="o">||</span> <span class="o">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">==</span> <span class="n">value</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">                             <span class="o">(</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">v</span><span class="o">))))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//如果是红黑树就调用树的删除方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">node</span><span class="o">).</span><span class="na">removeTreeNode</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">movable</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//如果node 是table[index]的第一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//就跳过p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//否则p作为前节点，直接跳过node节点，指向下一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//记录操作次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//较小大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">--</span><span class="n">size</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">afterNodeRemoval</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//返回被删除节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><hr>
<h2 id="4treenode源码">4.TreeNode源码</h2>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2022-11-19</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/hashmap%E8%AF%A6%E8%A7%A3/index.md" target="_blank">Read Markdown</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="http://zxlkgf.github.io/hashmap%E8%AF%A6%E8%A7%A3/" data-title="HashMap详解" data-hashtags="HashMap"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="http://zxlkgf.github.io/hashmap%E8%AF%A6%E8%A7%A3/" data-hashtag="HashMap"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="http://zxlkgf.github.io/hashmap%E8%AF%A6%E8%A7%A3/" data-title="HashMap详解"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="http://zxlkgf.github.io/hashmap%E8%AF%A6%E8%A7%A3/" data-title="HashMap详解"><i data-svg-src="/lib/simple-icons/icons/line.min.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="http://zxlkgf.github.io/hashmap%E8%AF%A6%E8%A7%A3/" data-title="HashMap详解"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/hashmap/">HashMap</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/%E9%9B%86%E5%90%88%E7%B1%BB/" class="prev" rel="prev" title="集合类"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>集合类</a>
            <a href="/hashmap-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/" class="next" rel="next" title="HashMap 循环链表">HashMap 循环链表<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.101.0">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/zxlkgf" target="_blank">Cyo</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.example.com/some.css"><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/typeit/index.umd.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/mhchem.min.js"></script><script type="text/javascript" src="/lib/cookieconsent/cookieconsent.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"data":{"id-1":"Cyo's blog","id-2":"Cyo's blog"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","maxResultLength":10,"noResultsFound":"No results found","snippetLength":50,"type":"lunr"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
