# 进程


# 进程
## 查看进程
    ps aux/ajx
a:显示终端上所有进程，包括其他用户的进程  
u:显示进程的详细信息  
x:显示没有控制终端的进程  
j:列出与作业息息相关的信息  

## 进程相关STAT参数
D   不可中断  
R   正在运行，或在队列中的进程  
S   休眠状态  
T   停止或被追踪  
Z   僵尸进程  
W   进入内存交换(kneral2.6开始无效)  
X   死掉的进程  
<   高优先级    
N   低优先级  
s   包含子进程  
\+   位于前台的进程组  

## 进程相关命令
top  
可以再使用top命令上加-G来指定显示信息更新的时间间隔，在top命令执行后，可以按一下按键显示的结果进行排序：  
M   根据内存使用量排序  
P   根据CPU占有率进行排序  
T   根据进程运行时间长短排序  
U   根据用户名来筛选  
K   输入指定的PID杀死线程  

## 杀死进程
kill [-signal] pid  
kill -l 列出所有信号  
kill -SIGKILL 进程ID  
kill -9 进程ID  
killall name 根据进程名杀死进程

## 进程号和相关函数
1.每个进程都由进程号来标识，其类型为pid_t(整型),进程号的范围为0-32767，进程号总是唯一的，但可以重复使用  
2.任何进程(除了init进程)都是由另一个进程创建，该进程成为被创建进程的父进程，对于的进程号为父进程号(PPID)  
3.进程组是一个或多个进程的集合，他们之间互相关联，进程组可以接受同一终端的各种信号，关联的进程有一个进程组号(PGID)，默认情况下，当前的进程号会当做当前的进程组号  
4.进程号和进程组的相关函数  
pid_t getpid(void);  
pid_t getppid(void);   
pid_t getpgid(void);  


## 孤儿进程
1.父进程允许结束，但是子进程还在运行，这样的进程成为孤儿进程  
2.每当出现一个孤儿进程的时候，内存就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。  
3.因此孤儿进程并不是什么危害  

## 僵尸进程
1.每个进程结束之后，，都会释放自己地址空间中的用户数据，内核区的pcb没有办法自己去释放需要父进程去释放  
2.进程终止时，父进程尚未回收，子进程残留资源(pcb)存放于内核中，变成僵尸进程  
3.僵尸进程不可被kill -9杀死  
4.这样会导致一个问题 ，父进程不调用wait()或者waitpid()的话，那么保留的那段信息不会被释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的僵尸进程产生，，将因为没有可以使用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害  

## 进程回收
1.在每个进程退出的时候，内核释放进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息，这些信息主要指向控制块PCB的信息  
2.父进程可以通过调用wait或者waitpid得到它的退出状态同时彻底清除掉这个进程。
3.wait()和waitpid()函数功能一样，区别在于，wait()函数会阻塞，waitpid()可以设置不阻塞，waitpid()可以指定等待哪个子进程结束。
4.注意 一次wait或waitpid调用只能清理一个子进程，清理多个子进程需要循环

## 退出信息相关宏函数
WIFEXITED(status)       非0 进程正常退出  

WEXITSTATUS(status)     如果宏为真，获取进程退出的状态  

WIFSIGNALED(status)     非0 进程异常退出  

WTERMSIG(status)        如果上宏为真，获取使进程停止的信号编号  

WIFSTOPPED(status)      非0 进程处于暂停  

WSTOPSIG(status)        如果上宏为真，获取使进程暂停的信号的编号  

WIFCONTINUED(status)    非0 进程暂停后已经继续运行  
